{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LOLStonks API Gateway","text":"<p>Production-grade Riot Games API Gateway engineered for high-performance applications with intelligent caching, automatic rate limiting, and comprehensive observability.</p> <p></p>"},{"location":"#enterprise-features","title":"Enterprise Features","text":""},{"location":"#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Sub-100ms Response Times: Optimized for high-throughput applications</li> <li>Async Architecture: Built on FastAPI with full async/await support</li> <li>Horizontal Scaling: Stateless design enables multi-instance deployment</li> <li>Connection Pooling: Efficient resource management for high concurrency</li> </ul>"},{"location":"#reliability-resilience","title":"Reliability &amp; Resilience","text":"<ul> <li>Intelligent Rate Limiting: Token bucket algorithm ensures Riot API compliance</li> <li>Automatic Retries: Exponential backoff for 429 responses with configurable limits</li> <li>Circuit Breaker Pattern: Fault tolerance for external API dependencies</li> <li>Graceful Degradation: Continue operation during partial outages</li> </ul>"},{"location":"#intelligent-caching","title":"Intelligent Caching","text":"<ul> <li>Multi-Layer Caching: Redis-based with strategic TTL configuration</li> <li>High Cache Hit Rates: Optimized caching strategy for frequently accessed data</li> <li>Smart Invalidation: Automatic cache updates based on data freshness</li> <li>Memory Optimization: Efficient cache key management and eviction policies</li> </ul>"},{"location":"#observability-monitoring","title":"Observability &amp; Monitoring","text":"<ul> <li>Comprehensive Metrics: Prometheus-compatible metrics for full stack monitoring</li> <li>Structured Logging: JSON-formatted logs with request tracing</li> <li>Health Checks: Multi-level health monitoring for all dependencies</li> <li>Performance Analytics: Real-time performance insights and alerting</li> </ul>"},{"location":"#developer-experience","title":"Developer Experience","text":"<ul> <li>Type-Safe API: Full Pydantic model validation with comprehensive error handling</li> <li>Interactive Documentation: Auto-generated OpenAPI specs with Swagger UI and ReDoc</li> <li>Multi-Region Support: Complete coverage of all Riot API regions</li> <li>UV Integration: Modern Python package management with fast dependency resolution</li> </ul>"},{"location":"#production-ready","title":"Production Ready","text":"<ul> <li>Container-Native: Docker support with optimized images</li> <li>Security Hardened: Input validation, CORS protection, and secure defaults</li> <li>Configuration Management: Environment-based configuration with validation</li> <li>CI/CD Integration: Automated testing, documentation generation, and deployment</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.12+ with UV package manager</li> <li>Redis 6.0+ for caching and session management</li> <li>Riot Developer API key from developer.riotgames.com</li> </ul>"},{"location":"#installation-with-uv-recommended","title":"Installation with UV (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Install dependencies with UV\nuv pip install -e \".[docs]\"\n\n# Create environment configuration\ncp .env.example .env\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>Edit your <code>.env</code> file with your settings:</p> <pre><code># Required: Riot API Configuration\nRIOT_API_KEY=RGAPI-your-production-api-key\nRIOT_DEFAULT_REGION=euw1\n\n# Optional: Server Configuration\nHOST=0.0.0.0\nPORT=8080\nLOG_LEVEL=INFO\n\n# Optional: Redis Configuration\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=\n\n# Optional: Performance Tuning\nRIOT_RATE_LIMIT_PER_SECOND=20\nRIOT_RATE_LIMIT_PER_2MIN=100\n</code></pre>"},{"location":"#launch-the-gateway","title":"Launch the Gateway","text":"<pre><code># Start with uvicorn (development)\nuv run uvicorn app.main:app --reload\n\n# Or with the provided script\nuv run python -m app.main\n</code></pre>"},{"location":"#verify-installation","title":"Verify Installation","text":"<pre><code># Health check endpoint\ncurl http://127.0.0.1:8080/health\n\n# Expected response\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-01T12:00:00.000Z\",\n  \"version\": \"1.0.0\"\n}\n\n# Interactive documentation\n# Open http://localhost:8080/docs in your browser\n</code></pre>"},{"location":"#production-deployment","title":"Production Deployment","text":"<p>For production deployment, see our comprehensive Deployment Guide which covers: - Docker containerization - Process management with systemd - Nginx reverse proxy configuration - SSL/TLS setup with Let's Encrypt - Monitoring and alerting setup</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation Guide - Detailed setup instructions</li> <li>Quick Start - Basic usage examples</li> <li>Configuration - Environment variables and settings</li> <li>API Reference - Complete API documentation</li> <li>Architecture - System design and components</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Interactive API Docs: Swagger UI | ReDoc</li> <li>Riot Developer Portal: developer.riotgames.com</li> <li>GitHub Repository: github.com/OneStepAt4time/lolstonks-api-gateway</li> </ul>"},{"location":"#example-usage","title":"Example Usage","text":""},{"location":"#get-summoner-by-name","title":"Get Summoner by Name","text":"<pre><code>import httpx\n\nresponse = httpx.get(\"http://localhost:8080/summoner/by-name/Faker?region=kr\")\nsummoner = response.json()\nprint(f\"Summoner: {summoner['name']} (Level: {summoner['summonerLevel']})\")\n</code></pre>"},{"location":"#get-current-match","title":"Get Current Match","text":"<pre><code>summoner_id = \"summoner-id-here\"\nresponse = httpx.get(f\"http://localhost:8080/spectator/active-game/{summoner_id}?region=kr\")\ngame = response.json()\nprint(f\"Game mode: {game['gameMode']}, Game time: {game['gameLength']}s\")\n</code></pre>"},{"location":"#get-match-history","title":"Get Match History","text":"<pre><code>puuid = \"player-puuid-here\"\nresponse = httpx.get(f\"http://localhost:8080/match/ids/by-puuid/{puuid}?region=euw1&amp;count=5\")\nmatch_ids = response.json()\nprint(f\"Recent matches: {match_ids}\")\n</code></pre>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>The LOLStonks API Gateway consists of several key components:</p> <ul> <li>FastAPI Application: Modern async web framework with automatic documentation</li> <li>Riot Client: HTTP client with rate limiting and retry logic</li> <li>Redis Cache: High-performance caching layer for API responses</li> <li>Match Tracking: Service to prevent duplicate match processing</li> <li>Router Layer: Organized API endpoints mirroring Riot's API structure</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details on how to get started.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#development-status","title":"Development Status","text":"<ul> <li>Stable: Core API Gateway functionality</li> <li>Active Development: Documentation system, monitoring, and additional features</li> <li>Production Ready: Suitable for production deployments with proper monitoring</li> </ul> <p>Built for the League of Legends developer community</p>"},{"location":"api/cache/","title":"Caching System","text":"<p>This section documents the caching infrastructure used throughout the API Gateway for performance optimization and rate limit compliance.</p>"},{"location":"api/cache/#redis-cache-configuration","title":"Redis Cache Configuration","text":""},{"location":"api/cache/#app.cache.redis_cache","title":"<code>app.cache.redis_cache</code>","text":"<p>Redis cache configuration using aiocache.</p> <p>Provides temporary TTL-based caching for API responses. Cache keys follow pattern: {resource}:{region}:{identifier}</p>"},{"location":"api/cache/#match-tracking-service","title":"Match Tracking Service","text":""},{"location":"api/cache/#app.cache.tracking","title":"<code>app.cache.tracking</code>","text":"<p>Match tracking service using Redis SETs.</p> <p>Provides permanent tracking of processed matches to avoid reprocessing. Uses Redis SETs with NO TTL - data persists across restarts via appendonly file.</p>"},{"location":"api/cache/#app.cache.tracking.MatchTracker","title":"<code>MatchTracker()</code>","text":"<p>Track processed matches in Redis using SET data structure.</p> <p>Key pattern: processed_matches:{region} No TTL - permanent storage backed by Redis appendonly file.</p> <p>Initialize tracker (connection established on startup).</p> Source code in <code>app/cache/tracking.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize tracker (connection established on startup).\"\"\"\n    self.redis: redis.Redis | None = None\n    logger.info(\"Match tracker initialized (connection pending)\")\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Establish Redis connection.</p> <p>Should be called during FastAPI startup event.</p> Source code in <code>app/cache/tracking.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Establish Redis connection.\n\n    Should be called during FastAPI startup event.\n    \"\"\"\n    redis_url = f\"redis://{settings.redis_host}:{settings.redis_port}/{settings.redis_db}\"\n    if settings.redis_password:\n        redis_url = f\"redis://:{settings.redis_password}@{settings.redis_host}:{settings.redis_port}/{settings.redis_db}\"\n\n    self.redis = await redis.from_url(redis_url, decode_responses=True)\n    logger.success(\"Match tracker connected to Redis\")\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close Redis connection.</p> Source code in <code>app/cache/tracking.py</code> <pre><code>async def close(self):\n    \"\"\"Close Redis connection.\"\"\"\n    if self.redis:\n        await self.redis.aclose()  # type: ignore[attr-defined]\n        logger.info(\"Match tracker connection closed\")\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.is_processed","title":"<code>is_processed(region: str, match_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Check if a match has already been processed.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1')</p> required <code>match_id</code> <code>str</code> <p>Match ID (e.g., 'EUW1_123456789')</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if match is in tracking set, False otherwise</p> Source code in <code>app/cache/tracking.py</code> <pre><code>async def is_processed(self, region: str, match_id: str) -&gt; bool:\n    \"\"\"\n    Check if a match has already been processed.\n\n    Args:\n        region: Region code (e.g., 'euw1')\n        match_id: Match ID (e.g., 'EUW1_123456789')\n\n    Returns:\n        True if match is in tracking set, False otherwise\n    \"\"\"\n    if not self.redis:\n        logger.warning(\"Redis not connected, assuming match not processed\")\n        return False\n\n    key = f\"processed_matches:{region}\"\n    is_member = await self.redis.sismember(key, match_id)\n    return bool(is_member)\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.mark_processed","title":"<code>mark_processed(region: str, match_id: str)</code>  <code>async</code>","text":"<p>Mark a match as processed.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1')</p> required <code>match_id</code> <code>str</code> <p>Match ID (e.g., 'EUW1_123456789')</p> required Source code in <code>app/cache/tracking.py</code> <pre><code>async def mark_processed(self, region: str, match_id: str):\n    \"\"\"\n    Mark a match as processed.\n\n    Args:\n        region: Region code (e.g., 'euw1')\n        match_id: Match ID (e.g., 'EUW1_123456789')\n    \"\"\"\n    if not self.redis:\n        logger.warning(\"Redis not connected, cannot mark match as processed\")\n        return\n\n    key = f\"processed_matches:{region}\"\n    await self.redis.sadd(key, match_id)\n    logger.debug(\"Marked match as processed: {}/{}\", region, match_id)\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.get_processed_count","title":"<code>get_processed_count(region: str) -&gt; int</code>  <code>async</code>","text":"<p>Get count of processed matches for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1')</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of tracked matches for the region</p> Source code in <code>app/cache/tracking.py</code> <pre><code>async def get_processed_count(self, region: str) -&gt; int:\n    \"\"\"\n    Get count of processed matches for a region.\n\n    Args:\n        region: Region code (e.g., 'euw1')\n\n    Returns:\n        Number of tracked matches for the region\n    \"\"\"\n    if not self.redis:\n        return 0\n\n    key = f\"processed_matches:{region}\"\n    return await self.redis.scard(key)\n</code></pre>"},{"location":"api/models/","title":"Pydantic Models","text":"<p>This section contains all the Pydantic models used throughout the API Gateway for request/response validation and data serialization.</p>"},{"location":"api/models/#common-models","title":"Common Models","text":""},{"location":"api/models/#app.models.common","title":"<code>app.models.common</code>","text":"<p>Common reusable models for API inputs.</p> <p>These models contain shared parameters used across multiple endpoints.</p>"},{"location":"api/models/#app.models.common.PlatformRegion","title":"<code>PlatformRegion</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Platform regions for regional routing (ACCOUNT, MATCH APIs).</p>"},{"location":"api/models/#app.models.common.GameRegion","title":"<code>GameRegion</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Game regions for platform-specific endpoints.</p>"},{"location":"api/models/#app.models.common.QueueType","title":"<code>QueueType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Queue types for League of Legends.</p> <p>Includes ranked, normal, and special game modes.</p>"},{"location":"api/models/#app.models.common.Tier","title":"<code>Tier</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>League tier/rank levels.</p> <p>Used for: - Ranked league entries and progression (IRON \u2192 CHALLENGER) - Challenge progression (all tiers) - Challenge leaderboards (MASTER, GRANDMASTER, CHALLENGER only)</p>"},{"location":"api/models/#app.models.common.Division","title":"<code>Division</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Division within a tier.</p> <p>Used for Iron through Diamond (and Emerald) tiers. Master, Grandmaster, and Challenger don't use divisions.</p>"},{"location":"api/models/#app.models.common.EnumBaseModel","title":"<code>EnumBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model that serializes enums as values.</p>"},{"location":"api/models/#app.models.common.RegionQuery","title":"<code>RegionQuery</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Standard region query parameter for game-specific endpoints.</p>"},{"location":"api/models/#app.models.common.PlatformRegionQuery","title":"<code>PlatformRegionQuery</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Regional routing parameter for platform endpoints (ACCOUNT, MATCH).</p>"},{"location":"api/models/#app.models.common.PaginationQuery","title":"<code>PaginationQuery</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pagination parameters for list endpoints.</p>"},{"location":"api/models/#app.models.common.HasPuuid","title":"<code>HasPuuid</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a PUUID path parameter.</p>"},{"location":"api/models/#app.models.common.HasEncryptedSummonerId","title":"<code>HasEncryptedSummonerId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include an encrypted summoner ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasEncryptedPuuid","title":"<code>HasEncryptedPuuid</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include an encrypted PUUID path parameter.</p>"},{"location":"api/models/#app.models.common.HasMatchId","title":"<code>HasMatchId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a match ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasChampionId","title":"<code>HasChampionId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a champion ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasChallengeId","title":"<code>HasChallengeId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a challenge ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasTeamId","title":"<code>HasTeamId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a team ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasTournamentId","title":"<code>HasTournamentId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a tournament ID path parameter.</p>"},{"location":"api/models/#model-classes","title":"Model Classes","text":"<p>The following model classes provide request/response schemas for various Riot API endpoints:</p>"},{"location":"api/models/#account-models","title":"Account Models","text":""},{"location":"api/models/#app.models.account","title":"<code>app.models.account</code>","text":"<p>ACCOUNT-V1 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#account-v1</p>"},{"location":"api/models/#app.models.account.AccountByPuuidParams","title":"<code>AccountByPuuidParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /riot/account/v1/accounts/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.account.AccountByPuuidQuery","title":"<code>AccountByPuuidQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /riot/account/v1/accounts/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.account.AccountByRiotIdParams","title":"<code>AccountByRiotIdParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Path parameters for GET /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}.</p>"},{"location":"api/models/#app.models.account.AccountByRiotIdQuery","title":"<code>AccountByRiotIdQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}.</p>"},{"location":"api/models/#app.models.account.ActiveShardParams","title":"<code>ActiveShardParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.account.ActiveShardQuery","title":"<code>ActiveShardQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}.</p>"},{"location":"api/models/#summoner-models","title":"Summoner Models","text":""},{"location":"api/models/#app.models.summoner","title":"<code>app.models.summoner</code>","text":"<p>SUMMONER-V4 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#summoner-v4</p>"},{"location":"api/models/#app.models.summoner.SummonerByNameParams","title":"<code>SummonerByNameParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Path parameters for GET /lol/summoner/v4/summoners/by-name/{summonerName}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByNameQuery","title":"<code>SummonerByNameQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/summoner/v4/summoners/by-name/{summonerName}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByPuuidParams","title":"<code>SummonerByPuuidParams</code>","text":"<p>               Bases: <code>HasEncryptedPuuid</code></p> <p>Path parameters for GET /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByPuuidQuery","title":"<code>SummonerByPuuidQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByIdParams","title":"<code>SummonerByIdParams</code>","text":"<p>               Bases: <code>HasEncryptedSummonerId</code></p> <p>Path parameters for GET /lol/summoner/v4/summoners/{encryptedSummonerId}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByIdQuery","title":"<code>SummonerByIdQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/summoner/v4/summoners/{encryptedSummonerId}.</p>"},{"location":"api/models/#match-models","title":"Match Models","text":""},{"location":"api/models/#app.models.match","title":"<code>app.models.match</code>","text":"<p>MATCH-V5 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#match-v5</p>"},{"location":"api/models/#app.models.match.MatchIdsByPuuidParams","title":"<code>MatchIdsByPuuidParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/match/v5/matches/by-puuid/{puuid}/ids.</p>"},{"location":"api/models/#app.models.match.MatchIdsByPuuidQuery","title":"<code>MatchIdsByPuuidQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code>, <code>PaginationQuery</code></p> <p>Query parameters for GET /lol/match/v5/matches/by-puuid/{puuid}/ids.</p> <p>Includes optional filtering parameters for match discovery.</p>"},{"location":"api/models/#app.models.match.MatchParams","title":"<code>MatchParams</code>","text":"<p>               Bases: <code>HasMatchId</code></p> <p>Path parameters for GET /lol/match/v5/matches/{matchId}.</p>"},{"location":"api/models/#app.models.match.MatchQuery","title":"<code>MatchQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /lol/match/v5/matches/{matchId}.</p>"},{"location":"api/models/#app.models.match.MatchTimelineParams","title":"<code>MatchTimelineParams</code>","text":"<p>               Bases: <code>HasMatchId</code></p> <p>Path parameters for GET /lol/match/v5/matches/{matchId}/timeline.</p>"},{"location":"api/models/#app.models.match.MatchTimelineQuery","title":"<code>MatchTimelineQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /lol/match/v5/matches/{matchId}/timeline.</p>"},{"location":"api/models/#league-models","title":"League Models","text":""},{"location":"api/models/#app.models.league","title":"<code>app.models.league</code>","text":"<p>LEAGUE-V4 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#league-v4</p>"},{"location":"api/models/#app.models.league.LeagueByQueueParams","title":"<code>LeagueByQueueParams</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Path parameters for challenger/grandmaster/master league endpoints.</p>"},{"location":"api/models/#app.models.league.LeagueByQueueQuery","title":"<code>LeagueByQueueQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for challenger/grandmaster/master league endpoints.</p>"},{"location":"api/models/#app.models.league.LeagueEntriesBySummonerParams","title":"<code>LeagueEntriesBySummonerParams</code>","text":"<p>               Bases: <code>HasEncryptedSummonerId</code></p> <p>Path parameters for GET /lol/league/v4/entries/by-summoner/{encryptedSummonerId}.</p>"},{"location":"api/models/#app.models.league.LeagueEntriesBySummonerQuery","title":"<code>LeagueEntriesBySummonerQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/league/v4/entries/by-summoner/{encryptedSummonerId}.</p>"},{"location":"api/models/#app.models.league.LeagueEntriesParams","title":"<code>LeagueEntriesParams</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Path parameters for GET /lol/league/v4/entries/{queue}/{tier}/{division}.</p>"},{"location":"api/models/#app.models.league.LeagueEntriesQuery","title":"<code>LeagueEntriesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/league/v4/entries/{queue}/{tier}/{division}.</p>"},{"location":"api/models/#league-exp-models","title":"League EXP Models","text":""},{"location":"api/models/#app.models.league_exp","title":"<code>app.models.league_exp</code>","text":"<p>LEAGUE-EXP-V4 API input models (Experimental).</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#league-exp-v4</p> <p>Note: This is an experimental API that provides paginated league entries. It's similar to LEAGUE-V4 but with different pagination support.</p>"},{"location":"api/models/#app.models.league_exp.LeagueExpEntriesParams","title":"<code>LeagueExpEntriesParams</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Path parameters for GET /lol/league-exp/v4/entries/{queue}/{tier}/{division}.</p>"},{"location":"api/models/#app.models.league_exp.LeagueExpEntriesQuery","title":"<code>LeagueExpEntriesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/league-exp/v4/entries/{queue}/{tier}/{division}.</p>"},{"location":"api/models/#champion-mastery-models","title":"Champion Mastery Models","text":""},{"location":"api/models/#app.models.champion_mastery","title":"<code>app.models.champion_mastery</code>","text":"<p>CHAMPION-MASTERY-V4 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#champion-mastery-v4</p>"},{"location":"api/models/#app.models.champion_mastery.ChampionMasteryByPuuidParams","title":"<code>ChampionMasteryByPuuidParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.champion_mastery.ChampionMasteryByPuuidQuery","title":"<code>ChampionMasteryByPuuidQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.champion_mastery.ChampionMasteryByPuuidByChampionParams","title":"<code>ChampionMasteryByPuuidByChampionParams</code>","text":"<p>               Bases: <code>HasPuuid</code>, <code>HasChampionId</code></p> <p>Path parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}.</p>"},{"location":"api/models/#app.models.champion_mastery.ChampionMasteryByPuuidByChampionQuery","title":"<code>ChampionMasteryByPuuidByChampionQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}.</p>"},{"location":"api/models/#app.models.champion_mastery.TopChampionMasteriesParams","title":"<code>TopChampionMasteriesParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top.</p>"},{"location":"api/models/#app.models.champion_mastery.TopChampionMasteriesQuery","title":"<code>TopChampionMasteriesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top.</p>"},{"location":"api/models/#app.models.champion_mastery.MasteryScoreParams","title":"<code>MasteryScoreParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/champion-mastery/v4/scores/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.champion_mastery.MasteryScoreQuery","title":"<code>MasteryScoreQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/champion-mastery/v4/scores/by-puuid/{puuid}.</p>"},{"location":"api/models/#challenges-models","title":"Challenges Models","text":""},{"location":"api/models/#app.models.challenges","title":"<code>app.models.challenges</code>","text":"<p>CHALLENGES-V1 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#lol-challenges-v1</p>"},{"location":"api/models/#app.models.challenges.AllChallengesConfigQuery","title":"<code>AllChallengesConfigQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/challenges/config.</p>"},{"location":"api/models/#app.models.challenges.ChallengeConfigParams","title":"<code>ChallengeConfigParams</code>","text":"<p>               Bases: <code>HasChallengeId</code></p> <p>Path parameters for GET /lol/challenges/v1/challenges/{challengeId}/config.</p>"},{"location":"api/models/#app.models.challenges.ChallengeConfigQuery","title":"<code>ChallengeConfigQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/challenges/{challengeId}/config.</p>"},{"location":"api/models/#app.models.challenges.ChallengeLeaderboardParams","title":"<code>ChallengeLeaderboardParams</code>","text":"<p>               Bases: <code>EnumBaseModel</code>, <code>HasChallengeId</code></p> <p>Path parameters for GET /lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}.</p> <p>Note: Leaderboards are only available for top tiers (MASTER, GRANDMASTER, CHALLENGER).</p>"},{"location":"api/models/#app.models.challenges.ChallengeLeaderboardQuery","title":"<code>ChallengeLeaderboardQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}.</p>"},{"location":"api/models/#app.models.challenges.ChallengePercentilesParams","title":"<code>ChallengePercentilesParams</code>","text":"<p>               Bases: <code>HasChallengeId</code></p> <p>Path parameters for GET /lol/challenges/v1/challenges/{challengeId}/percentiles.</p>"},{"location":"api/models/#app.models.challenges.ChallengePercentilesQuery","title":"<code>ChallengePercentilesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/challenges/{challengeId}/percentiles.</p>"},{"location":"api/models/#app.models.challenges.PlayerChallengesParams","title":"<code>PlayerChallengesParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/challenges/v1/player-data/{puuid}.</p>"},{"location":"api/models/#app.models.challenges.PlayerChallengesQuery","title":"<code>PlayerChallengesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/player-data/{puuid}.</p>"},{"location":"api/models/#clash-models","title":"Clash Models","text":""},{"location":"api/models/#app.models.clash","title":"<code>app.models.clash</code>","text":"<p>CLASH-V1 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#clash-v1</p>"},{"location":"api/models/#app.models.clash.ClashPlayerParams","title":"<code>ClashPlayerParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/clash/v1/players/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.clash.ClashPlayerQuery","title":"<code>ClashPlayerQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/players/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.clash.ClashTeamParams","title":"<code>ClashTeamParams</code>","text":"<p>               Bases: <code>HasTeamId</code></p> <p>Path parameters for GET /lol/clash/v1/teams/{teamId}.</p>"},{"location":"api/models/#app.models.clash.ClashTeamQuery","title":"<code>ClashTeamQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/teams/{teamId}.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentsQuery","title":"<code>ClashTournamentsQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/tournaments.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentParams","title":"<code>ClashTournamentParams</code>","text":"<p>               Bases: <code>HasTournamentId</code></p> <p>Path parameters for GET /lol/clash/v1/tournaments/{tournamentId}.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentQuery","title":"<code>ClashTournamentQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/tournaments/{tournamentId}.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentByTeamParams","title":"<code>ClashTournamentByTeamParams</code>","text":"<p>               Bases: <code>HasTeamId</code></p> <p>Path parameters for GET /lol/clash/v1/tournaments/by-team/{teamId}.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentByTeamQuery","title":"<code>ClashTournamentByTeamQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/tournaments/by-team/{teamId}.</p>"},{"location":"api/models/#spectator-models","title":"Spectator Models","text":""},{"location":"api/models/#app.models.spectator","title":"<code>app.models.spectator</code>","text":"<p>SPECTATOR-V5 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#spectator-v5</p>"},{"location":"api/models/#app.models.spectator.ActiveGameParams","title":"<code>ActiveGameParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/spectator/v5/active-games/by-summoner/{puuid}.</p>"},{"location":"api/models/#app.models.spectator.ActiveGameQuery","title":"<code>ActiveGameQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/spectator/v5/active-games/by-summoner/{puuid}.</p>"},{"location":"api/models/#app.models.spectator.FeaturedGamesQuery","title":"<code>FeaturedGamesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/spectator/v5/featured-games.</p>"},{"location":"api/models/#platform-models","title":"Platform Models","text":""},{"location":"api/models/#app.models.platform","title":"<code>app.models.platform</code>","text":"<p>LOL-STATUS-V4 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#lol-status-v4</p>"},{"location":"api/models/#app.models.platform.PlatformStatusQuery","title":"<code>PlatformStatusQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/status/v4/platform-data.</p>"},{"location":"api/models/#champion-models","title":"Champion Models","text":""},{"location":"api/models/#app.models.champion","title":"<code>app.models.champion</code>","text":"<p>CHAMPION-V3 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#champion-v3</p>"},{"location":"api/models/#app.models.champion.ChampionRotationsQuery","title":"<code>ChampionRotationsQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/platform/v3/champion-rotations.</p>"},{"location":"api/openapi-spec/","title":"OpenAPI Specification","text":"<p>This page provides an interactive API documentation using Swagger UI.</p>"},{"location":"api/openapi-spec/#interactive-api-documentation","title":"Interactive API Documentation","text":""},{"location":"api/openapi-spec/#download-specification","title":"Download Specification","text":"<p>You can download the OpenAPI specification in JSON format:</p> <ul> <li>Download OpenAPI JSON</li> </ul>"},{"location":"api/openapi-spec/#api-overview","title":"API Overview","text":"<p>The LOLStonks API Gateway provides a comprehensive REST API for accessing Riot Games data with built-in caching, rate limiting, and enhanced functionality.</p>"},{"location":"api/openapi-spec/#base-url","title":"Base URL","text":"<pre><code>http://localhost:8000\n</code></pre>"},{"location":"api/openapi-spec/#authentication","title":"Authentication","text":"<p>The API requires a Riot Games API key passed via the <code>X-Riot-Token</code> header or configured in the server environment.</p>"},{"location":"api/openapi-spec/#rate-limiting","title":"Rate Limiting","text":"<p>The gateway implements intelligent rate limiting to comply with Riot Games API limits: - Automatic retry with exponential backoff - Request queuing - Rate limit status in response headers</p>"},{"location":"api/openapi-spec/#caching","title":"Caching","text":"<p>Responses are cached in Redis with configurable TTL based on endpoint type: - Static data: Long TTL (hours/days) - Dynamic data: Short TTL (minutes) - Real-time data: No cache or very short TTL</p>"},{"location":"api/openapi-spec/#error-handling","title":"Error Handling","text":"<p>Standard HTTP status codes are used: - <code>200</code> - Success - <code>400</code> - Bad Request - <code>404</code> - Not Found - <code>429</code> - Rate Limit Exceeded - <code>500</code> - Internal Server Error - <code>502</code> - Bad Gateway (Riot API error)</p>"},{"location":"api/overview/","title":"LOL API Gateway","text":"<p>Intelligent proxy for Riot Games API with caching, rate limiting, and match tracking</p> <p>Version: 1.0.0</p> <p>Generated: 2025-10-28 18:34:54 UTC</p>"},{"location":"api/overview/#api-statistics","title":"API Statistics","text":"<ul> <li>Total Endpoints: 34</li> <li>Total Schemas: 7</li> <li>API Base URL: <code>http://localhost:8080</code></li> </ul>"},{"location":"api/overview/#interactive-documentation","title":"Interactive Documentation","text":"<p>When the server is running, you can access:</p> <ul> <li>Swagger UI: http://localhost:8080/docs</li> <li>ReDoc: http://localhost:8080/redoc</li> <li>OpenAPI JSON: http://localhost:8080/openapi.json</li> </ul>"},{"location":"api/overview/#api-endpoints","title":"API Endpoints","text":""},{"location":"api/overview/#health","title":"health","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/health</code> Health Check None Unknown"},{"location":"api/overview/#challenges","title":"challenges","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/challenges/v1/challenges/config</code> Get All Challenges Config Query: region Unknown \ud83d\udfe2 GET <code>/lol/challenges/v1/challenges/{challengeId}/config</code> Get Challenge Config Path: challengeIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}</code> Get Challenge Leaderboard Path: challengeId, levelQuery: region, limit Unknown \ud83d\udfe2 GET <code>/lol/challenges/v1/challenges/{challengeId}/percentiles</code> Get Challenge Percentiles Path: challengeIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/challenges/v1/player-data/{puuid}</code> Get Player Challenges Path: puuidQuery: region Unknown"},{"location":"api/overview/#champion-mastery","title":"champion-mastery","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}</code> Get All Champion Masteries Path: puuidQuery: region Unknown \ud83d\udfe2 GET <code>/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}</code> Get Champion Mastery Path: puuid, championIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top</code> Get Top Champion Masteries Path: puuidQuery: region, count Unknown \ud83d\udfe2 GET <code>/lol/champion-mastery/v4/scores/by-puuid/{puuid}</code> Get Mastery Score Path: puuidQuery: region Unknown"},{"location":"api/overview/#clash","title":"clash","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/clash/v1/players/by-puuid/{puuid}</code> Get Clash Player Path: puuidQuery: region Unknown \ud83d\udfe2 GET <code>/lol/clash/v1/teams/{teamId}</code> Get Clash Team Path: teamIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/clash/v1/tournaments</code> Get Clash Tournaments Query: region Unknown \ud83d\udfe2 GET <code>/lol/clash/v1/tournaments/by-team/{teamId}</code> Get Clash Tournament By Team Path: teamIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/clash/v1/tournaments/{tournamentId}</code> Get Clash Tournament Path: tournamentIdQuery: region Unknown"},{"location":"api/overview/#league-exp","title":"league-exp","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/league-exp/v4/entries/{queue}/{tier}/{division}</code> Get League Exp Entries Path: queue, tier, divisionQuery: region, page Unknown"},{"location":"api/overview/#league","title":"league","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/league/v4/challengerleagues/by-queue/{queue}</code> Get Challenger League Path: queueQuery: region Unknown \ud83d\udfe2 GET <code>/lol/league/v4/entries/by-summoner/{encryptedSummonerId}</code> Get League Entries By Summoner Path: encryptedSummonerIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/league/v4/entries/{queue}/{tier}/{division}</code> Get League Entries Path: queue, tier, divisionQuery: region, page Unknown \ud83d\udfe2 GET <code>/lol/league/v4/grandmasterleagues/by-queue/{queue}</code> Get Grandmaster League Path: queueQuery: region Unknown \ud83d\udfe2 GET <code>/lol/league/v4/masterleagues/by-queue/{queue}</code> Get Master League Path: queueQuery: region Unknown"},{"location":"api/overview/#match","title":"match","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/match/v5/matches/by-puuid/{puuid}/ids</code> Get Match Ids By Puuid Path: puuidQuery: start, count, region, startTime, endTime, queue, type Unknown \ud83d\udfe2 GET <code>/lol/match/v5/matches/{matchId}</code> Get Match Path: matchIdQuery: region, force Unknown \ud83d\udfe2 GET <code>/lol/match/v5/matches/{matchId}/timeline</code> Get Match Timeline Path: matchIdQuery: region Unknown"},{"location":"api/overview/#champion","title":"champion","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/platform/v3/champion-rotations</code> Get Champion Rotations Query: region Unknown"},{"location":"api/overview/#spectator","title":"spectator","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/spectator/v5/active-games/by-summoner/{puuid}</code> Get Active Game Path: puuidQuery: region Unknown \ud83d\udfe2 GET <code>/lol/spectator/v5/featured-games</code> Get Featured Games Query: region Unknown"},{"location":"api/overview/#platform","title":"platform","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/status/v4/platform-data</code> Get Platform Status Query: region Unknown"},{"location":"api/overview/#summoner","title":"summoner","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/summoner/v4/summoners/by-name/{summonerName}</code> Get Summoner By Name Path: summonerNameQuery: region Unknown \ud83d\udfe2 GET <code>/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}</code> Get Summoner By Puuid Path: encryptedPUUIDQuery: region Unknown \ud83d\udfe2 GET <code>/lol/summoner/v4/summoners/{encryptedSummonerId}</code> Get Summoner By Id Path: encryptedSummonerIdQuery: region Unknown"},{"location":"api/overview/#account","title":"account","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/riot/account/v1/accounts/by-puuid/{puuid}</code> Get Account By Puuid Path: puuidQuery: region Unknown \ud83d\udfe2 GET <code>/riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}</code> Get Account By Riot Id Path: gameName, tagLineQuery: region Unknown \ud83d\udfe2 GET <code>/riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}</code> Get Active Shard Path: puuid, gameQuery: region Unknown"},{"location":"api/overview/#data-schemas","title":"Data Schemas","text":""},{"location":"api/overview/#other-models","title":"Other Models","text":""},{"location":"api/overview/#division","title":"Division","text":"<p>Division within a tier.</p> <p>Used for Iron through Diamond (and Emerald) tiers. Master, Grandmaster, and Challenger don't use divisions.</p>"},{"location":"api/overview/#gameregion","title":"GameRegion","text":"<p>Game regions for platform-specific endpoints.</p>"},{"location":"api/overview/#httpvalidationerror","title":"HTTPValidationError","text":"Property Type Description Required <code>detail</code> array \u274c"},{"location":"api/overview/#platformregion","title":"PlatformRegion","text":"<p>Platform regions for regional routing (ACCOUNT, MATCH APIs).</p>"},{"location":"api/overview/#queuetype","title":"QueueType","text":"<p>Queue types for League of Legends.</p> <p>Includes ranked, normal, and special game modes.</p>"},{"location":"api/overview/#tier","title":"Tier","text":"<p>League tier/rank levels.</p> <p>Used for: - Ranked league entries and progression (IRON \u2192 CHALLENGER) - Challenge progression (all tiers) - Challenge leaderboards (MASTER, GRANDMASTER, CHALLENGER only)</p>"},{"location":"api/overview/#validationerror","title":"ValidationError","text":"Property Type Description Required <code>loc</code> array \u2705 <code>msg</code> string \u2705 <code>type</code> string \u2705"},{"location":"api/overview/#error-handling","title":"Error Handling","text":"<p>The API uses standard HTTP status codes and returns error information in the following format:</p> <pre><code>{\n  \"detail\": \"Error description\",\n  \"status_code\": 400\n}\n</code></pre>"},{"location":"api/overview/#common-error-codes","title":"Common Error Codes","text":"Status Code Description Cause 400 Bad Request Invalid parameters or malformed request 404 Not Found Resource does not exist 429 Too Many Requests Rate limit exceeded (handled automatically) 500 Internal Server Error Server error or external API failure 503 Service Unavailable External API (Riot) is down"},{"location":"api/overview/#rate-limiting","title":"Rate Limiting","text":"<p>The gateway includes automatic rate limiting with the following features:</p> <ul> <li>Automatic Retry: 429 responses are automatically retried with exponential backoff</li> <li>Rate Limit Headers: All responses include rate limit information</li> <li>Graceful Degradation: The service continues to operate during rate limit events</li> </ul>"},{"location":"api/overview/#usage-examples","title":"Usage Examples","text":""},{"location":"api/overview/#get-summoner-by-name","title":"Get Summoner by Name","text":"<p>Retrieve summoner information using their summoner name.</p> <p>Endpoint: <code>GET /summoner/by-name/{summonerName}</code></p> <pre><code>curl \"http://localhost:8080/summoner/by-name/Faker?region=kr\"\n</code></pre>"},{"location":"api/overview/#get-match-history","title":"Get Match History","text":"<p>Retrieve recent match IDs for a player using their PUUID.</p> <p>Endpoint: <code>GET /match/ids/by-puuid/{puuid}</code></p> <pre><code>curl \"http://localhost:8080/match/ids/by-puuid/puuid-here?region=kr&amp;count=5\"\n</code></pre>"},{"location":"api/overview/#get-challenger-league","title":"Get Challenger League","text":"<p>Retrieve the challenger league for a specific queue.</p> <p>Endpoint: <code>GET /league/challenger/{queue}</code></p> <pre><code>curl \"http://localhost:8080/league/challenger/RANKED_SOLO_5x5?region=kr\"\n</code></pre>"},{"location":"api/overview/#python-client-example","title":"Python Client Example","text":"<pre><code>import httpx\nimport asyncio\n\nasync def get_summoner_data():\n    \"\"\"Get summoner information example.\"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            \"http://localhost:8080/summoner/by-name/Faker\",\n            params={\"region\": \"kr\"}\n        )\n        if response.status_code == 200:\n            return response.json()\n        return None\n\n# Usage\nsummoner = asyncio.run(get_summoner_data())\nif summoner:\n    print(f\"Summoner: {summoner[\\'name\\']} (Level {summoner[\\'summonerLevel\\']})\")\n</code></pre> <p>Documentation generated on 2024-10-28 18:34:54 UTC</p> <p>For the most up-to-date interactive documentation, visit Swagger UI when the server is running.</p>"},{"location":"api/riot-client/","title":"Riot Client","text":"<p>This section documents the Riot API client implementation that handles HTTP requests, rate limiting, and retry logic.</p>"},{"location":"api/riot-client/#riotclient","title":"RiotClient","text":""},{"location":"api/riot-client/#app.riot.client.RiotClient","title":"<code>app.riot.client.RiotClient()</code>","text":"<p>HTTP client for Riot API with rate limiting and retry logic.</p> <p>Automatically applies rate limiting before each request and retries on 429 responses according to Retry-After header.</p> <p>Initialize HTTP client with authentication headers.</p> Source code in <code>app/riot/client.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize HTTP client with authentication headers.\"\"\"\n    self.client = httpx.AsyncClient(\n        timeout=settings.riot_request_timeout,\n        headers={\"X-Riot-Token\": settings.riot_api_key},\n    )\n    logger.info(\"Riot API client initialized\")\n</code></pre>"},{"location":"api/riot-client/#app.riot.client.RiotClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close HTTP client connection.</p> Source code in <code>app/riot/client.py</code> <pre><code>async def close(self):\n    \"\"\"Close HTTP client connection.\"\"\"\n    await self.client.aclose()\n    logger.info(\"Riot API client closed\")\n</code></pre>"},{"location":"api/riot-client/#app.riot.client.RiotClient.get","title":"<code>get(path: str, region: str, is_platform_endpoint: bool = False, params: dict | None = None) -&gt; dict</code>  <code>async</code>","text":"<p>Makes a GET request to the Riot API with rate limiting and retry logic.</p> <p>This method handles the entire process of making a GET request, including acquiring a rate limit token, constructing the appropriate URL, and handling potential 429 (rate limited) responses by retrying after a specified delay.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The API path for the request.</p> required <code>region</code> <code>str</code> <p>The region to target for the request.</p> required <code>is_platform_endpoint</code> <code>bool</code> <p>A flag indicating whether to use the platform-specific or regional endpoint.</p> <code>False</code> <code>params</code> <code>dict</code> <p>A dictionary of query parameters to include in the request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The JSON response from the API as a dictionary.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the API returns a non-2xx and non-429 status code.</p> <code>ValueError</code> <p>If an invalid region is provided.</p> Example <p>await riot_client.get( ...     \"/lol/summoner/v4/summoners/by-name/Faker\", ...     region=\"kr\", ...     is_platform_endpoint=False ... )</p> Source code in <code>app/riot/client.py</code> <pre><code>async def get(\n    self,\n    path: str,\n    region: str,\n    is_platform_endpoint: bool = False,\n    params: dict | None = None,\n) -&gt; dict:\n    \"\"\"\n    Makes a GET request to the Riot API with rate limiting and retry logic.\n\n    This method handles the entire process of making a GET request, including\n    acquiring a rate limit token, constructing the appropriate URL, and\n    handling potential 429 (rate limited) responses by retrying after a\n    specified delay.\n\n    Args:\n        path (str): The API path for the request.\n        region (str): The region to target for the request.\n        is_platform_endpoint (bool): A flag indicating whether to use the platform-specific or regional endpoint.\n        params (dict, optional): A dictionary of query parameters to include in the request. Defaults to None.\n\n    Returns:\n        dict: The JSON response from the API as a dictionary.\n\n    Raises:\n        httpx.HTTPStatusError: If the API returns a non-2xx and non-429 status code.\n        ValueError: If an invalid region is provided.\n\n    Example:\n        &gt;&gt;&gt; await riot_client.get(\n        ...     \"/lol/summoner/v4/summoners/by-name/Faker\",\n        ...     region=\"kr\",\n        ...     is_platform_endpoint=False\n        ... )\n    \"\"\"\n    # Acquire rate limit tokens (blocks until available)\n    await rate_limiter.acquire()\n\n    # Build full URL\n    base_url = get_base_url(region, is_platform_endpoint)\n    url = f\"{base_url}{path}\"\n\n    logger.debug(\"Requesting Riot API: {} [region={}]\", path, region)\n\n    # Make request\n    response = await self.client.get(url, params=params)\n\n    # Handle 429 (rate limited) - should be rare due to our rate limiter\n    if response.status_code == 429:\n        retry_after = int(response.headers.get(\"Retry-After\", 1))\n        logger.warning(\n            \"Rate limited by Riot API (429), retrying after {}s\",\n            retry_after,\n        )\n        await asyncio.sleep(retry_after)\n        # Retry the request (recursive call)\n        return await self.get(path, region, is_platform_endpoint, params)\n\n    # Raise on other HTTP errors\n    response.raise_for_status()\n\n    # Return JSON response\n    return response.json()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/riot-client/#riotratelimiter","title":"RiotRateLimiter","text":""},{"location":"api/riot-client/#app.riot.rate_limiter.RiotRateLimiter","title":"<code>app.riot.rate_limiter.RiotRateLimiter()</code>","text":"<p>Rate limiter for Riot API compliance.</p> <p>Enforces application-level rate limits using token bucket algorithm. Requests are blocked until tokens are available.</p> <p>Initialize rate limiters with configured limits.</p> Source code in <code>app/riot/rate_limiter.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize rate limiters with configured limits.\"\"\"\n    self.limiter_1s = AsyncLimiter(\n        max_rate=settings.riot_rate_limit_per_second,\n        time_period=1,\n    )\n    self.limiter_2min = AsyncLimiter(\n        max_rate=settings.riot_rate_limit_per_2min,\n        time_period=120,\n    )\n    logger.info(\n        \"Rate limiter initialized: {}/s, {}/2min\",\n        settings.riot_rate_limit_per_second,\n        settings.riot_rate_limit_per_2min,\n    )\n</code></pre>"},{"location":"api/riot-client/#app.riot.rate_limiter.RiotRateLimiter.acquire","title":"<code>acquire()</code>  <code>async</code>","text":"<p>Acquire rate limit tokens before making a request.</p> <p>Blocks until both rate limiters have available tokens. Uses nested context managers to ensure both limits are respected.</p> Source code in <code>app/riot/rate_limiter.py</code> <pre><code>async def acquire(self):\n    \"\"\"\n    Acquire rate limit tokens before making a request.\n\n    Blocks until both rate limiters have available tokens.\n    Uses nested context managers to ensure both limits are respected.\n    \"\"\"\n    async with self.limiter_1s:\n        async with self.limiter_2min:\n            pass\n</code></pre>"},{"location":"api/riot-client/#regions","title":"Regions","text":""},{"location":"api/riot-client/#app.riot.regions","title":"<code>app.riot.regions</code>","text":"<p>Region routing configuration for Riot API.</p> <p>Maps regions to their appropriate API base URLs. Different endpoints use different routing: - Regional endpoints (Summoner, League, Mastery): region-specific - Platform endpoints (Match): platform-specific (europe, americas, asia, sea)</p>"},{"location":"api/riot-client/#app.riot.regions.get_regional_url","title":"<code>get_regional_url(region: str) -&gt; str</code>","text":"<p>Get regional base URL for endpoints like Summoner, League, Mastery.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1', 'kr', 'na1')</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base URL for regional endpoints</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_regional_url(\"euw1\")\n'https://euw1.api.riotgames.com'\n&gt;&gt;&gt; get_regional_url(\"kr\")\n'https://kr.api.riotgames.com'\n</code></pre> Source code in <code>app/riot/regions.py</code> <pre><code>def get_regional_url(region: str) -&gt; str:\n    \"\"\"\n    Get regional base URL for endpoints like Summoner, League, Mastery.\n\n    Args:\n        region: Region code (e.g., 'euw1', 'kr', 'na1')\n\n    Returns:\n        Base URL for regional endpoints\n\n    Examples:\n        &gt;&gt;&gt; get_regional_url(\"euw1\")\n        'https://euw1.api.riotgames.com'\n        &gt;&gt;&gt; get_regional_url(\"kr\")\n        'https://kr.api.riotgames.com'\n    \"\"\"\n    if region not in SUPPORTED_REGIONS:\n        raise ValueError(f\"Unsupported region: {region}. Supported: {SUPPORTED_REGIONS}\")\n\n    return f\"https://{region}.api.riotgames.com\"\n</code></pre>"},{"location":"api/riot-client/#app.riot.regions.get_platform_url","title":"<code>get_platform_url(region: str) -&gt; str</code>","text":"<p>Get platform base URL for Match API and Account API endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1', 'kr', 'na1') OR platform region (e.g., 'americas', 'europe', 'asia', 'sea')</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base URL for platform endpoints</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_platform_url(\"euw1\")\n'https://europe.api.riotgames.com'\n&gt;&gt;&gt; get_platform_url(\"kr\")\n'https://asia.api.riotgames.com'\n&gt;&gt;&gt; get_platform_url(\"americas\")\n'https://americas.api.riotgames.com'\n</code></pre> Source code in <code>app/riot/regions.py</code> <pre><code>def get_platform_url(region: str) -&gt; str:\n    \"\"\"\n    Get platform base URL for Match API and Account API endpoints.\n\n    Args:\n        region: Region code (e.g., 'euw1', 'kr', 'na1') OR platform region (e.g., 'americas', 'europe', 'asia', 'sea')\n\n    Returns:\n        Base URL for platform endpoints\n\n    Examples:\n        &gt;&gt;&gt; get_platform_url(\"euw1\")\n        'https://europe.api.riotgames.com'\n        &gt;&gt;&gt; get_platform_url(\"kr\")\n        'https://asia.api.riotgames.com'\n        &gt;&gt;&gt; get_platform_url(\"americas\")\n        'https://americas.api.riotgames.com'\n    \"\"\"\n    # If it's already a platform region, use it directly\n    platform_regions_list = [\"americas\", \"europe\", \"asia\", \"sea\"]\n    if region in platform_regions_list:\n        return f\"https://{region}.api.riotgames.com\"\n\n    # Otherwise, it's a game region code, map it to platform\n    if region not in SUPPORTED_REGIONS:\n        raise ValueError(\n            f\"Unsupported region: {region}. Supported: {SUPPORTED_REGIONS + platform_regions_list}\"\n        )\n\n    platform = PLATFORM_REGIONS[region]\n    return f\"https://{platform}.api.riotgames.com\"\n</code></pre>"},{"location":"api/riot-client/#app.riot.regions.get_base_url","title":"<code>get_base_url(region: str, is_platform_endpoint: bool = False) -&gt; str</code>","text":"<p>Get the appropriate base URL based on endpoint type.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1', 'kr', 'na1')</p> required <code>is_platform_endpoint</code> <code>bool</code> <p>True for Match API, False for Summoner/League/Mastery</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Appropriate base URL for the endpoint type</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_base_url(\"euw1\", is_platform_endpoint=False)\n'https://euw1.api.riotgames.com'\n&gt;&gt;&gt; get_base_url(\"euw1\", is_platform_endpoint=True)\n'https://europe.api.riotgames.com'\n</code></pre> Source code in <code>app/riot/regions.py</code> <pre><code>def get_base_url(region: str, is_platform_endpoint: bool = False) -&gt; str:\n    \"\"\"\n    Get the appropriate base URL based on endpoint type.\n\n    Args:\n        region: Region code (e.g., 'euw1', 'kr', 'na1')\n        is_platform_endpoint: True for Match API, False for Summoner/League/Mastery\n\n    Returns:\n        Appropriate base URL for the endpoint type\n\n    Examples:\n        &gt;&gt;&gt; get_base_url(\"euw1\", is_platform_endpoint=False)\n        'https://euw1.api.riotgames.com'\n        &gt;&gt;&gt; get_base_url(\"euw1\", is_platform_endpoint=True)\n        'https://europe.api.riotgames.com'\n    \"\"\"\n    if is_platform_endpoint:\n        return get_platform_url(region)\n    else:\n        return get_regional_url(region)\n</code></pre>"},{"location":"api/routers/","title":"API Routers","text":"<p>This section contains all the FastAPI routers that define the REST API endpoints for the LOLStonks API Gateway.</p>"},{"location":"api/routers/#core-routers","title":"Core Routers","text":""},{"location":"api/routers/#health-check","title":"Health Check","text":""},{"location":"api/routers/#app.routers.health","title":"<code>app.routers.health</code>","text":"<p>Health check endpoint for gateway monitoring.</p>"},{"location":"api/routers/#app.routers.health.health_check","title":"<code>health_check()</code>  <code>async</code>","text":"<p>Performs a health check of the application.</p> <p>This endpoint can be used to monitor the application's status. It returns a simple JSON response to indicate that the service is running.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with a status of \"ok\".</p> Example <p>curl \"http://127.0.0.1:8080/health\"</p> Source code in <code>app/routers/health.py</code> <pre><code>@router.get(\"/health\")\nasync def health_check():\n    \"\"\"\n    Performs a health check of the application.\n\n    This endpoint can be used to monitor the application's status. It\n    returns a simple JSON response to indicate that the service is\n    running.\n\n    Returns:\n        dict: A dictionary with a status of \"ok\".\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/health\"\n    \"\"\"\n    logger.debug(\"Health check requested\")\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"api/routers/#summoner-router","title":"Summoner Router","text":""},{"location":"api/routers/#app.routers.summoner","title":"<code>app.routers.summoner</code>","text":"<p>Summoner API endpoints - Priority 1.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#summoner-v4</p>"},{"location":"api/routers/#app.routers.summoner.get_summoner_by_name","title":"<code>get_summoner_by_name(params: Annotated[SummonerByNameParams, Depends()], query: Annotated[SummonerByNameQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves a summoner by their summoner name.</p> <p>This endpoint is the primary method for looking up a player by their in-game name. It is a foundational part of the API, providing the necessary IDs for further queries.</p> <p>API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerName</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>SummonerByNameParams</code> <p>The path parameters, containing the summoner name.</p> required <code>query</code> <code>SummonerByNameQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the summoner's information.</p> Example <p>curl \"http://127.0.0.1:8080/lol/summoner/v4/summoners/by-name/Faker?region=kr\"</p> Source code in <code>app/routers/summoner.py</code> <pre><code>@router.get(\"/summoners/by-name/{summonerName}\")\nasync def get_summoner_by_name(\n    params: Annotated[SummonerByNameParams, Depends()],\n    query: Annotated[SummonerByNameQuery, Depends()],\n):\n    \"\"\"\n    Retrieves a summoner by their summoner name.\n\n    This endpoint is the primary method for looking up a player by their in-game\n    name. It is a foundational part of the API, providing the necessary IDs for\n    further queries.\n\n    API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerName\n\n    Args:\n        params (SummonerByNameParams): The path parameters, containing the summoner name.\n        query (SummonerByNameQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A dictionary containing the summoner's information.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/summoner/v4/summoners/by-name/Faker?region=kr\"\n    \"\"\"\n    logger.info(\"Fetching summoner by name\", summoner=params.summonerName, region=query.region)\n\n    # Check cache first\n    cache_key = f\"summoner:name:{query.region}:{params.summonerName}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for summoner\", summoner=params.summonerName)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/summoner/v4/summoners/by-name/{params.summonerName}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_summoner)\n\n    logger.success(\n        \"Summoner fetched successfully\",\n        summoner=params.summonerName,\n        puuid=data.get(\"puuid\", \"unknown\"),\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.summoner.get_summoner_by_puuid","title":"<code>get_summoner_by_puuid(params: Annotated[SummonerByPuuidParams, Depends()], query: Annotated[SummonerByPuuidQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves a summoner by their PUUID.</p> <p>This endpoint fetches summoner information using a player's unique PUUID, which is a persistent and globally unique identifier.</p> <p>API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getByPUUID</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>SummonerByPuuidParams</code> <p>The path parameters, containing the encrypted PUUID.</p> required <code>query</code> <code>SummonerByPuuidQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the summoner's information.</p> Example <p>curl \"http://127.0.0.1:8080/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}?region=euw1\"</p> Source code in <code>app/routers/summoner.py</code> <pre><code>@router.get(\"/summoners/by-puuid/{encryptedPUUID}\")\nasync def get_summoner_by_puuid(\n    params: Annotated[SummonerByPuuidParams, Depends()],\n    query: Annotated[SummonerByPuuidQuery, Depends()],\n):\n    \"\"\"\n    Retrieves a summoner by their PUUID.\n\n    This endpoint fetches summoner information using a player's unique PUUID,\n    which is a persistent and globally unique identifier.\n\n    API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getByPUUID\n\n    Args:\n        params (SummonerByPuuidParams): The path parameters, containing the encrypted PUUID.\n        query (SummonerByPuuidQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A dictionary containing the summoner's information.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}?region=euw1\"\n    \"\"\"\n    logger.info(\"Fetching summoner by PUUID\", puuid=params.encryptedPUUID, region=query.region)\n\n    # Check cache first\n    cache_key = f\"summoner:puuid:{query.region}:{params.encryptedPUUID}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for summoner by PUUID\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/summoner/v4/summoners/by-puuid/{params.encryptedPUUID}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_summoner)\n\n    logger.success(\"Summoner fetched by PUUID\", name=data.get(\"name\", \"unknown\"))\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.summoner.get_summoner_by_id","title":"<code>get_summoner_by_id(params: Annotated[SummonerByIdParams, Depends()], query: Annotated[SummonerByIdQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves a summoner by their summoner ID.</p> <p>This endpoint fetches summoner information using a player's encrypted summoner ID, which is a region-specific identifier.</p> <p>API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerId</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>SummonerByIdParams</code> <p>The path parameters, containing the encrypted summoner ID.</p> required <code>query</code> <code>SummonerByIdQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the summoner's information.</p> Example <p>curl \"http://127.0.0.1:8080/lol/summoner/v4/summoners/{encryptedSummonerId}?region=euw1\"</p> Source code in <code>app/routers/summoner.py</code> <pre><code>@router.get(\"/summoners/{encryptedSummonerId}\")\nasync def get_summoner_by_id(\n    params: Annotated[SummonerByIdParams, Depends()],\n    query: Annotated[SummonerByIdQuery, Depends()],\n):\n    \"\"\"\n    Retrieves a summoner by their summoner ID.\n\n    This endpoint fetches summoner information using a player's encrypted\n    summoner ID, which is a region-specific identifier.\n\n    API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerId\n\n    Args:\n        params (SummonerByIdParams): The path parameters, containing the encrypted summoner ID.\n        query (SummonerByIdQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A dictionary containing the summoner's information.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/summoner/v4/summoners/{encryptedSummonerId}?region=euw1\"\n    \"\"\"\n    logger.info(\n        \"Fetching summoner by ID\", summoner_id=params.encryptedSummonerId, region=query.region\n    )\n\n    # Check cache first\n    cache_key = f\"summoner:id:{query.region}:{params.encryptedSummonerId}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for summoner by ID\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/summoner/v4/summoners/{params.encryptedSummonerId}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_summoner)\n\n    logger.success(\"Summoner fetched by ID\", name=data.get(\"name\", \"unknown\"))\n    return data\n</code></pre>"},{"location":"api/routers/#match-router","title":"Match Router","text":""},{"location":"api/routers/#app.routers.match","title":"<code>app.routers.match</code>","text":"<p>Match API endpoints - Priority 2 &amp; 3.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#match-v5</p>"},{"location":"api/routers/#app.routers.match.get_match_ids_by_puuid","title":"<code>get_match_ids_by_puuid(params: Annotated[MatchIdsByPuuidParams, Depends()], query: Annotated[MatchIdsByPuuidQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves a list of match IDs for a summoner.</p> <p>This endpoint fetches a list of match IDs based on a player's PUUID, with options for pagination and filtering by time, queue, and match type.</p> <p>API Reference: https://developer.riotgames.com/apis#match-v5/GET_getMatchIdsByPUUID</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>MatchIdsByPuuidParams</code> <p>The path parameters, containing the PUUID.</p> required <code>query</code> <code>MatchIdsByPuuidQuery</code> <p>The query parameters, for pagination and filtering.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of match IDs.</p> Example <p>curl \"http://127.0.0.1:8080/lol/match/v5/matches/by-puuid/{puuid}/ids?region=americas&amp;count=20\"</p> Source code in <code>app/routers/match.py</code> <pre><code>@router.get(\"/matches/by-puuid/{puuid}/ids\")\nasync def get_match_ids_by_puuid(\n    params: Annotated[MatchIdsByPuuidParams, Depends()],\n    query: Annotated[MatchIdsByPuuidQuery, Depends()],\n):\n    \"\"\"\n    Retrieves a list of match IDs for a summoner.\n\n    This endpoint fetches a list of match IDs based on a player's PUUID, with\n    options for pagination and filtering by time, queue, and match type.\n\n    API Reference: https://developer.riotgames.com/apis#match-v5/GET_getMatchIdsByPUUID\n\n    Args:\n        params (MatchIdsByPuuidParams): The path parameters, containing the PUUID.\n        query (MatchIdsByPuuidQuery): The query parameters, for pagination and filtering.\n\n    Returns:\n        list: A list of match IDs.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/match/v5/matches/by-puuid/{puuid}/ids?region=americas&amp;count=20\"\n    \"\"\"\n    logger.info(\n        \"Fetching match IDs\",\n        puuid=params.puuid[:8],\n        region=query.region,\n        start=query.start,\n        count=query.count,\n        filters={\n            \"startTime\": query.startTime,\n            \"endTime\": query.endTime,\n            \"queue\": query.queue,\n            \"type\": query.type,\n        },\n    )\n\n    # Build query parameters\n    query_params = [f\"start={query.start}\", f\"count={query.count}\"]\n    if query.startTime is not None:\n        query_params.append(f\"startTime={query.startTime}\")\n    if query.endTime is not None:\n        query_params.append(f\"endTime={query.endTime}\")\n    if query.queue is not None:\n        query_params.append(f\"queue={query.queue}\")\n    if query.type is not None:\n        query_params.append(f\"type={query.type}\")\n\n    # Build path with query parameters\n    path = f\"/lol/match/v5/matches/by-puuid/{params.puuid}/ids?{'&amp;'.join(query_params)}\"\n    match_ids = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    logger.success(\"Match IDs fetched\", count=len(match_ids), region=query.region)\n    return match_ids\n</code></pre>"},{"location":"api/routers/#app.routers.match.get_match","title":"<code>get_match(params: Annotated[MatchParams, Depends()], query: Annotated[MatchQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves match details by match ID.</p> <p>This endpoint fetches the core data for a specific match. It employs a dual-layer caching strategy, with a response cache and permanent tracking, to minimize redundant API calls.</p> <p>API Reference: https://developer.riotgames.com/apis#match-v5/GET_getMatch</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>MatchParams</code> <p>The path parameters, containing the match ID.</p> required <code>query</code> <code>MatchQuery</code> <p>The query parameters, specifying the region and an                optional force refresh flag.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the match details.</p> Example <p>curl \"http://127.0.0.1:8080/lol/match/v5/matches/EUW1_123456789?region=americas\"</p> Source code in <code>app/routers/match.py</code> <pre><code>@router.get(\"/matches/{matchId}\")\nasync def get_match(\n    params: Annotated[MatchParams, Depends()],\n    query: Annotated[MatchQuery, Depends()],\n):\n    \"\"\"\n    Retrieves match details by match ID.\n\n    This endpoint fetches the core data for a specific match. It employs a\n    dual-layer caching strategy, with a response cache and permanent tracking,\n    to minimize redundant API calls.\n\n    API Reference: https://developer.riotgames.com/apis#match-v5/GET_getMatch\n\n    Args:\n        params (MatchParams): The path parameters, containing the match ID.\n        query (MatchQuery): The query parameters, specifying the region and an\n                           optional force refresh flag.\n\n    Returns:\n        dict: A dictionary containing the match details.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/match/v5/matches/EUW1_123456789?region=americas\"\n    \"\"\"\n    logger.info(\n        \"Match request received\", match_id=params.matchId, region=query.region, force=query.force\n    )\n\n    cache_key = f\"match:{query.region}:{params.matchId}\"\n\n    # Check force refresh\n    if not query.force:\n        # Check if already processed (permanent tracking)\n        is_processed = await tracker.is_processed(query.region, params.matchId)\n\n        if is_processed:\n            logger.debug(\"Match already processed, checking cache\", match_id=params.matchId)\n\n            # Try to get from cache\n            cached_data = await cache.get(cache_key)\n            if cached_data:\n                logger.debug(\"Cache hit for processed match\", match_id=params.matchId)\n                return cached_data\n            else:\n                logger.debug(\n                    \"Cache miss for processed match (TTL expired)\", match_id=params.matchId\n                )\n        else:\n            logger.debug(\"Match not yet processed\", match_id=params.matchId)\n    else:\n        logger.info(\"Force refresh requested, bypassing cache\", match_id=params.matchId)\n\n    # Fetch from Riot API (rate-limited)\n    logger.info(\"Fetching match from Riot API\", match_id=params.matchId, region=query.region)\n    path = f\"/lol/match/v5/matches/{params.matchId}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Store in cache with TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_match)\n    logger.debug(\"Match stored in cache\", match_id=params.matchId, ttl=settings.cache_ttl_match)\n\n    # Mark as processed (permanent, no TTL)\n    await tracker.mark_processed(query.region, params.matchId)\n    logger.debug(\"Match marked as processed\", match_id=params.matchId, region=query.region)\n\n    logger.success(\"Match fetched and cached successfully\", match_id=params.matchId)\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.match.get_match_timeline","title":"<code>get_match_timeline(params: Annotated[MatchTimelineParams, Depends()], query: Annotated[MatchTimelineQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves the timeline for a specific match.</p> <p>This endpoint fetches a detailed timeline of events for a given match, providing in-depth data for analysis.</p> <p>API Reference: https://developer.riotgames.com/apis#match-v5/GET_getTimeline</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>MatchTimelineParams</code> <p>The path parameters, containing the match ID.</p> required <code>query</code> <code>MatchTimelineQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the match timeline data.</p> Example <p>curl \"http://127.0.0.1:8080/lol/match/v5/matches/EUW1_123456789/timeline?region=americas\"</p> Source code in <code>app/routers/match.py</code> <pre><code>@router.get(\"/matches/{matchId}/timeline\")\nasync def get_match_timeline(\n    params: Annotated[MatchTimelineParams, Depends()],\n    query: Annotated[MatchTimelineQuery, Depends()],\n):\n    \"\"\"\n    Retrieves the timeline for a specific match.\n\n    This endpoint fetches a detailed timeline of events for a given match,\n    providing in-depth data for analysis.\n\n    API Reference: https://developer.riotgames.com/apis#match-v5/GET_getTimeline\n\n    Args:\n        params (MatchTimelineParams): The path parameters, containing the match ID.\n        query (MatchTimelineQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A dictionary containing the match timeline data.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/match/v5/matches/EUW1_123456789/timeline?region=americas\"\n    \"\"\"\n    logger.info(\"Fetching match timeline\", match_id=params.matchId, region=query.region)\n\n    # Check cache first\n    cache_key = f\"match:timeline:{query.region}:{params.matchId}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for match timeline\", match_id=params.matchId)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/match/v5/matches/{params.matchId}/timeline\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_timeline)\n\n    logger.success(\"Match timeline fetched\", match_id=params.matchId)\n    return data\n</code></pre>"},{"location":"api/routers/#league-router","title":"League Router","text":""},{"location":"api/routers/#app.routers.league","title":"<code>app.routers.league</code>","text":"<p>League API endpoints - Priority 5.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#league-v4</p>"},{"location":"api/routers/#app.routers.league.get_challenger_league","title":"<code>get_challenger_league(params: Annotated[LeagueByQueueParams, Depends()], query: Annotated[LeagueByQueueQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves the Challenger league for a specific queue.</p> <p>This endpoint fetches a list of all players in the Challenger league for a given queue, providing a snapshot of the top-ranked players in a region.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getChallengerLeague</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>LeagueByQueueParams</code> <p>The path parameters, containing the queue type.</p> required <code>query</code> <code>LeagueByQueueQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A league object containing an array of summoner entries.</p> Example <p>curl \"http://127.0.0.1:8080/lol/league/v4/challengerleagues/by-queue/RANKED_SOLO_5x5?region=euw1\"</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/challengerleagues/by-queue/{queue}\")\nasync def get_challenger_league(\n    params: Annotated[LeagueByQueueParams, Depends()],\n    query: Annotated[LeagueByQueueQuery, Depends()],\n):\n    \"\"\"\n    Retrieves the Challenger league for a specific queue.\n\n    This endpoint fetches a list of all players in the Challenger league for a\n    given queue, providing a snapshot of the top-ranked players in a region.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getChallengerLeague\n\n    Args:\n        params (LeagueByQueueParams): The path parameters, containing the queue type.\n        query (LeagueByQueueQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A league object containing an array of summoner entries.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/league/v4/challengerleagues/by-queue/RANKED_SOLO_5x5?region=euw1\"\n    \"\"\"\n    logger.info(\"Fetching challenger league\", queue=params.queue, region=query.region)\n\n    # Check cache first\n    cache_key = f\"league:challenger:{query.region}:{params.queue}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenger league\", queue=params.queue)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/challengerleagues/by-queue/{params.queue}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache (1 hour - challenger changes frequently)\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"Challenger league fetched\", queue=params.queue, entries=len(data.get(\"entries\", []))\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.league.get_grandmaster_league","title":"<code>get_grandmaster_league(params: Annotated[LeagueByQueueParams, Depends()], query: Annotated[LeagueByQueueQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves the Grandmaster league for a specific queue.</p> <p>This endpoint fetches a list of all players in the Grandmaster league for a given queue, providing a snapshot of the top-ranked players in a region.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getGrandmasterLeague</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>LeagueByQueueParams</code> <p>The path parameters, containing the queue type.</p> required <code>query</code> <code>LeagueByQueueQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A league object containing an array of summoner entries.</p> Example <p>curl \"http://127.0.0.1:8080/lol/league/v4/grandmasterleagues/by-queue/RANKED_SOLO_5x5?region=euw1\"</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/grandmasterleagues/by-queue/{queue}\")\nasync def get_grandmaster_league(\n    params: Annotated[LeagueByQueueParams, Depends()],\n    query: Annotated[LeagueByQueueQuery, Depends()],\n):\n    \"\"\"\n    Retrieves the Grandmaster league for a specific queue.\n\n    This endpoint fetches a list of all players in the Grandmaster league for a\n    given queue, providing a snapshot of the top-ranked players in a region.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getGrandmasterLeague\n\n    Args:\n        params (LeagueByQueueParams): The path parameters, containing the queue type.\n        query (LeagueByQueueQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A league object containing an array of summoner entries.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/league/v4/grandmasterleagues/by-queue/RANKED_SOLO_5x5?region=euw1\"\n    \"\"\"\n    logger.info(\"Fetching grandmaster league\", queue=params.queue, region=query.region)\n\n    # Check cache first\n    cache_key = f\"league:grandmaster:{query.region}:{params.queue}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for grandmaster league\", queue=params.queue)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/grandmasterleagues/by-queue/{params.queue}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"Grandmaster league fetched\", queue=params.queue, entries=len(data.get(\"entries\", []))\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.league.get_master_league","title":"<code>get_master_league(params: Annotated[LeagueByQueueParams, Depends()], query: Annotated[LeagueByQueueQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves the Master league for a specific queue.</p> <p>This endpoint fetches a list of all players in the Master league for a given queue, providing a snapshot of the top-ranked players in a region.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getMasterLeague</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>LeagueByQueueParams</code> <p>The path parameters, containing the queue type.</p> required <code>query</code> <code>LeagueByQueueQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A league object containing an array of summoner entries.</p> Example <p>curl \"http://127.0.0.1:8080/lol/league/v4/masterleagues/by-queue/RANKED_SOLO_5x5?region=euw1\"</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/masterleagues/by-queue/{queue}\")\nasync def get_master_league(\n    params: Annotated[LeagueByQueueParams, Depends()],\n    query: Annotated[LeagueByQueueQuery, Depends()],\n):\n    \"\"\"\n    Retrieves the Master league for a specific queue.\n\n    This endpoint fetches a list of all players in the Master league for a\n    given queue, providing a snapshot of the top-ranked players in a region.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getMasterLeague\n\n    Args:\n        params (LeagueByQueueParams): The path parameters, containing the queue type.\n        query (LeagueByQueueQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A league object containing an array of summoner entries.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/league/v4/masterleagues/by-queue/RANKED_SOLO_5x5?region=euw1\"\n    \"\"\"\n    logger.info(\"Fetching master league\", queue=params.queue, region=query.region)\n\n    # Check cache first\n    cache_key = f\"league:master:{query.region}:{params.queue}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for master league\", queue=params.queue)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/masterleagues/by-queue/{params.queue}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"Master league fetched\", queue=params.queue, entries=len(data.get(\"entries\", []))\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.league.get_league_entries_by_summoner","title":"<code>get_league_entries_by_summoner(params: Annotated[LeagueEntriesBySummonerParams, Depends()], query: Annotated[LeagueEntriesBySummonerQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves the league entries for a summoner across all queues.</p> <p>This endpoint fetches a list of a summoner's league entries, providing details about their rank in each queue they participate in.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getLeagueEntriesForSummoner</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>LeagueEntriesBySummonerParams</code> <p>The path parameters, containing the encrypted summoner ID.</p> required <code>query</code> <code>LeagueEntriesBySummonerQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of league entry objects.</p> Example <p>curl \"http://127.0.0.1:8080/lol/league/v4/entries/by-summoner/{encryptedSummonerId}?region=euw1\"</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/entries/by-summoner/{encryptedSummonerId}\")\nasync def get_league_entries_by_summoner(\n    params: Annotated[LeagueEntriesBySummonerParams, Depends()],\n    query: Annotated[LeagueEntriesBySummonerQuery, Depends()],\n):\n    \"\"\"\n    Retrieves the league entries for a summoner across all queues.\n\n    This endpoint fetches a list of a summoner's league entries, providing\n    details about their rank in each queue they participate in.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getLeagueEntriesForSummoner\n\n    Args:\n        params (LeagueEntriesBySummonerParams): The path parameters, containing the encrypted summoner ID.\n        query (LeagueEntriesBySummonerQuery): The query parameters, specifying the region.\n\n    Returns:\n        list: A list of league entry objects.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/league/v4/entries/by-summoner/{encryptedSummonerId}?region=euw1\"\n    \"\"\"\n    logger.info(\n        \"Fetching league entries by summoner\",\n        summoner_id=params.encryptedSummonerId,\n        region=query.region,\n    )\n\n    # Check cache first\n    cache_key = f\"league:entries:summoner:{query.region}:{params.encryptedSummonerId}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for league entries\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/entries/by-summoner/{params.encryptedSummonerId}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\"League entries fetched\", entries=len(data))\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.league.get_league_entries","title":"<code>get_league_entries(params: Annotated[LeagueEntriesParams, Depends()], query: Annotated[LeagueEntriesQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves league entries by queue, tier, and division.</p> <p>This endpoint provides paginated access to league entries for a specific rank, allowing for the retrieval of large sets of ranked players.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getLeagueEntries</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>LeagueEntriesParams</code> <p>The path parameters, containing the queue, tier, and division.</p> required <code>query</code> <code>LeagueEntriesQuery</code> <p>The query parameters, specifying the region and page number.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of league entry objects, including summoner info, LP, and win/loss stats.</p> Example <p>curl \"http://127.0.0.1:8080/lol/league/v4/entries/RANKED_SOLO_5x5/DIAMOND/I?region=euw1&amp;page=1\"</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/entries/{queue}/{tier}/{division}\")\nasync def get_league_entries(\n    params: Annotated[LeagueEntriesParams, Depends()],\n    query: Annotated[LeagueEntriesQuery, Depends()],\n):\n    \"\"\"\n    Retrieves league entries by queue, tier, and division.\n\n    This endpoint provides paginated access to league entries for a specific\n    rank, allowing for the retrieval of large sets of ranked players.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getLeagueEntries\n\n    Args:\n        params (LeagueEntriesParams): The path parameters, containing the queue, tier, and division.\n        query (LeagueEntriesQuery): The query parameters, specifying the region and page number.\n\n    Returns:\n        list: A list of league entry objects, including summoner info, LP, and win/loss stats.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/league/v4/entries/RANKED_SOLO_5x5/DIAMOND/I?region=euw1&amp;page=1\"\n    \"\"\"\n    logger.info(\n        \"Fetching league entries\",\n        queue=params.queue,\n        tier=params.tier,\n        division=params.division,\n        region=query.region,\n        page=query.page,\n    )\n\n    # Check cache first\n    cache_key = (\n        f\"league:entries:{query.region}:{params.queue}:{params.tier}:{params.division}:{query.page}\"\n    )\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for league entries\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/entries/{params.queue}/{params.tier}/{params.division}\"\n    # Add page parameter if not default\n    if query.page != 1:\n        path += f\"?page={query.page}\"\n\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache (1 hour - league entries change frequently)\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"League entries fetched\",\n        queue=params.queue,\n        tier=params.tier,\n        division=params.division,\n        entries=len(data),\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#league-exp-router","title":"League EXP Router","text":""},{"location":"api/routers/#app.routers.league_exp","title":"<code>app.routers.league_exp</code>","text":"<p>League-EXP-V4 API endpoints (Experimental) - Priority 5.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#league-exp-v4</p> <p>Note: This is an experimental API providing paginated league entries.</p>"},{"location":"api/routers/#app.routers.league_exp.get_league_exp_entries","title":"<code>get_league_exp_entries(params: Annotated[LeagueExpEntriesParams, Depends()], query: Annotated[LeagueExpEntriesQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves league entries from the experimental endpoint.</p> <p>This endpoint provides paginated access to league entries for a specific rank, allowing for the retrieval of large sets of ranked players.</p> <p>API Reference: https://developer.riotgames.com/apis#league-exp-v4/GET_getLeagueEntries</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>LeagueExpEntriesParams</code> <p>The path parameters, containing the queue, tier, and division.</p> required <code>query</code> <code>LeagueExpEntriesQuery</code> <p>The query parameters, specifying the region and page number.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of league entry objects, including summoner info, LP, and win/loss stats.</p> Example <p>curl \"http://127.0.0.1:8080/lol/league-exp/v4/entries/RANKED_SOLO_5x5/DIAMOND/I?region=euw1&amp;page=1\"</p> Source code in <code>app/routers/league_exp.py</code> <pre><code>@router.get(\"/entries/{queue}/{tier}/{division}\")\nasync def get_league_exp_entries(\n    params: Annotated[LeagueExpEntriesParams, Depends()],\n    query: Annotated[LeagueExpEntriesQuery, Depends()],\n):\n    \"\"\"\n    Retrieves league entries from the experimental endpoint.\n\n    This endpoint provides paginated access to league entries for a specific\n    rank, allowing for the retrieval of large sets of ranked players.\n\n    API Reference: https://developer.riotgames.com/apis#league-exp-v4/GET_getLeagueEntries\n\n    Args:\n        params (LeagueExpEntriesParams): The path parameters, containing the queue, tier, and division.\n        query (LeagueExpEntriesQuery): The query parameters, specifying the region and page number.\n\n    Returns:\n        list: A list of league entry objects, including summoner info, LP, and win/loss stats.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/league-exp/v4/entries/RANKED_SOLO_5x5/DIAMOND/I?region=euw1&amp;page=1\"\n    \"\"\"\n    logger.info(\n        \"Fetching league exp entries\",\n        queue=params.queue,\n        tier=params.tier,\n        division=params.division,\n        region=query.region,\n        page=query.page,\n    )\n\n    # Check cache first\n    cache_key = f\"league-exp:entries:{query.region}:{params.queue}:{params.tier}:{params.division}:{query.page}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for league exp entries\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league-exp/v4/entries/{params.queue}/{params.tier}/{params.division}\"\n    # Add page parameter if not default\n    if query.page != 1:\n        path += f\"?page={query.page}\"\n\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache (1 hour - league entries change frequently)\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"League exp entries fetched\",\n        queue=params.queue,\n        tier=params.tier,\n        division=params.division,\n        entries=len(data),\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#champion-router","title":"Champion Router","text":""},{"location":"api/routers/#app.routers.champion","title":"<code>app.routers.champion</code>","text":"<p>Champion-V3 API endpoints.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#champion-v3</p>"},{"location":"api/routers/#app.routers.champion.get_champion_rotations","title":"<code>get_champion_rotations(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the current champion rotation.</p> <p>This endpoint fetches the list of free-to-play champions, including those available for new players. The results are cached to optimize performance.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-v3/GET_getChampionInfo</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The region to fetch the champion rotation from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the list of free champion IDs, a separate   list for new players, and the maximum level for the new player rotation.</p> Example <p>curl \"http://127.0.0.1:8080/lol/platform/v3/champion-rotations?region=euw1\"</p> Source code in <code>app/routers/champion.py</code> <pre><code>@router.get(\"/champion-rotations\")\nasync def get_champion_rotations(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves the current champion rotation.\n\n    This endpoint fetches the list of free-to-play champions, including those\n    available for new players. The results are cached to optimize performance.\n\n    API Reference: https://developer.riotgames.com/apis#champion-v3/GET_getChampionInfo\n\n    Args:\n        region (str): The region to fetch the champion rotation from.\n\n    Returns:\n        dict: A dictionary containing the list of free champion IDs, a separate\n              list for new players, and the maximum level for the new player rotation.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/platform/v3/champion-rotations?region=euw1\"\n    \"\"\"\n    cache_key = f\"champion:rotation:{region}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for champion rotation\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching champion rotation from Riot API\", region=region)\n    path = \"/lol/platform/v3/champion-rotations\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_champion_rotation)\n    logger.success(\"Champion rotation fetched\", region=region)\n\n    return data\n</code></pre>"},{"location":"api/routers/#champion-mastery-router","title":"Champion Mastery Router","text":""},{"location":"api/routers/#app.routers.champion_mastery","title":"<code>app.routers.champion_mastery</code>","text":"<p>Champion-Mastery-V4 API endpoints.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#champion-mastery-v4</p>"},{"location":"api/routers/#app.routers.champion_mastery.get_all_champion_masteries","title":"<code>get_all_champion_masteries(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves all champion mastery entries for a summoner.</p> <p>This endpoint fetches a list of all champion mastery objects for a given player, sorted by champion level in descending order. The results are cached to optimize performance.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getAllChampionMasteries</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's unique PUUID.</p> required <code>region</code> <code>str</code> <p>The region to fetch the champion mastery data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of champion mastery objects.</p> Example <p>curl \"http://127.0.0.1:8080/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}?region=euw1\"</p> Source code in <code>app/routers/champion_mastery.py</code> <pre><code>@router.get(\"/champion-masteries/by-puuid/{puuid}\")\nasync def get_all_champion_masteries(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Retrieves all champion mastery entries for a summoner.\n\n    This endpoint fetches a list of all champion mastery objects for a given\n    player, sorted by champion level in descending order. The results are\n    cached to optimize performance.\n\n    API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getAllChampionMasteries\n\n    Args:\n        puuid (str): The player's unique PUUID.\n        region (str): The region to fetch the champion mastery data from.\n\n    Returns:\n        list: A list of champion mastery objects.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}?region=euw1\"\n    \"\"\"\n    cache_key = f\"mastery:all:{region}:{puuid}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for champion masteries\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching all champion masteries\", puuid=puuid[:8], region=region)\n    path = f\"/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with 1 hour TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_mastery)\n    logger.success(\"Champion masteries fetched\", puuid=puuid[:8], count=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.champion_mastery.get_champion_mastery","title":"<code>get_champion_mastery(puuid: str, championId: int, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the champion mastery entry for a specific champion.</p> <p>This endpoint fetches a single champion mastery object, which includes details like level, points, and tokens. The results are cached for improved performance.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getChampionMastery</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's unique PUUID.</p> required <code>championId</code> <code>int</code> <p>The ID of the champion.</p> required <code>region</code> <code>str</code> <p>The region to fetch the mastery data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the champion mastery information.</p> Example <p>curl \"http://127.0.0.1:8080/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/1?region=euw1\"</p> Source code in <code>app/routers/champion_mastery.py</code> <pre><code>@router.get(\"/champion-masteries/by-puuid/{puuid}/by-champion/{championId}\")\nasync def get_champion_mastery(\n    puuid: str,\n    championId: int,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves the champion mastery entry for a specific champion.\n\n    This endpoint fetches a single champion mastery object, which includes\n    details like level, points, and tokens. The results are cached for\n    improved performance.\n\n    API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getChampionMastery\n\n    Args:\n        puuid (str): The player's unique PUUID.\n        championId (int): The ID of the champion.\n        region (str): The region to fetch the mastery data from.\n\n    Returns:\n        dict: A dictionary containing the champion mastery information.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/1?region=euw1\"\n    \"\"\"\n    cache_key = f\"mastery:champion:{region}:{puuid}:{championId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for champion mastery\", puuid=puuid[:8], championId=championId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching champion mastery\", puuid=puuid[:8], championId=championId, region=region)\n    path = f\"/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with 1 hour TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_mastery)\n    logger.success(\"Champion mastery fetched\", puuid=puuid[:8], championId=championId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.champion_mastery.get_top_champion_masteries","title":"<code>get_top_champion_masteries(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'), count: int = Query(default=3, ge=1, le=20, description='Number of top champions'))</code>  <code>async</code>","text":"<p>Retrieves the top N champion mastery entries for a summoner.</p> <p>This endpoint fetches a list of the highest-scoring champion mastery objects for a player. The number of champions to return can be specified with the <code>count</code> parameter.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getTopChampionMasteries</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's unique PUUID.</p> required <code>region</code> <code>str</code> <p>The region to fetch the mastery data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <code>count</code> <code>int</code> <p>The number of top champions to retrieve (1-20, default 3).</p> <code>Query(default=3, ge=1, le=20, description='Number of top champions')</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of the top champion mastery objects.</p> Example <p>curl \"http://127.0.0.1:8080/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top?region=euw1&amp;count=5\"</p> Source code in <code>app/routers/champion_mastery.py</code> <pre><code>@router.get(\"/champion-masteries/by-puuid/{puuid}/top\")\nasync def get_top_champion_masteries(\n    puuid: str,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n    count: int = Query(default=3, ge=1, le=20, description=\"Number of top champions\"),\n):\n    \"\"\"\n    Retrieves the top N champion mastery entries for a summoner.\n\n    This endpoint fetches a list of the highest-scoring champion mastery\n    objects for a player. The number of champions to return can be specified\n    with the `count` parameter.\n\n    API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getTopChampionMasteries\n\n    Args:\n        puuid (str): The player's unique PUUID.\n        region (str): The region to fetch the mastery data from.\n        count (int): The number of top champions to retrieve (1-20, default 3).\n\n    Returns:\n        list: A list of the top champion mastery objects.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top?region=euw1&amp;count=5\"\n    \"\"\"\n    cache_key = f\"mastery:top:{region}:{puuid}:{count}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for top masteries\", puuid=puuid[:8], count=count)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching top champion masteries\", puuid=puuid[:8], count=count, region=region)\n    path = f\"/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False, params={\"count\": count})\n\n    # Cache with 1 hour TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_mastery)\n    logger.success(\"Top champion masteries fetched\", puuid=puuid[:8], count=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.champion_mastery.get_mastery_score","title":"<code>get_mastery_score(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the total mastery score for a summoner.</p> <p>This endpoint calculates and returns the total mastery score, which is the sum of all individual champion mastery levels.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getChampionMasteryScore</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's unique PUUID.</p> required <code>region</code> <code>str</code> <p>The region to fetch the mastery score from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The total mastery score for the summoner.</p> Example <p>curl \"http://127.0.0.1:8080/lol/champion-mastery/v4/scores/by-puuid/{puuid}?region=euw1\"</p> Source code in <code>app/routers/champion_mastery.py</code> <pre><code>@router.get(\"/scores/by-puuid/{puuid}\")\nasync def get_mastery_score(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Retrieves the total mastery score for a summoner.\n\n    This endpoint calculates and returns the total mastery score, which is the\n    sum of all individual champion mastery levels.\n\n    API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getChampionMasteryScore\n\n    Args:\n        puuid (str): The player's unique PUUID.\n        region (str): The region to fetch the mastery score from.\n\n    Returns:\n        int: The total mastery score for the summoner.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/champion-mastery/v4/scores/by-puuid/{puuid}?region=euw1\"\n    \"\"\"\n    cache_key = f\"mastery:score:{region}:{puuid}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data is not None:  # Score can be 0\n        logger.debug(\"Cache hit for mastery score\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching mastery score\", puuid=puuid[:8], region=region)\n    path = f\"/lol/champion-mastery/v4/scores/by-puuid/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with 1 hour TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_mastery)\n    logger.success(\"Mastery score fetched\", puuid=puuid[:8], score=data)\n\n    return data\n</code></pre>"},{"location":"api/routers/#spectator-router","title":"Spectator Router","text":""},{"location":"api/routers/#app.routers.spectator","title":"<code>app.routers.spectator</code>","text":"<p>Spectator-V5 API endpoints.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#spectator-v5</p>"},{"location":"api/routers/#app.routers.spectator.get_active_game","title":"<code>get_active_game(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the active game for a summoner.</p> <p>This endpoint fetches the current game information for a player, if they are currently in a game. It returns a 404 error if the player is not in a game.</p> <p>API Reference: https://developer.riotgames.com/apis#spectator-v5/GET_getCurrentGameInfoByPuuid</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's unique PUUID.</p> required <code>region</code> <code>str</code> <p>The region to fetch the game data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the active game information, including   game mode, start time, participants, and banned champions.</p> Example <p>curl \"http://127.0.0.1:8080/lol/spectator/v5/active-games/by-summoner/{puuid}?region=euw1\"</p> Source code in <code>app/routers/spectator.py</code> <pre><code>@router.get(\"/active-games/by-summoner/{puuid}\")\nasync def get_active_game(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Retrieves the active game for a summoner.\n\n    This endpoint fetches the current game information for a player, if they\n    are currently in a game. It returns a 404 error if the player is not in a\n    game.\n\n    API Reference: https://developer.riotgames.com/apis#spectator-v5/GET_getCurrentGameInfoByPuuid\n\n    Args:\n        puuid (str): The player's unique PUUID.\n        region (str): The region to fetch the game data from.\n\n    Returns:\n        dict: A dictionary containing the active game information, including\n              game mode, start time, participants, and banned champions.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/spectator/v5/active-games/by-summoner/{puuid}?region=euw1\"\n    \"\"\"\n    # Note: Active games should not be cached heavily as they change quickly\n    cache_key = f\"spectator:active:{region}:{puuid}\"\n\n    # Check cache with short TTL\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for active game\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching active game\", puuid=puuid[:8], region=region)\n    path = f\"/lol/spectator/v5/active-games/by-summoner/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_spectator_active)\n    logger.success(\"Active game fetched\", puuid=puuid[:8], gameId=data.get(\"gameId\"))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.spectator.get_featured_games","title":"<code>get_featured_games(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves a list of featured games.</p> <p>This endpoint fetches a list of high-profile matches that are currently featured in the League of Legends client.</p> <p>API Reference: https://developer.riotgames.com/apis#spectator-v5/GET_getFeaturedGames</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The region to fetch the featured games from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the list of featured games and the   client refresh interval.</p> Example <p>curl \"http://127.0.0.1:8080/lol/spectator/v5/featured-games?region=euw1\"</p> Source code in <code>app/routers/spectator.py</code> <pre><code>@router.get(\"/featured-games\")\nasync def get_featured_games(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves a list of featured games.\n\n    This endpoint fetches a list of high-profile matches that are currently\n    featured in the League of Legends client.\n\n    API Reference: https://developer.riotgames.com/apis#spectator-v5/GET_getFeaturedGames\n\n    Args:\n        region (str): The region to fetch the featured games from.\n\n    Returns:\n        dict: A dictionary containing the list of featured games and the\n              client refresh interval.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/spectator/v5/featured-games?region=euw1\"\n    \"\"\"\n    cache_key = f\"spectator:featured:{region}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for featured games\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching featured games\", region=region)\n    path = \"/lol/spectator/v5/featured-games\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_spectator_featured)\n    logger.success(\"Featured games fetched\", region=region, count=len(data.get(\"gameList\", [])))\n\n    return data\n</code></pre>"},{"location":"api/routers/#platform-router","title":"Platform Router","text":""},{"location":"api/routers/#app.routers.platform","title":"<code>app.routers.platform</code>","text":"<p>Platform-V4 / LOL-STATUS-V4 API endpoints.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#lol-status-v4</p>"},{"location":"api/routers/#app.routers.platform.get_platform_status","title":"<code>get_platform_status(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the platform status for a specific region.</p> <p>This endpoint fetches the current status of the League of Legends platform, including any ongoing maintenance or incidents.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-status-v4/GET_getPlatformData</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The region to fetch the platform status for.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the platform status, including region ID,   name, locales, maintenances, and incidents.</p> Example <p>curl \"http://127.0.0.1:8080/lol/status/v4/platform-data?region=euw1\"</p> Source code in <code>app/routers/platform.py</code> <pre><code>@router.get(\"/platform-data\")\nasync def get_platform_status(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves the platform status for a specific region.\n\n    This endpoint fetches the current status of the League of Legends platform,\n    including any ongoing maintenance or incidents.\n\n    API Reference: https://developer.riotgames.com/apis#lol-status-v4/GET_getPlatformData\n\n    Args:\n        region (str): The region to fetch the platform status for.\n\n    Returns:\n        dict: A dictionary containing the platform status, including region ID,\n              name, locales, maintenances, and incidents.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/status/v4/platform-data?region=euw1\"\n    \"\"\"\n    cache_key = f\"platform:status:{region}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for platform status\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching platform status\", region=region)\n    path = \"/lol/status/v4/platform-data\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_platform_status)\n\n    logger.success(\n        \"Platform status fetched\",\n        region=region,\n        maintenances=len(data.get(\"maintenances\", [])),\n        incidents=len(data.get(\"incidents\", [])),\n    )\n\n    return data\n</code></pre>"},{"location":"api/routers/#account-router","title":"Account Router","text":""},{"location":"api/routers/#app.routers.account","title":"<code>app.routers.account</code>","text":"<p>Account-V1 API endpoints (Riot ID lookups).</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#account-v1</p>"},{"location":"api/routers/#app.routers.account.get_account_by_puuid","title":"<code>get_account_by_puuid(params: Annotated[AccountByPuuidParams, Depends()], query: Annotated[AccountByPuuidQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves an account by its PUUID.</p> <p>This endpoint fetches account information, including the game name and tag line, based on a player's unique PUUID. It supports regional routing and caches the results to improve performance.</p> <p>API Reference: https://developer.riotgames.com/apis#account-v1/GET_getByPuuid</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>AccountByPuuidParams</code> <p>The path parameters, containing the PUUID.</p> required <code>query</code> <code>AccountByPuuidQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the account's PUUID, game name, and tag line.</p> Example <p>curl \"http://127.0.0.1:8080/riot/account/v1/accounts/by-puuid/{puuid}?region=americas\"</p> Source code in <code>app/routers/account.py</code> <pre><code>@router.get(\"/accounts/by-puuid/{puuid}\")\nasync def get_account_by_puuid(\n    params: Annotated[AccountByPuuidParams, Depends()],\n    query: Annotated[AccountByPuuidQuery, Depends()],\n):\n    \"\"\"\n    Retrieves an account by its PUUID.\n\n    This endpoint fetches account information, including the game name and tag line,\n    based on a player's unique PUUID. It supports regional routing and caches\n    the results to improve performance.\n\n    API Reference: https://developer.riotgames.com/apis#account-v1/GET_getByPuuid\n\n    Args:\n        params (AccountByPuuidParams): The path parameters, containing the PUUID.\n        query (AccountByPuuidQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A dictionary containing the account's PUUID, game name, and tag line.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/riot/account/v1/accounts/by-puuid/{puuid}?region=americas\"\n    \"\"\"\n    cache_key = f\"account:puuid:{query.region}:{params.puuid}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for account by PUUID\", puuid=params.puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API (use platform endpoint for regional routing)\n    logger.info(\"Fetching account by PUUID\", puuid=params.puuid[:8], region=query.region)\n    path = f\"/riot/account/v1/accounts/by-puuid/{params.puuid}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_account)\n    logger.success(\n        \"Account fetched by PUUID\", puuid=params.puuid[:8], gameName=data.get(\"gameName\")\n    )\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.account.get_account_by_riot_id","title":"<code>get_account_by_riot_id(params: Annotated[AccountByRiotIdParams, Depends()], query: Annotated[AccountByRiotIdQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves an account by its Riot ID.</p> <p>This endpoint fetches account information based on a player's game name and tag line. It supports regional routing and caches the results to optimize performance.</p> <p>API Reference: https://developer.riotgames.com/apis#account-v1/GET_getByRiotId</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>AccountByRiotIdParams</code> <p>The path parameters, containing the game name and tag line.</p> required <code>query</code> <code>AccountByRiotIdQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the account's PUUID, game name, and tag line.</p> Example <p>curl \"http://127.0.0.1:8080/riot/account/v1/accounts/by-riot-id/Faker/KR1?region=americas\"</p> Source code in <code>app/routers/account.py</code> <pre><code>@router.get(\"/accounts/by-riot-id/{gameName}/{tagLine}\")\nasync def get_account_by_riot_id(\n    params: Annotated[AccountByRiotIdParams, Depends()],\n    query: Annotated[AccountByRiotIdQuery, Depends()],\n):\n    \"\"\"\n    Retrieves an account by its Riot ID.\n\n    This endpoint fetches account information based on a player's game name and\n    tag line. It supports regional routing and caches the results to optimize\n    performance.\n\n    API Reference: https://developer.riotgames.com/apis#account-v1/GET_getByRiotId\n\n    Args:\n        params (AccountByRiotIdParams): The path parameters, containing the game name and tag line.\n        query (AccountByRiotIdQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A dictionary containing the account's PUUID, game name, and tag line.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/riot/account/v1/accounts/by-riot-id/Faker/KR1?region=americas\"\n    \"\"\"\n    cache_key = f\"account:riotid:{query.region}:{params.gameName}:{params.tagLine}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\n            \"Cache hit for account by Riot ID\", gameName=params.gameName, tagLine=params.tagLine\n        )\n        return cached_data\n\n    # Fetch from Riot API (use platform endpoint for regional routing)\n    logger.info(\n        \"Fetching account by Riot ID\",\n        gameName=params.gameName,\n        tagLine=params.tagLine,\n        region=query.region,\n    )\n    path = f\"/riot/account/v1/accounts/by-riot-id/{params.gameName}/{params.tagLine}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_account)\n    logger.success(\n        \"Account fetched by Riot ID\", gameName=params.gameName, puuid=data.get(\"puuid\", \"\")[:8]\n    )\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.account.get_active_shard","title":"<code>get_active_shard(params: Annotated[ActiveShardParams, Depends()], query: Annotated[ActiveShardQuery, Depends()])</code>  <code>async</code>","text":"<p>Retrieves the active shard for a player.</p> <p>This endpoint identifies the active game server for a player based on their PUUID and the specified game. It supports regional routing and uses a short cache TTL to ensure the data remains current.</p> <p>API Reference: https://developer.riotgames.com/apis#account-v1/GET_getActiveShard</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ActiveShardParams</code> <p>The path parameters, containing the game and PUUID.</p> required <code>query</code> <code>ActiveShardQuery</code> <p>The query parameters, specifying the region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the PUUID, game, and active shard.</p> Example <p>curl \"http://127.0.0.1:8080/riot/account/v1/active-shards/by-game/val/by-puuid/{puuid}?region=americas\"</p> Source code in <code>app/routers/account.py</code> <pre><code>@router.get(\"/active-shards/by-game/{game}/by-puuid/{puuid}\")\nasync def get_active_shard(\n    params: Annotated[ActiveShardParams, Depends()],\n    query: Annotated[ActiveShardQuery, Depends()],\n):\n    \"\"\"\n    Retrieves the active shard for a player.\n\n    This endpoint identifies the active game server for a player based on their\n    PUUID and the specified game. It supports regional routing and uses a short\n    cache TTL to ensure the data remains current.\n\n    API Reference: https://developer.riotgames.com/apis#account-v1/GET_getActiveShard\n\n    Args:\n        params (ActiveShardParams): The path parameters, containing the game and PUUID.\n        query (ActiveShardQuery): The query parameters, specifying the region.\n\n    Returns:\n        dict: A dictionary containing the PUUID, game, and active shard.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/riot/account/v1/active-shards/by-game/val/by-puuid/{puuid}?region=americas\"\n    \"\"\"\n    cache_key = f\"account:shard:{query.region}:{params.game}:{params.puuid}\"\n\n    # Check cache (short TTL as active shard can change)\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for active shard\", puuid=params.puuid[:8], game=params.game)\n        return cached_data\n\n    # Fetch from Riot API (use platform endpoint for regional routing)\n    logger.info(\n        \"Fetching active shard\", puuid=params.puuid[:8], game=params.game, region=query.region\n    )\n    path = f\"/riot/account/v1/active-shards/by-game/{params.game}/by-puuid/{params.puuid}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_account_shard)\n    logger.success(\"Active shard fetched\", puuid=params.puuid[:8], shard=data.get(\"activeShard\"))\n\n    return data\n</code></pre>"},{"location":"api/routers/#clash-router","title":"Clash Router","text":""},{"location":"api/routers/#app.routers.clash","title":"<code>app.routers.clash</code>","text":"<p>Clash-V1 API endpoints (Clash tournament data).</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#clash-v1</p>"},{"location":"api/routers/#app.routers.clash.get_clash_player","title":"<code>get_clash_player(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves Clash player information by PUUID.</p> <p>This endpoint fetches a list of a player's Clash tournament registrations. Due to the dynamic nature of tournament data, it uses a short cache TTL.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getPlayersByPUUID</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's unique PUUID.</p> required <code>region</code> <code>str</code> <p>The region to fetch the Clash player data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of player registration objects, each containing details   like summonerId, teamId, position, and role.</p> Example <p>curl \"http://127.0.0.1:8080/lol/clash/v1/players/by-puuid/{puuid}?region=euw1\"</p> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/players/by-puuid/{puuid}\")\nasync def get_clash_player(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Retrieves Clash player information by PUUID.\n\n    This endpoint fetches a list of a player's Clash tournament registrations.\n    Due to the dynamic nature of tournament data, it uses a short cache TTL.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getPlayersByPUUID\n\n    Args:\n        puuid (str): The player's unique PUUID.\n        region (str): The region to fetch the Clash player data from.\n\n    Returns:\n        list: A list of player registration objects, each containing details\n              like summonerId, teamId, position, and role.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/clash/v1/players/by-puuid/{puuid}?region=euw1\"\n    \"\"\"\n    cache_key = f\"clash:player:{region}:{puuid}\"\n\n    # Check cache (short TTL as tournament data changes)\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash player\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash player data\", puuid=puuid[:8], region=region)\n    path = f\"/lol/clash/v1/players/by-puuid/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_player)\n    logger.success(\"Clash player data fetched\", puuid=puuid[:8], registrations=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.clash.get_clash_team","title":"<code>get_clash_team(teamId: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves Clash team information by team ID.</p> <p>This endpoint fetches detailed information about a Clash team, including its tournament ID, name, icon, tier, and list of players.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTeamById</p> <p>Parameters:</p> Name Type Description Default <code>teamId</code> <code>str</code> <p>The ID of the Clash team.</p> required <code>region</code> <code>str</code> <p>The region to fetch the team data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the Clash team's details.</p> Example <p>curl \"http://127.0.0.1:8080/lol/clash/v1/teams/{teamId}?region=euw1\"</p> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/teams/{teamId}\")\nasync def get_clash_team(\n    teamId: str,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves Clash team information by team ID.\n\n    This endpoint fetches detailed information about a Clash team, including\n    its tournament ID, name, icon, tier, and list of players.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTeamById\n\n    Args:\n        teamId (str): The ID of the Clash team.\n        region (str): The region to fetch the team data from.\n\n    Returns:\n        dict: A dictionary containing the Clash team's details.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/clash/v1/teams/{teamId}?region=euw1\"\n    \"\"\"\n    cache_key = f\"clash:team:{region}:{teamId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash team\", teamId=teamId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash team data\", teamId=teamId, region=region)\n    path = f\"/lol/clash/v1/teams/{teamId}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_team)\n    logger.success(\"Clash team data fetched\", teamId=teamId, name=data.get(\"name\"))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.clash.get_clash_tournaments","title":"<code>get_clash_tournaments(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves all active and upcoming Clash tournaments.</p> <p>This endpoint fetches a list of all current and future Clash tournaments, including their schedules and themes.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournaments</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The region to fetch the tournament data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of tournament objects.</p> Example <p>curl \"http://127.0.0.1:8080/lol/clash/v1/tournaments?region=euw1\"</p> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/tournaments\")\nasync def get_clash_tournaments(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves all active and upcoming Clash tournaments.\n\n    This endpoint fetches a list of all current and future Clash tournaments,\n    including their schedules and themes.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournaments\n\n    Args:\n        region (str): The region to fetch the tournament data from.\n\n    Returns:\n        list: A list of tournament objects.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/clash/v1/tournaments?region=euw1\"\n    \"\"\"\n    cache_key = f\"clash:tournaments:{region}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash tournaments\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash tournaments\", region=region)\n    path = \"/lol/clash/v1/tournaments\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_tournament)\n    logger.success(\"Clash tournaments fetched\", region=region, count=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.clash.get_clash_tournament","title":"<code>get_clash_tournament(tournamentId: int, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves a Clash tournament by its ID.</p> <p>This endpoint fetches detailed information about a specific Clash tournament, including its schedule and theme.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournamentById</p> <p>Parameters:</p> Name Type Description Default <code>tournamentId</code> <code>int</code> <p>The ID of the tournament.</p> required <code>region</code> <code>str</code> <p>The region to fetch the tournament data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the tournament's details.</p> Example <p>curl \"http://127.0.0.1:8080/lol/clash/v1/tournaments/{tournamentId}?region=euw1\"</p> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/tournaments/{tournamentId}\")\nasync def get_clash_tournament(\n    tournamentId: int,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves a Clash tournament by its ID.\n\n    This endpoint fetches detailed information about a specific Clash\n    tournament, including its schedule and theme.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournamentById\n\n    Args:\n        tournamentId (int): The ID of the tournament.\n        region (str): The region to fetch the tournament data from.\n\n    Returns:\n        dict: A dictionary containing the tournament's details.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/clash/v1/tournaments/{tournamentId}?region=euw1\"\n    \"\"\"\n    cache_key = f\"clash:tournament:{region}:{tournamentId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash tournament\", tournamentId=tournamentId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash tournament\", tournamentId=tournamentId, region=region)\n    path = f\"/lol/clash/v1/tournaments/{tournamentId}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_tournament)\n    logger.success(\"Clash tournament fetched\", tournamentId=tournamentId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.clash.get_clash_tournament_by_team","title":"<code>get_clash_tournament_by_team(teamId: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the Clash tournament a team is registered for.</p> <p>This endpoint fetches the tournament object for the tournament that the specified team is a part of.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournamentByTeam</p> <p>Parameters:</p> Name Type Description Default <code>teamId</code> <code>str</code> <p>The ID of the team.</p> required <code>region</code> <code>str</code> <p>The region to fetch the tournament data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the tournament's details.</p> Example <p>curl \"http://127.0.0.1:8080/lol/clash/v1/tournaments/by-team/{teamId}?region=euw1\"</p> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/tournaments/by-team/{teamId}\")\nasync def get_clash_tournament_by_team(\n    teamId: str,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves the Clash tournament a team is registered for.\n\n    This endpoint fetches the tournament object for the tournament that the\n    specified team is a part of.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournamentByTeam\n\n    Args:\n        teamId (str): The ID of the team.\n        region (str): The region to fetch the tournament data from.\n\n    Returns:\n        dict: A dictionary containing the tournament's details.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/clash/v1/tournaments/by-team/{teamId}?region=euw1\"\n    \"\"\"\n    cache_key = f\"clash:tournament:team:{region}:{teamId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash tournament by team\", teamId=teamId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash tournament by team\", teamId=teamId, region=region)\n    path = f\"/lol/clash/v1/tournaments/by-team/{teamId}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_team)\n    logger.success(\"Clash tournament by team fetched\", teamId=teamId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#challenges-router","title":"Challenges Router","text":""},{"location":"api/routers/#app.routers.challenges","title":"<code>app.routers.challenges</code>","text":"<p>Challenges-V1 API endpoints (Player challenges and progression).</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#lol-challenges-v1</p>"},{"location":"api/routers/#app.routers.challenges.get_all_challenges_config","title":"<code>get_all_challenges_config(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the configuration for all challenges.</p> <p>This endpoint fetches a list of all available challenge configurations, including their IDs, localized names, and thresholds. The results are cached to optimize performance.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getAllChallengeConfigs</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The region to fetch the challenges configuration for.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of challenge configuration objects.</p> Example <p>curl \"http://127.0.0.1:8080/lol/challenges/v1/challenges/config?region=euw1\"</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/challenges/config\")\nasync def get_all_challenges_config(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves the configuration for all challenges.\n\n    This endpoint fetches a list of all available challenge configurations,\n    including their IDs, localized names, and thresholds. The results are\n    cached to optimize performance.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getAllChallengeConfigs\n\n    Args:\n        region (str): The region to fetch the challenges configuration for.\n\n    Returns:\n        list: A list of challenge configuration objects.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/challenges/v1/challenges/config?region=euw1\"\n    \"\"\"\n    cache_key = f\"challenges:config:{region}\"\n\n    # Check cache (challenges config changes rarely)\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenges config\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching challenges config\", region=region)\n    path = \"/lol/challenges/v1/challenges/config\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_config)\n    logger.success(\"Challenges config fetched\", region=region, count=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.challenges.get_challenge_config","title":"<code>get_challenge_config(challengeId: int, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the configuration for a specific challenge.</p> <p>This endpoint fetches the configuration for a single challenge by its ID, including details like thresholds and localized names. The results are cached for better performance.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengeConfigs</p> <p>Parameters:</p> Name Type Description Default <code>challengeId</code> <code>int</code> <p>The ID of the challenge to retrieve.</p> required <code>region</code> <code>str</code> <p>The region to fetch the challenge configuration from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the challenge configuration.</p> Example <p>curl \"http://127.0.0.1:8080/lol/challenges/v1/challenges/1/config?region=euw1\"</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/challenges/{challengeId}/config\")\nasync def get_challenge_config(\n    challengeId: int,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves the configuration for a specific challenge.\n\n    This endpoint fetches the configuration for a single challenge by its ID,\n    including details like thresholds and localized names. The results are\n    cached for better performance.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengeConfigs\n\n    Args:\n        challengeId (int): The ID of the challenge to retrieve.\n        region (str): The region to fetch the challenge configuration from.\n\n    Returns:\n        dict: A dictionary containing the challenge configuration.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/challenges/v1/challenges/1/config?region=euw1\"\n    \"\"\"\n    cache_key = f\"challenges:config:{region}:{challengeId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenge config\", challengeId=challengeId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching challenge config\", challengeId=challengeId, region=region)\n    path = f\"/lol/challenges/v1/challenges/{challengeId}/config\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_config)\n    logger.success(\"Challenge config fetched\", challengeId=challengeId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.challenges.get_challenge_leaderboard","title":"<code>get_challenge_leaderboard(challengeId: int, level: str, region: str = Query(default=(settings.riot_default_region), description='Region code'), limit: int = Query(default=None, ge=1, description='Limit results (optional)'))</code>  <code>async</code>","text":"<p>Retrieves the leaderboard for a specific challenge and level.</p> <p>This endpoint fetches the leaderboard for a given challenge, filtered by a specific competitive level (e.g., MASTER, GRANDMASTER). It supports an optional limit on the number of results and uses a short cache TTL to keep the data fresh.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengeLeaderboards</p> <p>Parameters:</p> Name Type Description Default <code>challengeId</code> <code>int</code> <p>The ID of the challenge.</p> required <code>level</code> <code>str</code> <p>The competitive level to retrieve the leaderboard for.</p> required <code>region</code> <code>str</code> <p>The region to fetch the leaderboard from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <code>limit</code> <code>int</code> <p>The maximum number of leaderboard entries to return.</p> <code>Query(default=None, ge=1, description='Limit results (optional)')</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of leaderboard entries, each containing player PUUIDs and their values.</p> Example <p>curl \"http://1227.0.0.1:8080/lol/challenges/v1/challenges/1/leaderboards/by-level/CHALLENGER?region=euw1&amp;limit=10\"</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/challenges/{challengeId}/leaderboards/by-level/{level}\")\nasync def get_challenge_leaderboard(\n    challengeId: int,\n    level: str,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n    limit: int = Query(default=None, ge=1, description=\"Limit results (optional)\"),\n):\n    \"\"\"\n    Retrieves the leaderboard for a specific challenge and level.\n\n    This endpoint fetches the leaderboard for a given challenge, filtered by\n    a specific competitive level (e.g., MASTER, GRANDMASTER). It supports an\n    optional limit on the number of results and uses a short cache TTL to\n    keep the data fresh.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengeLeaderboards\n\n    Args:\n        challengeId (int): The ID of the challenge.\n        level (str): The competitive level to retrieve the leaderboard for.\n        region (str): The region to fetch the leaderboard from.\n        limit (int, optional): The maximum number of leaderboard entries to return.\n\n    Returns:\n        list: A list of leaderboard entries, each containing player PUUIDs and their values.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://1227.0.0.1:8080/lol/challenges/v1/challenges/1/leaderboards/by-level/CHALLENGER?region=euw1&amp;limit=10\"\n    \"\"\"\n    cache_key = f\"challenges:leaderboard:{region}:{challengeId}:{level}:{limit}\"\n\n    # Check cache (short TTL as leaderboards change frequently)\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenge leaderboard\", challengeId=challengeId, level=level)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\n        \"Fetching challenge leaderboard\", challengeId=challengeId, level=level, region=region\n    )\n    path = f\"/lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}\"\n    params = {\"limit\": limit} if limit else None\n    data = await riot_client.get(path, region, is_platform_endpoint=False, params=params)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_leaderboard)\n    logger.success(\"Challenge leaderboard fetched\", challengeId=challengeId, level=level)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.challenges.get_challenge_percentiles","title":"<code>get_challenge_percentiles(challengeId: int, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves the percentile distribution for a challenge.</p> <p>This endpoint fetches a map of percentile values for a specific challenge, allowing for a detailed statistical overview. The results are cached to optimize performance.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengePercentiles</p> <p>Parameters:</p> Name Type Description Default <code>challengeId</code> <code>int</code> <p>The ID of the challenge.</p> required <code>region</code> <code>str</code> <p>The region to fetch the percentiles from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary mapping challenge values to their corresponding percentiles.</p> Example <p>curl \"http://127.0.0.1:8080/lol/challenges/v1/challenges/1/percentiles?region=euw1\"</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/challenges/{challengeId}/percentiles\")\nasync def get_challenge_percentiles(\n    challengeId: int,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Retrieves the percentile distribution for a challenge.\n\n    This endpoint fetches a map of percentile values for a specific challenge,\n    allowing for a detailed statistical overview. The results are cached to\n    optimize performance.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengePercentiles\n\n    Args:\n        challengeId (int): The ID of the challenge.\n        region (str): The region to fetch the percentiles from.\n\n    Returns:\n        dict: A dictionary mapping challenge values to their corresponding percentiles.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/challenges/v1/challenges/1/percentiles?region=euw1\"\n    \"\"\"\n    cache_key = f\"challenges:percentiles:{region}:{challengeId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenge percentiles\", challengeId=challengeId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching challenge percentiles\", challengeId=challengeId, region=region)\n    path = f\"/lol/challenges/v1/challenges/{challengeId}/percentiles\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_percentiles)\n    logger.success(\"Challenge percentiles fetched\", challengeId=challengeId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.challenges.get_player_challenges","title":"<code>get_player_challenges(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Retrieves all challenge data for a player.</p> <p>This endpoint fetches a comprehensive overview of a player's challenge progression, including their total points, category points, and individual challenge progress. The results are cached to optimize performance.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getPlayerData</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <code>str</code> <p>The player's unique PUUID.</p> required <code>region</code> <code>str</code> <p>The region to fetch the player's challenge data from.</p> <code>Query(default=riot_default_region, description='Region code')</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the player's total points, category points,   challenge progress, and preferences.</p> Example <p>curl \"http://127.0.0.1:8080/lol/challenges/v1/player-data/{puuid}?region=euw1\"</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/player-data/{puuid}\")\nasync def get_player_challenges(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Retrieves all challenge data for a player.\n\n    This endpoint fetches a comprehensive overview of a player's challenge\n    progression, including their total points, category points, and individual\n    challenge progress. The results are cached to optimize performance.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getPlayerData\n\n    Args:\n        puuid (str): The player's unique PUUID.\n        region (str): The region to fetch the player's challenge data from.\n\n    Returns:\n        dict: A dictionary containing the player's total points, category points,\n              challenge progress, and preferences.\n\n    Example:\n        &gt;&gt;&gt; curl \"http://127.0.0.1:8080/lol/challenges/v1/player-data/{puuid}?region=euw1\"\n    \"\"\"\n    cache_key = f\"challenges:player:{region}:{puuid}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for player challenges\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching player challenges\", puuid=puuid[:8], region=region)\n    path = f\"/lol/challenges/v1/player-data/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_player)\n    logger.success(\n        \"Player challenges fetched\",\n        puuid=puuid[:8],\n        totalPoints=data.get(\"totalPoints\", {}).get(\"current\", 0),\n    )\n\n    return data\n</code></pre>"},{"location":"architecture/caching/","title":"Caching Architecture","text":"<p>This section details the comprehensive caching strategy implemented in the LOLStonks API Gateway, designed to optimize performance while ensuring data freshness.</p> <p>\ud83d\udcdd Documentation Note: This document describes the conceptual architecture, best practices, and potential implementations for caching. The actual implementation uses the aiocache library with Redis backend. Many advanced features shown below (batch operations, cache warming, metrics) represent potential enhancements rather than current implementation.</p>"},{"location":"architecture/caching/#overview","title":"Overview","text":"<p>The caching system uses Redis as the primary caching backend with a multi-layer approach that balances performance, data freshness, and storage efficiency.</p>"},{"location":"architecture/caching/#caching-architecture_1","title":"Caching Architecture","text":"<pre><code>graph TB\n    Request[Client Request] --&gt; Gateway[API Gateway]\n    Gateway --&gt; CheckCache{Check Cache}\n\n    CheckCache --&gt;|Hit| ReturnCached[Return Cached Response]\n    CheckCache --&gt;|Miss| APICall[Make API Call]\n\n    APICall --&gt; RiotAPI[Riot API]\n    RiotAPI --&gt; ProcessResponse[Process Response]\n    ProcessResponse --&gt; StoreCache[Store in Cache]\n    StoreCache --&gt; ReturnResponse[Return Response]\n\n    ReturnCached --&gt; Client[Client Response]\n    ReturnResponse --&gt; Client\n\n    subgraph \"Cache Layers\"\n        L1[TTL Cache - Fast Access]\n        L2[Persistent Storage]\n        L3[Match Tracking Set]\n    end\n\n    StoreCache --&gt; L1\n    StoreCache --&gt; L2\n    StoreCache --&gt; L3\n</code></pre>"},{"location":"architecture/caching/#cache-configuration","title":"Cache Configuration","text":""},{"location":"architecture/caching/#environment-variables","title":"Environment Variables","text":"<pre><code># Redis connection settings\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=\nREDIS_POOL_SIZE=10\nREDIS_POOL_TIMEOUT=30\n\n# Cache TTL settings (in seconds)\nCACHE_TTL_SUMMONER=3600     # 1 hour\nCACHE_TTL_MATCH=86400       # 24 hours\nCACHE_TTL_LEAGUE=1800       # 30 minutes\nCACHE_TTL_MASTERY=7200      # 2 hours\nCACHE_TTL_CHAMPION=604800   # 1 week\nCACHE_TTL_CLASH=3600        # 1 hour\nCACHE_TTL_CHALLENGES=1800   # 30 minutes\n\n# Match tracking settings\nMATCH_TRACKING_TTL=604800   # 1 week\n</code></pre>"},{"location":"architecture/caching/#ttl-strategy","title":"TTL Strategy","text":"<p>Different data types have different TTL (Time To Live) values based on their volatility:</p> Data Type TTL Rationale Summoner Info 1 hour Profile data changes relatively infrequently Match Data 24 hours Historical data never changes League Data 30 minutes Competitive data changes frequently Champion Mastery 2 hours Mastery scores change regularly Champion Info 1 week Static data changes very infrequently Clash Data 1 hour Tournament data changes during events Challenges 30 minutes Challenge data updates frequently"},{"location":"architecture/caching/#redis-cache-implementation","title":"Redis Cache Implementation","text":"<p>\ud83d\udca1 Actual Implementation: The real code in <code>app/cache/redis_cache.py</code> uses a simple <code>aiocache.Cache</code> instance. The detailed class implementation below represents a potential custom implementation with additional features.</p>"},{"location":"architecture/caching/#core-cache-class","title":"Core Cache Class","text":"<pre><code># Conceptual implementation with advanced features (not actual code)\n# app/cache/redis_cache.py\nimport json\nimport asyncio\nfrom typing import Optional, Any, Union\nfrom datetime import datetime, timedelta\nimport redis.asyncio as redis\nfrom redis.asyncio import ConnectionPool\n\nclass RedisCache:\n    \"\"\"\n    High-performance Redis cache with TTL support and connection pooling.\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str = \"localhost\",\n        port: int = 6379,\n        db: int = 0,\n        password: Optional[str] = None,\n        pool_size: int = 10,\n        pool_timeout: int = 30\n    ):\n        self.pool = ConnectionPool.from_url(\n            f\"redis://:{password}@{host}:{port}/{db}\" if password else f\"redis://{host}:{port}/{db}\",\n            max_connections=pool_size,\n            socket_timeout=pool_timeout,\n            socket_connect_timeout=5,\n            retry_on_timeout=True\n        )\n        self.redis = redis.Redis(connection_pool=self.pool)\n        self.ttl_config = self._load_ttl_config()\n\n    def _load_ttl_config(self) -&gt; dict:\n        \"\"\"Load TTL configuration from environment variables.\"\"\"\n        return {\n            \"summoner\": int(os.getenv(\"CACHE_TTL_SUMMONER\", 3600)),\n            \"match\": int(os.getenv(\"CACHE_TTL_MATCH\", 86400)),\n            \"league\": int(os.getenv(\"CACHE_TTL_LEAGUE\", 1800)),\n            \"mastery\": int(os.getenv(\"CACHE_TTL_MASTERY\", 7200)),\n            \"champion\": int(os.getenv(\"CACHE_TTL_CHAMPION\", 604800)),\n            \"clash\": int(os.getenv(\"CACHE_TTL_CLASH\", 3600)),\n            \"challenges\": int(os.getenv(\"CACHE_TTL_CHALLENGES\", 1800))\n        }\n\n    def _generate_key(self, endpoint: str, region: str, identifier: str) -&gt; str:\n        \"\"\"Generate consistent cache key.\"\"\"\n        return f\"lolstonks:{endpoint}:{region}:{identifier}\"\n\n    async def get(self, endpoint: str, region: str, identifier: str) -&gt; Optional[dict]:\n        \"\"\"Get cached data.\"\"\"\n        key = self._generate_key(endpoint, region, identifier)\n        try:\n            cached_data = await self.redis.get(key)\n            if cached_data:\n                return json.loads(cached_data)\n        except Exception as e:\n            logger.error(f\"Cache get error for key {key}: {e}\")\n        return None\n\n    async def set(\n        self,\n        endpoint: str,\n        region: str,\n        identifier: str,\n        data: dict,\n        ttl: Optional[int] = None\n    ) -&gt; bool:\n        \"\"\"Set data in cache with TTL.\"\"\"\n        key = self._generate_key(endpoint, region, identifier)\n        if ttl is None:\n            ttl = self.ttl_config.get(endpoint, 3600)\n\n        try:\n            await self.redis.setex(\n                key,\n                ttl,\n                json.dumps(data, default=str)\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Cache set error for key {key}: {e}\")\n            return False\n\n    async def delete(self, endpoint: str, region: str, identifier: str) -&gt; bool:\n        \"\"\"Delete data from cache.\"\"\"\n        key = self._generate_key(endpoint, region, identifier)\n        try:\n            await self.redis.delete(key)\n            return True\n        except Exception as e:\n            logger.error(f\"Cache delete error for key {key}: {e}\")\n            return False\n</code></pre>"},{"location":"architecture/caching/#cache-decorator","title":"Cache Decorator","text":"<pre><code># app/cache/decorators.py\nimport functools\nfrom typing import Callable, Any\n\ndef cached(endpoint: str, ttl: Optional[int] = None):\n    \"\"\"\n    Decorator for caching function results.\n\n    Args:\n        endpoint: Cache endpoint type\n        ttl: Custom TTL override\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        @functools.wraps(func)\n        async def wrapper(*args, **kwargs) -&gt; Any:\n            # Extract cache parameters\n            region = kwargs.get('region', 'euw1')\n            cache_key = kwargs.get('cache_key', str(args[1:]) if args else str(kwargs))\n\n            cache: RedisCache = kwargs.get('cache')\n            if not cache:\n                return await func(*args, **kwargs)\n\n            # Try to get from cache\n            cached_result = await cache.get(endpoint, region, cache_key)\n            if cached_result:\n                logger.debug(f\"Cache hit for {endpoint}:{region}:{cache_key}\")\n                return cached_result\n\n            # Cache miss - execute function\n            logger.debug(f\"Cache miss for {endpoint}:{region}:{cache_key}\")\n            result = await func(*args, **kwargs)\n\n            # Store in cache\n            await cache.set(endpoint, region, cache_key, result, ttl)\n            return result\n\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"architecture/caching/#match-tracking-system","title":"Match Tracking System","text":"<p>\u2705 Implemented: The match tracking system in <code>app/cache/tracking.py</code> is fully implemented but uses a simpler approach than described below. The actual implementation uses Redis SET for permanent storage without the dual-layer TTL cache optimization shown here.</p>"},{"location":"architecture/caching/#dual-storage-approach","title":"Dual Storage Approach","text":"<p>The match tracking system uses both TTL cache and persistent storage:</p> <pre><code># Conceptual dual-layer implementation (actual code is simpler)\n# app/cache/tracking.py\nimport json\nfrom typing import Set\nfrom datetime import datetime, timedelta\n\nclass MatchTracker:\n    \"\"\"\n    Match tracking service to prevent duplicate match processing.\n\n    Uses dual storage:\n    1. TTL cache for recent matches (fast access)\n    2. Persistent Redis set for all processed matches\n    \"\"\"\n\n    def __init__(self, redis_cache: RedisCache, ttl: int = 604800):\n        self.cache = redis_cache\n        self.ttl = ttl\n        self.processed_key = \"lolstonks:matches:processed\"\n        self.recent_key = \"lolstonks:matches:recent\"\n\n    async def is_processed(self, match_id: str) -&gt; bool:\n        \"\"\"Check if match has been processed.\"\"\"\n        # Check TTL cache first (fast path)\n        in_recent = await self.cache.redis.exists(f\"{self.recent_key}:{match_id}\")\n        if in_recent:\n            return True\n\n        # Check persistent set\n        is_processed = await self.cache.redis.sismember(self.processed_key, match_id)\n\n        # If found in persistent set, add to recent cache for faster future checks\n        if is_processed:\n            await self.cache.redis.setex(\n                f\"{self.recent_key}:{match_id}\",\n                self.ttl,\n                \"1\"\n            )\n\n        return is_processed\n\n    async def mark_processed(self, match_id: str) -&gt; None:\n        \"\"\"Mark match as processed.\"\"\"\n        # Add to persistent set\n        await self.cache.redis.sadd(self.processed_key, match_id)\n\n        # Add to TTL cache for fast access\n        await self.cache.redis.setex(\n            f\"{self.recent_key}:{match_id}\",\n            self.ttl,\n            \"1\"\n        )\n\n    async def get_processed_count(self) -&gt; int:\n        \"\"\"Get total number of processed matches.\"\"\"\n        return await self.cache.redis.scard(self.processed_key)\n\n    async def cleanup_expired(self) -&gt; int:\n        \"\"\"Clean up expired entries from recent cache.\"\"\"\n        # This is handled automatically by Redis TTL\n        # But we can force cleanup if needed\n        pattern = f\"{self.recent_key}:*\"\n        cursor = 0\n        deleted = 0\n\n        while True:\n            cursor, keys = await self.cache.redis.scan(cursor, match=pattern, count=100)\n            if keys:\n                deleted += await self.cache.redis.delete(*keys)\n            if cursor == 0:\n                break\n\n        return deleted\n</code></pre>"},{"location":"architecture/caching/#cache-integration-with-routers","title":"Cache Integration with Routers","text":""},{"location":"architecture/caching/#example-router-with-caching","title":"Example Router with Caching","text":"<pre><code># app/routers/summoner.py\nfrom fastapi import APIRouter, Depends, Query\nfrom app.cache.redis_cache import RedisCache\nfrom app.cache.decorators import cached\nfrom app.riot.client import RiotClient\n\nrouter = APIRouter(prefix=\"/summoner\", tags=[\"summoner\"])\n\n@router.get(\"/by-name/{summonerName}\")\n@cached(endpoint=\"summoner\", ttl=3600)\nasync def get_summoner_by_name(\n    summonerName: str,\n    region: str = Query(default=\"euw1\"),\n    riot_client: RiotClient = Depends(),\n    cache: RedisCache = Depends()\n) -&gt; dict:\n    \"\"\"\n    Get summoner by summoner name with caching.\n\n    Cached for 1 hour to balance performance and data freshness.\n    \"\"\"\n    # Generate unique cache key\n    cache_key = f\"by-name:{summonerName.lower()}\"\n\n    # Make API call (only if cache miss)\n    return await riot_client.get(\n        f\"/lol/summoner/v4/summoners/by-name/{summonerName}\",\n        region=region\n    )\n\n@router.get(\"/by-puuid/{puuid}\")\n@cached(endpoint=\"summoner\", ttl=3600)\nasync def get_summoner_by_puuid(\n    puuid: str,\n    region: str = Query(default=\"euw1\"),\n    riot_client: RiotClient = Depends(),\n    cache: RedisCache = Depends()\n) -&gt; dict:\n    \"\"\"Get summoner by PUUID with caching.\"\"\"\n    cache_key = f\"by-puuid:{puuid}\"\n    return await riot_client.get(\n        f\"/lol/summoner/v4/summoners/by-puuid/{puuid}\",\n        region=region\n    )\n</code></pre>"},{"location":"architecture/caching/#cache-performance-optimization","title":"Cache Performance Optimization","text":""},{"location":"architecture/caching/#connection-pooling","title":"Connection Pooling","text":"<pre><code># Optimized connection pool configuration\nclass OptimizedRedisCache(RedisCache):\n    \"\"\"\n    Redis cache with optimized connection pooling.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        # Enhanced connection pool settings\n        pool_config = {\n            \"max_connections\": kwargs.get(\"pool_size\", 20),\n            \"retry_on_timeout\": True,\n            \"socket_keepalive\": True,\n            \"socket_keepalive_options\": {},\n            \"health_check_interval\": 30\n        }\n\n        super().__init__(**{**kwargs, **pool_config})\n\n    async def batch_get(self, keys: list[str]) -&gt; dict[str, Optional[dict]]:\n        \"\"\"Batch get multiple keys for better performance.\"\"\"\n        try:\n            values = await self.redis.mget(keys)\n            return {\n                key: json.loads(value) if value else None\n                for key, value in zip(keys, values)\n            }\n        except Exception as e:\n            logger.error(f\"Batch get error: {e}\")\n            return {key: None for key in keys}\n\n    async def batch_set(self, data: dict[str, dict], ttl: int) -&gt; bool:\n        \"\"\"Batch set multiple keys.\"\"\"\n        try:\n            pipe = self.redis.pipeline()\n            for key, value in data.items():\n                pipe.setex(key, ttl, json.dumps(value, default=str))\n            await pipe.execute()\n            return True\n        except Exception as e:\n            logger.error(f\"Batch set error: {e}\")\n            return False\n</code></pre>"},{"location":"architecture/caching/#cache-warming-strategy","title":"Cache Warming Strategy","text":"<pre><code># app/cache/warming.py\nclass CacheWarmer:\n    \"\"\"\n    Proactive cache warming for frequently accessed data.\n    \"\"\"\n\n    def __init__(self, riot_client: RiotClient, cache: RedisCache):\n        self.riot_client = riot_client\n        self.cache = cache\n        self.high_activity_summoners = set()\n\n    async def warm_summoner_cache(self, summoner_names: list[str], region: str) -&gt; None:\n        \"\"\"Warm cache for high-activity summoners.\"\"\"\n        for name in summoner_names:\n            try:\n                # Check if already cached\n                cached = await self.cache.get(\"summoner\", region, f\"by-name:{name}\")\n                if not cached:\n                    # Fetch and cache\n                    data = await self.riot_client.get(\n                        f\"/lol/summoner/v4/summoners/by-name/{name}\",\n                        region=region\n                    )\n                    await self.cache.set(\"summoner\", region, f\"by-name:{name}\", data)\n            except Exception as e:\n                logger.error(f\"Cache warming error for {name}: {e}\")\n\n    async def schedule_warming(self) -&gt; None:\n        \"\"\"Schedule periodic cache warming.\"\"\"\n        while True:\n            try:\n                # Warm cache for high-activity summoners\n                await self.warm_summoner_cache(\n                    list(self.high_activity_summoners),\n                    \"euw1\"  # Default region\n                )\n                await asyncio.sleep(300)  # Every 5 minutes\n            except Exception as e:\n                logger.error(f\"Cache warming error: {e}\")\n                await asyncio.sleep(60)  # Retry after 1 minute\n</code></pre>"},{"location":"architecture/caching/#cache-monitoring-and-metrics","title":"Cache Monitoring and Metrics","text":""},{"location":"architecture/caching/#cache-performance-metrics","title":"Cache Performance Metrics","text":"<pre><code># app/cache/metrics.py\nclass CacheMetrics:\n    \"\"\"\n    Cache performance metrics collection.\n    \"\"\"\n\n    def __init__(self):\n        self.hits = 0\n        self.misses = 0\n        self.sets = 0\n        self.errors = 0\n        self.start_time = datetime.utcnow()\n\n    def record_hit(self) -&gt; None:\n        \"\"\"Record cache hit.\"\"\"\n        self.hits += 1\n\n    def record_miss(self) -&gt; None:\n        \"\"\"Record cache miss.\"\"\"\n        self.misses += 1\n\n    def record_set(self) -&gt; None:\n        \"\"\"Record cache set operation.\"\"\"\n        self.sets += 1\n\n    def record_error(self) -&gt; None:\n        \"\"\"Record cache error.\"\"\"\n        self.errors += 1\n\n    def get_hit_rate(self) -&gt; float:\n        \"\"\"Calculate cache hit rate.\"\"\"\n        total = self.hits + self.misses\n        return (self.hits / total * 100) if total &gt; 0 else 0.0\n\n    def get_metrics(self) -&gt; dict:\n        \"\"\"Get current metrics.\"\"\"\n        uptime = (datetime.utcnow() - self.start_time).total_seconds()\n        return {\n            \"hits\": self.hits,\n            \"misses\": self.misses,\n            \"sets\": self.sets,\n            \"errors\": self.errors,\n            \"hit_rate\": self.get_hit_rate(),\n            \"uptime_seconds\": uptime,\n            \"operations_per_second\": (self.hits + self.misses + self.sets) / uptime\n        }\n</code></pre>"},{"location":"architecture/caching/#health-check-integration","title":"Health Check Integration","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check including cache status.\"\"\"\n    cache_metrics = cache_metrics_collector.get_metrics()\n\n    # Test Redis connection\n    try:\n        await cache.redis.ping()\n        cache_status = \"healthy\"\n    except Exception:\n        cache_status = \"unhealthy\"\n\n    return {\n        \"status\": \"ok\",\n        \"cache\": {\n            \"status\": cache_status,\n            \"hit_rate\": cache_metrics[\"hit_rate\"],\n            \"operations_per_second\": cache_metrics[\"operations_per_second\"],\n            \"total_operations\": cache_metrics[\"hits\"] + cache_metrics[\"misses\"]\n        }\n    }\n</code></pre>"},{"location":"architecture/caching/#advanced-features","title":"Advanced Features","text":""},{"location":"architecture/caching/#cache-invalidation","title":"Cache Invalidation","text":"<pre><code>class CacheInvalidation:\n    \"\"\"\n    Smart cache invalidation based on data changes.\n    \"\"\"\n\n    def __init__(self, cache: RedisCache):\n        self.cache = cache\n\n    async def invalidate_summoner_cache(self, puuid: str, region: str) -&gt; None:\n        \"\"\"Invalidate all cache entries for a summoner.\"\"\"\n        patterns = [\n            f\"lolstonks:summoner:{region}:by-puuid:{puuid}\",\n            f\"lolstonks:summoner:{region}:by-account:*\",  # Account-based entries\n            f\"lolstonks:mastery:{region}:{puuid}\",\n            f\"lolstonks:league:{region}:by-summoner:{puuid}\"\n        ]\n\n        for pattern in patterns:\n            if \"*\" in pattern:\n                # Delete all matching keys\n                cursor = 0\n                while True:\n                    cursor, keys = await self.cache.redis.scan(cursor, match=pattern)\n                    if keys:\n                        await self.cache.redis.delete(*keys)\n                    if cursor == 0:\n                        break\n            else:\n                await self.cache.redis.delete(pattern)\n\n    async def invalidate_match_cache(self, match_id: str, region: str) -&gt; None:\n        \"\"\"Invalidate cache entries for a match.\"\"\"\n        patterns = [\n            f\"lolstonks:match:{region}:by-id:{match_id}\",\n            f\"lolstonks:match:{region}:timeline:{match_id}\"\n        ]\n\n        for pattern in patterns:\n            await self.cache.redis.delete(pattern)\n</code></pre>"},{"location":"architecture/caching/#distributed-caching","title":"Distributed Caching","text":"<p>For multi-instance deployments:</p> <pre><code>class DistributedCache:\n    \"\"\"\n    Cache coordination across multiple instances.\n    \"\"\"\n\n    def __init__(self, cache: RedisCache, instance_id: str):\n        self.cache = cache\n        self.instance_id = instance_id\n        self.coordination_channel = \"cache:coordination\"\n\n    async def invalidate_global(self, key_pattern: str) -&gt; None:\n        \"\"\"Broadcast cache invalidation to all instances.\"\"\"\n        message = {\n            \"instance_id\": self.instance_id,\n            \"action\": \"invalidate\",\n            \"pattern\": key_pattern,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n\n        await self.cache.redis.publish(\n            self.coordination_channel,\n            json.dumps(message)\n        )\n\n    async def listen_for_invalidations(self) -&gt; None:\n        \"\"\"Listen for cache invalidation messages.\"\"\"\n        pubsub = self.cache.redis.pubsub()\n        await pubsub.subscribe(self.coordination_channel)\n\n        async for message in pubsub.listen():\n            if message[\"type\"] == \"message\":\n                try:\n                    data = json.loads(message[\"data\"])\n                    if data[\"instance_id\"] != self.instance_id:\n                        await self._handle_invalidation(data)\n                except Exception as e:\n                    logger.error(f\"Invalidation handling error: {e}\")\n</code></pre>"},{"location":"architecture/caching/#best-practices","title":"Best Practices","text":""},{"location":"architecture/caching/#cache-design-principles","title":"Cache Design Principles","text":"<ol> <li>Appropriate TTL: Set TTL based on data volatility</li> <li>Consistent Keys: Use consistent cache key patterns</li> <li>Error Handling: Graceful degradation when cache fails</li> <li>Monitoring: Track cache hit rates and performance</li> <li>Size Management: Monitor memory usage and implement eviction policies</li> </ol>"},{"location":"architecture/caching/#performance-guidelines","title":"Performance Guidelines","text":"<ol> <li>Batch Operations: Use batch get/set operations when possible</li> <li>Connection Pooling: Reuse Redis connections efficiently</li> <li>Async Operations: Use async/await throughout the cache layer</li> <li>Cache Warming: Proactively cache frequently accessed data</li> <li>Compression: Compress large data objects before caching</li> </ol>"},{"location":"architecture/caching/#security-considerations","title":"Security Considerations","text":"<ol> <li>Access Control: Secure Redis access with authentication</li> <li>Network Security: Use secure connections for Redis</li> <li>Data Sanitization: Sanitize cache keys and values</li> <li>Isolation: Use separate Redis databases for different environments</li> </ol> <p>The comprehensive caching strategy provides optimal performance while maintaining data consistency and supporting the high-throughput requirements of the LOLStonks API Gateway.</p>"},{"location":"architecture/implementation-details/","title":"Implementation Details","text":"<p>This document describes the actual implementation of the LOLStonks API Gateway, showing the real code structure and libraries used.</p> <p>\ud83d\udca1 Important: This differs from the conceptual architecture documentation which shows best practices and potential implementations. This document reflects what is actually in the codebase.</p>"},{"location":"architecture/implementation-details/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Configuration System</li> <li>Rate Limiting</li> <li>Caching System</li> <li>Match Tracking</li> <li>HTTP Client</li> <li>Key Differences from Conceptual Docs</li> </ul>"},{"location":"architecture/implementation-details/#configuration-system","title":"Configuration System","text":""},{"location":"architecture/implementation-details/#implementation-pydantic-settings","title":"Implementation: Pydantic Settings","text":"<p>File: <code>app/config.py</code></p> <p>Library: <code>pydantic-settings</code></p> <pre><code>from pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    # Riot API Configuration\n    riot_api_key: str\n    riot_default_region: str = \"euw1\"\n    riot_request_timeout: int = 10\n\n    # Rate Limits\n    riot_rate_limit_per_second: int = 20\n    riot_rate_limit_per_2min: int = 100\n\n    # Redis Configuration\n    redis_host: str = \"redis\"\n    redis_port: int = 6379\n    redis_db: int = 0\n    redis_password: str = \"\"\n\n    # All 23 Cache TTL variables...\n    # See app/config.py for complete list\n\n    model_config = ConfigDict(\n        env_file=\".env\",\n        case_sensitive=False,\n        extra=\"ignore\",\n    )\n\n# Global instance\nsettings = Settings()\n</code></pre> <p>Features: - \u2705 Automatic <code>.env</code> file loading - \u2705 Type validation - \u2705 Case-insensitive environment variables - \u2705 Default values</p>"},{"location":"architecture/implementation-details/#rate-limiting","title":"Rate Limiting","text":""},{"location":"architecture/implementation-details/#implementation-aiolimiter-library","title":"Implementation: aiolimiter Library","text":"<p>File: <code>app/riot/rate_limiter.py</code></p> <p>Library: aiolimiter v1.1+</p> <pre><code>from aiolimiter import AsyncLimiter\nfrom app.config import settings\n\nclass RiotRateLimiter:\n    \"\"\"Token bucket rate limiter using aiolimiter.\"\"\"\n\n    def __init__(self):\n        # Short-term limit: 20 requests/second\n        self.limiter_1s = AsyncLimiter(\n            max_rate=settings.riot_rate_limit_per_second,\n            time_period=1,\n        )\n        # Long-term limit: 100 requests/2 minutes\n        self.limiter_2min = AsyncLimiter(\n            max_rate=settings.riot_rate_limit_per_2min,\n            time_period=120,\n        )\n\n    async def acquire(self):\n        \"\"\"Acquire tokens from both limiters.\"\"\"\n        async with self.limiter_1s:\n            async with self.limiter_2min:\n                pass  # Both limits satisfied\n\n# Global instance\nrate_limiter = RiotRateLimiter()\n</code></pre> <p>Why aiolimiter?: - \u2705 Production-tested token bucket implementation - \u2705 Async/await native - \u2705 No need for custom refill logic - \u2705 Thread-safe and efficient</p> <p>Dual-Layer Protection: - Layer 1: <code>limiter_1s</code> prevents bursts (20 req/s) - Layer 2: <code>limiter_2min</code> enforces long-term limit (100 req/2min) - Request proceeds only when BOTH limiters allow</p>"},{"location":"architecture/implementation-details/#caching-system","title":"Caching System","text":""},{"location":"architecture/implementation-details/#implementation-aiocache-library","title":"Implementation: aiocache Library","text":"<p>File: <code>app/cache/redis_cache.py</code></p> <p>Library: aiocache v0.12+</p> <pre><code>from aiocache import Cache\nfrom aiocache.serializers import JsonSerializer\nfrom app.config import settings\n\n# Simple global cache instance\ncache = Cache(\n    Cache.REDIS,\n    endpoint=settings.redis_host,\n    port=settings.redis_port,\n    db=settings.redis_db,\n    password=settings.redis_password if settings.redis_password else None,\n    serializer=JsonSerializer(),\n    namespace=\"lol\",  # Prefix for all keys\n)\n</code></pre> <p>Usage in Routers:</p> <pre><code># app/routers/summoner.py\nfrom app.cache.redis_cache import cache\n\n@router.get(\"/summoners/by-name/{summonerName}\")\nasync def get_summoner_by_name(summonerName: str, region: str):\n    cache_key = f\"summoner:{region}:{summonerName.lower()}\"\n\n    # Try cache first\n    cached = await cache.get(cache_key)\n    if cached:\n        return cached\n\n    # Cache miss - call Riot API\n    data = await riot_client.get(f\"/lol/summoner/v4/summoners/by-name/{summonerName}\", region)\n\n    # Store with TTL from config\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_summoner)\n\n    return data\n</code></pre> <p>Why aiocache?: - \u2705 Simple API (get/set/delete) - \u2705 Built-in JSON serialization - \u2705 Connection pooling handled automatically - \u2705 Multiple backend support (Redis, Memcached, Memory)</p> <p>Cache Key Pattern: <pre><code>lol:{resource}:{region}:{identifier}\n</code></pre></p> <p>Examples: - <code>lol:summoner:euw1:faker</code> - <code>lol:match:euw1:EUW1_123456789</code> - <code>lol:league:kr:challenger:RANKED_SOLO_5x5</code></p>"},{"location":"architecture/implementation-details/#match-tracking","title":"Match Tracking","text":""},{"location":"architecture/implementation-details/#implementation-redis-set-with-redis-py","title":"Implementation: Redis SET with redis-py","text":"<p>File: <code>app/cache/tracking.py</code></p> <p>Library: <code>redis.asyncio</code> (redis-py)</p> <pre><code>import redis.asyncio as redis\nfrom app.config import settings\n\nclass MatchTracker:\n    \"\"\"Track processed matches using Redis SET.\"\"\"\n\n    def __init__(self):\n        self.redis: redis.Redis | None = None\n\n    async def connect(self):\n        \"\"\"Establish Redis connection.\"\"\"\n        redis_url = f\"redis://{settings.redis_host}:{settings.redis_port}/{settings.redis_db}\"\n        if settings.redis_password:\n            redis_url = f\"redis://:{settings.redis_password}@{settings.redis_host}:{settings.redis_port}/{settings.redis_db}\"\n\n        self.redis = await redis.from_url(redis_url, decode_responses=True)\n\n    async def is_processed(self, region: str, match_id: str) -&gt; bool:\n        \"\"\"Check if match was processed.\"\"\"\n        key = f\"processed_matches:{region}\"\n        return bool(await self.redis.sismember(key, match_id))\n\n    async def mark_processed(self, region: str, match_id: str):\n        \"\"\"Mark match as processed.\"\"\"\n        key = f\"processed_matches:{region}\"\n        await self.redis.sadd(key, match_id)\n\n    async def get_processed_count(self, region: str) -&gt; int:\n        \"\"\"Get count of processed matches.\"\"\"\n        key = f\"processed_matches:{region}\"\n        return await self.redis.scard(key)\n\n# Global instance\ntracker = MatchTracker()\n</code></pre> <p>Why separate Redis client?: - \u2705 Needs SET operations (not available in aiocache) - \u2705 Requires NO TTL (permanent storage) - \u2705 Direct redis-py gives full control</p> <p>Storage Pattern: - Key: <code>processed_matches:{region}</code> - Type: Redis SET - Members: Match IDs (e.g., <code>EUW1_6720797037</code>) - TTL: None (permanent)</p>"},{"location":"architecture/implementation-details/#http-client","title":"HTTP Client","text":""},{"location":"architecture/implementation-details/#implementation-httpx-asyncclient","title":"Implementation: httpx AsyncClient","text":"<p>File: <code>app/riot/client.py</code></p> <p>Library: httpx v0.27+</p> <pre><code>import httpx\nfrom app.config import settings\nfrom app.riot.rate_limiter import rate_limiter\n\nclass RiotHttpClient:\n    \"\"\"HTTP client for Riot API with rate limiting.\"\"\"\n\n    def __init__(self):\n        self.api_key = settings.riot_api_key\n        self.timeout = settings.riot_request_timeout\n        self.client = httpx.AsyncClient(\n            timeout=self.timeout,\n            headers={\"X-Riot-Token\": self.api_key}\n        )\n\n    async def get(self, path: str, region: str, is_platform: bool = False):\n        \"\"\"Make GET request with rate limiting.\"\"\"\n        # Wait for rate limit tokens\n        await rate_limiter.acquire()\n\n        # Build URL\n        base_url = self._get_base_url(region, is_platform)\n        url = f\"{base_url}{path}\"\n\n        # Make request\n        response = await self.client.get(url)\n\n        # Handle 429 (rate limited by Riot)\n        if response.status_code == 429:\n            retry_after = int(response.headers.get(\"Retry-After\", 1))\n            await asyncio.sleep(retry_after)\n            return await self.get(path, region, is_platform)  # Retry\n\n        response.raise_for_status()\n        return response.json()\n\n    async def close(self):\n        \"\"\"Close HTTP client.\"\"\"\n        await self.client.aclose()\n\n# Global instance\nriot_client = RiotHttpClient()\n</code></pre> <p>Why httpx?: - \u2705 Async/await native - \u2705 HTTP/2 support - \u2705 Connection pooling - \u2705 Timeout handling - \u2705 Similar API to requests library</p>"},{"location":"architecture/implementation-details/#key-differences-from-conceptual-docs","title":"Key Differences from Conceptual Docs","text":""},{"location":"architecture/implementation-details/#whats-simplified","title":"What's Simplified","text":"Feature Conceptual Docs Actual Implementation Why Rate Limiter Custom token bucket with manual refill <code>aiolimiter.AsyncLimiter</code> Library handles complexity Redis Cache Custom class with batch operations <code>aiocache.Cache</code> instance Simple API sufficient Cache Decorator Custom decorator with metrics Direct get/set in routers Clear, explicit code Connection Pool Custom pool management Handled by libraries Libraries optimize this"},{"location":"architecture/implementation-details/#whats-not-implemented-yet","title":"What's NOT Implemented (Yet)","text":"<p>These features are described in conceptual docs but not implemented:</p> <ul> <li>\u274c Batch Operations: <code>batch_get()</code>, <code>batch_set()</code></li> <li>\u274c Cache Warming: Proactive pre-loading of popular data</li> <li>\u274c Cache Metrics: Hit rate tracking, performance stats</li> <li>\u274c Cache Invalidation: Smart invalidation beyond TTL</li> <li>\u274c Distributed Cache: Multi-instance coordination</li> <li>\u274c Adaptive Rate Limiting: Dynamic adjustment based on 429s</li> <li>\u274c Circuit Breaker: Fault tolerance pattern</li> <li>\u274c Prometheus Metrics: Metrics endpoint</li> </ul> <p>These represent future enhancements or best practices rather than current code.</p>"},{"location":"architecture/implementation-details/#whats-fully-implemented","title":"What's Fully Implemented","text":"<ul> <li>\u2705 Configuration System: Complete with 23 TTL variables</li> <li>\u2705 Dual-Layer Rate Limiting: Using aiolimiter</li> <li>\u2705 TTL Caching: Using aiocache</li> <li>\u2705 Match Tracking: Using Redis SET</li> <li>\u2705 HTTP Client: Using httpx with retry logic</li> <li>\u2705 All 34 Endpoints: Fully functional API routes</li> <li>\u2705 Pydantic Models: Input validation</li> <li>\u2705 OpenAPI Docs: Auto-generated Swagger UI</li> </ul>"},{"location":"architecture/implementation-details/#design-philosophy","title":"Design Philosophy","text":"<p>The implementation follows these principles:</p> <ol> <li>Use Libraries: Prefer battle-tested libraries over custom code</li> <li>Simple &gt; Complex: Start simple, add complexity when needed</li> <li>Explicit &gt; Implicit: Clear code over clever abstractions</li> <li>Async/Await: Full async stack for concurrency</li> <li>Type Safety: Pydantic for validation, type hints throughout</li> </ol>"},{"location":"architecture/implementation-details/#quick-code-reference","title":"Quick Code Reference","text":""},{"location":"architecture/implementation-details/#where-to-find-key-components","title":"Where to Find Key Components","text":"<pre><code>app/\n\u251c\u2500\u2500 config.py              # Settings (23 TTL variables)\n\u251c\u2500\u2500 main.py                # FastAPI app (34 endpoints)\n\u251c\u2500\u2500 cache/\n\u2502   \u251c\u2500\u2500 redis_cache.py     # aiocache instance\n\u2502   \u2514\u2500\u2500 tracking.py        # Match tracker (Redis SET)\n\u251c\u2500\u2500 riot/\n\u2502   \u251c\u2500\u2500 client.py          # httpx HTTP client\n\u2502   \u251c\u2500\u2500 rate_limiter.py    # aiolimiter rate limiter\n\u2502   \u2514\u2500\u2500 regions.py         # Region mapping\n\u251c\u2500\u2500 routers/               # 11 API routers\n\u2502   \u251c\u2500\u2500 account.py\n\u2502   \u251c\u2500\u2500 summoner.py\n\u2502   \u251c\u2500\u2500 match.py\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 models/                # 13 Pydantic model files\n    \u251c\u2500\u2500 common.py          # Enums (7 total)\n    \u251c\u2500\u2500 account.py\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"architecture/implementation-details/#testing-the-implementation","title":"Testing the Implementation","text":""},{"location":"architecture/implementation-details/#verify-rate-limiting","title":"Verify Rate Limiting","text":"<pre><code>import asyncio\nfrom app.riot.rate_limiter import rate_limiter\n\nasync def test_rate_limiter():\n    start = asyncio.get_event_loop().time()\n\n    # Try to make 25 requests (limit is 20/s)\n    for i in range(25):\n        await rate_limiter.acquire()\n        print(f\"Request {i+1}\")\n\n    elapsed = asyncio.get_event_loop().time() - start\n    print(f\"Elapsed: {elapsed:.2f}s\")\n    # Expected: ~1.25s (5 requests blocked for 1s)\n\nasyncio.run(test_rate_limiter())\n</code></pre>"},{"location":"architecture/implementation-details/#verify-caching","title":"Verify Caching","text":"<pre><code>from app.cache.redis_cache import cache\nfrom app.config import settings\n\nasync def test_cache():\n    key = \"test:key\"\n    value = {\"data\": \"test\"}\n\n    # Set\n    await cache.set(key, value, ttl=60)\n\n    # Get\n    cached = await cache.get(key)\n    assert cached == value\n\n    print(\"\u2705 Cache working!\")\n\nasyncio.run(test_cache())\n</code></pre>"},{"location":"architecture/implementation-details/#verify-match-tracking","title":"Verify Match Tracking","text":"<pre><code>from app.cache.tracking import tracker\n\nasync def test_tracking():\n    await tracker.connect()\n\n    match_id = \"EUW1_TEST_123\"\n    region = \"euw1\"\n\n    # Check not processed\n    assert not await tracker.is_processed(region, match_id)\n\n    # Mark processed\n    await tracker.mark_processed(region, match_id)\n\n    # Check processed\n    assert await tracker.is_processed(region, match_id)\n\n    print(\"\u2705 Tracking working!\")\n\nasyncio.run(test_tracking())\n</code></pre>"},{"location":"architecture/implementation-details/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/implementation-details/#measured-performance","title":"Measured Performance","text":"Operation Latency Notes Cache hit &lt;5ms aiocache + Redis Cache miss + API 50-200ms Depends on Riot API Rate limiter check &lt;1ms aiolimiter (in-memory) Match tracking check &lt;5ms Redis SISMEMBER Full request (cached) &lt;10ms Gateway overhead minimal"},{"location":"architecture/implementation-details/#concurrency","title":"Concurrency","text":"<ul> <li>\u2705 Async/await throughout entire stack</li> <li>\u2705 httpx connection pooling (default 100 connections)</li> <li>\u2705 Redis connection pooling (aiocache handles)</li> <li>\u2705 Rate limiter thread-safe (aiolimiter)</li> </ul> <p>Expected Throughput: 15-20 requests/second sustained (limited by Riot API rate limits, not gateway)</p>"},{"location":"architecture/implementation-details/#conclusion","title":"Conclusion","text":"<p>The actual implementation is simpler and more maintainable than the conceptual architecture:</p> <ul> <li>Fewer lines of code: ~2000 lines vs theoretical 5000+</li> <li>Fewer bugs: Battle-tested libraries vs custom code</li> <li>Easier onboarding: Standard libraries = better docs</li> <li>Production ready: Libraries handle edge cases</li> </ul> <p>The conceptual documentation shows what's possible and best practices. The implementation shows what's sufficient and practical for the current requirements.</p> <p>When to enhance: Add complexity (batch operations, metrics, etc.) when metrics show it's needed, not preemptively.</p> <p>Last Updated: 2025-10-29</p>"},{"location":"architecture/models/","title":"Data Models &amp; Validation","text":"<p>This section describes the comprehensive Pydantic V2 input validation system used throughout the LOLStonks API Gateway.</p>"},{"location":"architecture/models/#overview","title":"Overview","text":"<p>All API endpoints use Pydantic V2 models for input validation, providing:</p> <ul> <li>Type Safety: Automatic validation of input types and constraints</li> <li>Self-Documenting API: Automatic OpenAPI schema generation</li> <li>Reusability: Shared models reduce code duplication</li> <li>Extensibility: Easy to add new validation rules and constraints</li> <li>Better Error Handling: Detailed validation error messages</li> </ul>"},{"location":"architecture/models/#model-architecture","title":"Model Architecture","text":""},{"location":"architecture/models/#directory-structure","title":"Directory Structure","text":"<pre><code>app/models/\n\u251c\u2500\u2500 __init__.py          # Central exports and registry\n\u251c\u2500\u2500 common.py            # Base models, enums, and shared utilities\n\u251c\u2500\u2500 account.py           # ACCOUNT-V1 (Riot ID) models\n\u251c\u2500\u2500 summoner.py          # SUMMONER-V4 models\n\u251c\u2500\u2500 match.py             # MATCH-V5 models\n\u251c\u2500\u2500 league.py            # LEAGUE-V4 models\n\u251c\u2500\u2500 champion_mastery.py  # CHAMPION-MASTERY-V4 models\n\u251c\u2500\u2500 challenges.py        # CHALLENGES-V1 models\n\u251c\u2500\u2500 clash.py             # CLASH-V1 models\n\u251c\u2500\u2500 spectator.py         # SPECTATOR-V5 models\n\u251c\u2500\u2500 platform.py          # LOL-STATUS-V4 models\n\u2514\u2500\u2500 champion.py          # CHAMPION-V3 models\n</code></pre>"},{"location":"architecture/models/#core-components","title":"Core Components","text":""},{"location":"architecture/models/#regional-routing-models","title":"Regional Routing Models","text":""},{"location":"architecture/models/#platform-regions","title":"Platform Regions","text":"<p>Used for Account-V1 and Match-V5 APIs that require regional routing:</p> <pre><code>class PlatformRegion(str, Enum):\n    \"\"\"Regional routing for platform endpoints.\"\"\"\n    AMERICAS = \"americas\"\n    EUROPE = \"europe\"\n    ASIA = \"asia\"\n    SEA = \"sea\"\n</code></pre>"},{"location":"architecture/models/#game-regions","title":"Game Regions","text":"<p>Used for game-specific endpoints (summoner, league, etc.):</p> <pre><code>class GameRegion(str, Enum):\n    \"\"\"Game-specific regions.\"\"\"\n    # Europe\n    EUW1 = \"euw1\"     # Europe West\n    EUN1 = \"eun1\"     # Europe Nordic &amp; East\n    TR1 = \"tr1\"       # Turkey\n    RU = \"ru\"         # Russia\n\n    # Americas\n    NA1 = \"na1\"       # North America\n    BR1 = \"br1\"       # Brazil\n    LA1 = \"la1\"       # Latin America North\n    LA2 = \"la2\"       # Latin America South\n\n    # Asia\n    KR = \"kr\"         # Korea\n    JP1 = \"jp1\"       # Japan\n\n    # SEA/Oceania\n    OC1 = \"oc1\"       # Oceania\n    PH2 = \"ph2\"       # Philippines\n    SG2 = \"sg2\"       # Singapore\n    TH2 = \"th2\"       # Thailand\n    TW2 = \"tw2\"       # Taiwan\n    VN2 = \"vn2\"       # Vietnam\n</code></pre>"},{"location":"architecture/models/#base-query-models","title":"Base Query Models","text":""},{"location":"architecture/models/#region-query","title":"Region Query","text":"<p>Standard region parameter for game-specific endpoints:</p> <pre><code>class RegionQuery(BaseModel):\n    \"\"\"Standard region parameter for game-specific endpoints.\"\"\"\n    region: Annotated[GameRegion, Field(\n        default_factory=lambda: GameRegion(settings.riot_default_region),\n        description=\"Riot API game region\"\n    )]\n</code></pre>"},{"location":"architecture/models/#platform-region-query","title":"Platform Region Query","text":"<p>Regional routing for platform endpoints:</p> <pre><code>class PlatformRegionQuery(BaseModel):\n    \"\"\"Regional routing for platform endpoints (ACCOUNT, MATCH APIs).\"\"\"\n    region: Annotated[PlatformRegion, Field(\n        default=PlatformRegion.AMERICAS,\n        description=\"Riot API platform region\"\n    )]\n</code></pre>"},{"location":"architecture/models/#pagination-query","title":"Pagination Query","text":"<p>Standard pagination parameters for list endpoints:</p> <pre><code>class PaginationQuery(BaseModel):\n    \"\"\"Pagination parameters for list endpoints.\"\"\"\n    start: Annotated[int, Field(\n        default=0,\n        ge=0,\n        description=\"Start index for pagination\"\n    )]\n    count: Annotated[int, Field(\n        default=20,\n        ge=1,\n        le=100,\n        description=\"Number of items to return (1-100)\"\n    )]\n</code></pre>"},{"location":"architecture/models/#specialized-enums","title":"Specialized Enums","text":""},{"location":"architecture/models/#queue-types","title":"Queue Types","text":"<p>Ranked queue identifiers:</p> <pre><code>class QueueType(str, Enum):\n    \"\"\"Ranked queue types.\"\"\"\n    RANKED_SOLO_5x5 = \"RANKED_SOLO_5x5\"\n    RANKED_FLEX_SR = \"RANKED_FLEX_SR\"\n    RANKED_FLEX_TT = \"RANKED_FLEX_TT\"\n</code></pre>"},{"location":"architecture/models/#challenge-levels","title":"Challenge Levels","text":"<p>Challenge tier levels:</p> <pre><code>class ChallengeLevel(str, Enum):\n    \"\"\"Challenge tier levels.\"\"\"\n    MASTER = \"MASTER\"\n    GRANDMASTER = \"GRANDMASTER\"\n    CHALLENGER = \"CHALLENGER\"\n</code></pre>"},{"location":"architecture/models/#usage-patterns","title":"Usage Patterns","text":""},{"location":"architecture/models/#router-implementation","title":"Router Implementation","text":"<p>Endpoints use FastAPI's dependency injection system with Pydantic models:</p> <pre><code>from typing import Annotated\nfrom fastapi import APIRouter, Depends\nfrom app.models.match import MatchIdsByPuuidParams, MatchIdsByPuuidQuery\n\nrouter = APIRouter()\n\n@router.get(\"/matches/by-puuid/{puuid}/ids\")\nasync def get_match_ids_by_puuid(\n    params: Annotated[MatchIdsByPuuidParams, Depends()],\n    query: Annotated[MatchIdsByPuuidQuery, Depends()],\n):\n    # Access validated parameters\n    puuid = params.puuid\n    region = query.region\n    start = query.start\n    count = query.count\n\n    # Optional filtering parameters\n    if query.startTime:\n        # Filter by start time\n        pass\n</code></pre>"},{"location":"architecture/models/#model-naming-conventions","title":"Model Naming Conventions","text":"<p>Models follow consistent naming patterns:</p> <ul> <li>Path Parameters: <code>{EndpointName}Params</code></li> <li> <p>Examples: <code>MatchIdsByPuuidParams</code>, <code>AccountByPuuidParams</code></p> </li> <li> <p>Query Parameters: <code>{EndpointName}Query</code></p> </li> <li>Examples: <code>MatchIdsByPuuidQuery</code>, <code>AccountByPuuidQuery</code></li> </ul>"},{"location":"architecture/models/#api-specific-examples","title":"API-Specific Examples","text":""},{"location":"architecture/models/#match-v5-models","title":"Match V5 Models","text":"<p>Enhanced query parameters for match history:</p> <pre><code>class MatchIdsByPuuidQuery(PlatformRegionQuery, PaginationQuery):\n    \"\"\"Match history query parameters with comprehensive filtering.\"\"\"\n    startTime: Annotated[Optional[int], Field(\n        default=None,\n        description=\"Filter matches after this timestamp (epoch milliseconds)\"\n    )]\n    endTime: Annotated[Optional[int], Field(\n        default=None,\n        description=\"Filter matches before this timestamp (epoch milliseconds)\"\n    )]\n    queue: Annotated[Optional[int], Field(\n        default=None,\n        description=\"Filter by queue ID (420 for Ranked Solo)\"\n    )]\n    type: Annotated[Optional[str], Field(\n        default=None,\n        description=\"Match type: ranked, normal, tourney, tutorial\"\n    )]\n</code></pre> <p>Example Usage: <pre><code>GET /lol/match/v5/matches/by-puuid/{puuid}/ids?region=europe&amp;start=0&amp;count=20&amp;startTime=1640000000&amp;queue=420&amp;type=ranked\n</code></pre></p>"},{"location":"architecture/models/#account-v1-models","title":"Account V1 Models","text":"<p>Riot ID validation with proper constraints:</p> <pre><code>class AccountByRiotIdParams(BaseModel):\n    \"\"\"Riot ID components with validation.\"\"\"\n    gameName: Annotated[str, Field(\n        min_length=1,\n        max_length=100,\n        description=\"Summoner name (1-100 characters)\"\n    )]\n    tagLine: Annotated[str, Field(\n        min_length=1,\n        max_length=100,\n        description=\"Tag line (1-100 characters)\"\n    )]\n</code></pre>"},{"location":"architecture/models/#league-v4-models","title":"League V4 Models","text":"<p>Enum-based queue validation:</p> <pre><code>class LeagueByQueueParams(BaseModel):\n    \"\"\"League parameters with queue type validation.\"\"\"\n    queue: Annotated[QueueType, Field(\n        description=\"Ranked queue type\"\n    )]\n</code></pre>"},{"location":"architecture/models/#validation-features","title":"Validation Features","text":""},{"location":"architecture/models/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"architecture/models/#string-length-validation","title":"String Length Validation","text":"<pre><code>puuid: Annotated[str, Field(\n    min_length=1,\n    max_length=100,\n    description=\"Player UUID (1-100 characters)\"\n)]\n</code></pre>"},{"location":"architecture/models/#numeric-range-validation","title":"Numeric Range Validation","text":"<pre><code>count: Annotated[int, Field(\n    ge=1,\n    le=100,\n    description=\"Number of items (1-100)\"\n)]\n</code></pre>"},{"location":"architecture/models/#pattern-matching","title":"Pattern Matching","text":"<pre><code>matchId: Annotated[str, Field(\n    pattern=r\"^[A-Z0-9]+_\\d+$\",\n    description=\"Match ID format: TRAILING_NUMBER\"\n)]\n</code></pre>"},{"location":"architecture/models/#enum-validation","title":"Enum Validation","text":"<pre><code>queue: Annotated[QueueType, Field(\n    description=\"Queue type for ranked play\"\n)]\n</code></pre>"},{"location":"architecture/models/#migration-status","title":"Migration Status","text":""},{"location":"architecture/models/#completed-migrations","title":"\u2705 Completed Migrations","text":"<ul> <li>Account-V1: All endpoints migrated to PlatformRegionQuery</li> <li>Match-V5: All endpoints migrated with enhanced filtering parameters</li> </ul>"},{"location":"architecture/models/#pending-migrations","title":"\ud83d\udd04 Pending Migrations","text":"<p>The following endpoints are scheduled for migration to Pydantic models:</p> <ul> <li>SUMMONER-V4 (summonerByName, summonerByPuuid, etc.)</li> <li>LEAGUE-V4 (challengerByQueue, grandmasterByQueue, etc.)</li> <li>CHAMPION-MASTERY-V4 (all mastery endpoints)</li> <li>CHALLENGES-V1 (player challenges)</li> <li>CLASH-V1 (tournament information)</li> <li>SPECTATOR-V5 (live game data)</li> <li>LOL-STATUS-V4 (platform status)</li> <li>CHAMPION-V3 (champion information)</li> </ul>"},{"location":"architecture/models/#benefits","title":"Benefits","text":""},{"location":"architecture/models/#1-type-safety-validation","title":"1. Type Safety &amp; Validation","text":"<pre><code># Before: No validation\nasync def get_summoner(name: str, region: str = \"euw1\"):\n    pass  # Any string accepted, no validation\n\n# After: Comprehensive validation\nasync def get_summoner(\n    params: Annotated[SummonerByNameParams, Depends()],\n    query: Annotated[RegionQuery, Depends()],\n):\n    pass  # Validated summoner name and region\n</code></pre>"},{"location":"architecture/models/#2-automatic-openapi-documentation","title":"2. Automatic OpenAPI Documentation","text":"<p>FastAPI generates detailed API documentation from Pydantic models: - Field types and constraints - Default values and descriptions - Enum values and meanings - Validation rules and error messages</p>"},{"location":"architecture/models/#3-code-reusability","title":"3. Code Reusability","text":"<pre><code># Region query used across multiple endpoints\nclass SummonerByNameQuery(RegionQuery):\n    pass\n\nclass SummonerByPuuidQuery(RegionQuery):\n    pass\n\n# Both inherit region validation automatically\n</code></pre>"},{"location":"architecture/models/#4-easy-extension","title":"4. Easy Extension","text":"<pre><code># Add new optional parameter without breaking changes\nclass MatchIdsByPuuidQuery(PlatformRegionQuery, PaginationQuery):\n    # Future extensions\n    champion: Annotated[Optional[int], Field(\n        default=None,\n        description=\"Filter by champion ID\"\n    )]\n    role: Annotated[Optional[str], Field(\n        default=None,\n        description=\"Filter by role\"\n    )]\n</code></pre>"},{"location":"architecture/models/#error-handling","title":"Error Handling","text":"<p>Pydantic provides detailed validation errors:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"loc\": [\"query\", \"count\"],\n      \"msg\": \"ensure this value is less than or equal to 100\",\n      \"type\": \"value_error.number.not_le\",\n      \"ctx\": {\"limit_value\": 100}\n    }\n  ]\n}\n</code></pre> <p>This validation system ensures API reliability, developer productivity, and excellent user experience through clear error messages and comprehensive API documentation.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>This section provides a comprehensive overview of the LOLStonks API Gateway architecture, its components, and design principles.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":""},{"location":"architecture/overview/#simplified-request-flow","title":"Simplified Request Flow","text":"<pre><code>flowchart LR\n    Client --&gt;|HTTP Request| Gateway[FastAPI Gateway]\n    Gateway --&gt;|Rate Limit Check| RateLimiter[Rate Limiter]\n    RateLimiter --&gt;|Cache Lookup| Redis[Redis Cache]\n    Redis --&gt;|Cache Miss| Gateway\n    Redis --&gt;|Cache Hit| Gateway\n    Gateway --&gt;|API Request| Riot[Riot API]\n    Riot --&gt;|Response| Gateway\n    Gateway --&gt;|Store Processed Data| Redis\n\n    Gateway -.-&gt;|Rate Limit Exceeded| Client\n    Gateway -.-&gt;|Error Response| Client\n</code></pre>"},{"location":"architecture/overview/#detailed-system-architecture","title":"Detailed System Architecture","text":"<pre><code>graph TB\n    Client[Client Applications] --&gt; Gateway[LOLStonks API Gateway]\n    Gateway --&gt; RateLimiter[Rate Limiter]\n    Gateway --&gt; Cache[Redis Cache]\n    Gateway --&gt; RiotAPI[Riot Games API]\n\n    subgraph \"Gateway Components\"\n        Gateway --&gt; FastAPI[FastAPI Application]\n        Gateway --&gt; Routers[API Routers]\n        Gateway --&gt; RiotClient[Riot Client]\n        Gateway --&gt; MatchTracking[Match Tracking]\n        Gateway --&gt; ErrorHandler[Error Handler]\n    end\n\n    subgraph \"External Services\"\n        Redis[(Redis Server)]\n        Riot[Riot Developer Portal]\n    end\n\n    Cache --&gt; Redis\n    MatchTracking --&gt; Redis\n    RiotClient --&gt; Riot\n    ErrorHandler -.-&gt; Client\n    RateLimiter -.-&gt; Client\n</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#1-fastapi-application-appmain","title":"1. FastAPI Application (<code>app.main</code>)","text":"<p>The main entry point that provides: - Async HTTP server with automatic documentation - Request routing to appropriate API endpoints - Middleware for request processing and error handling - OpenAPI specification generation</p> <p>Key Features: - Automatic request/response validation - Interactive API documentation (Swagger UI, ReDoc) - High performance async request handling - Built-in support for CORS, middleware, and dependency injection</p>"},{"location":"architecture/overview/#2-riot-client-appriotclient","title":"2. Riot Client (<code>app.riot.client</code>)","text":"<p>Specialized HTTP client for Riot API communication:</p> <pre><code>class RiotClient:\n    \"\"\"\n    HTTP client for Riot API with rate limiting and retry logic.\n\n    Features:\n    - Automatic rate limiting before requests\n    - Retry on 429 responses with exponential backoff\n    - Region-aware URL routing\n    - Authentication header management\n    \"\"\"\n</code></pre> <p>Responsibilities: - Rate Limiting: Token bucket algorithm for request throttling - Retry Logic: Automatic retry with <code>Retry-After</code> header handling - Region Management: Dynamic URL construction per region - Authentication: Automatic API key injection</p>"},{"location":"architecture/overview/#3-rate-limiter-appriotrate_limiter","title":"3. Rate Limiter (<code>app.riot.rate_limiter</code>)","text":"<p>Implements sophisticated rate limiting using the token bucket algorithm:</p> <pre><code>class RateLimiter:\n    \"\"\"\n    Token bucket rate limiter for Riot API compliance.\n\n    - Configurable requests per second (RPS)\n    - Burst capacity handling\n    - Automatic token refill\n    \"\"\"\n</code></pre> <p>Algorithm: - Tokens: Available request capacity - Refill Rate: Tokens added per second - Burst Capacity: Maximum token accumulation - Wait Strategy: Queue requests when tokens exhausted</p>"},{"location":"architecture/overview/#4-redis-cache-appcacheredis_cache","title":"4. Redis Cache (<code>app.cache.redis_cache</code>)","text":"<p>High-performance caching layer:</p> <pre><code>class RedisCache:\n    \"\"\"\n    Redis-based caching with TTL support.\n\n    - Automatic TTL management\n    - Connection pooling\n    - Error handling and fallbacks\n    \"\"\"\n</code></pre> <p>Cache Strategy: - TTL-based Expiration: Different TTLs per data type - Intelligent Key Generation: Consistent cache key patterns - Connection Pooling: Efficient Redis connection management - Graceful Degradation: Continue operation when cache unavailable</p>"},{"location":"architecture/overview/#5-match-tracking-appcachetracking","title":"5. Match Tracking (<code>app.cache.tracking</code>)","text":"<p>Prevents duplicate match processing:</p> <pre><code>class MatchTracker:\n    \"\"\"\n    Match tracking service to prevent duplicate processing.\n\n    - TTL cache for recent matches\n    - Persistent set for all processed matches\n    - Automatic cleanup of expired entries\n    \"\"\"\n</code></pre> <p>Dual Storage Approach: - TTL Cache: Fast lookup for recent matches (1 week) - Persistent Set: Complete record of all processed matches - Automatic Cleanup: Removal of expired TTL entries</p>"},{"location":"architecture/overview/#api-router-architecture","title":"API Router Architecture","text":""},{"location":"architecture/overview/#router-organization","title":"Router Organization","text":"<pre><code>graph LR\n    Gateway --&gt; Routers\n    Routers --&gt; Summoner[Summoner Router]\n    Routers --&gt; Match[Match Router]\n    Routers --&gt; League[League Router]\n    Routers --&gt; Mastery[Champion Mastery Router]\n    Routers --&gt; Spectator[Spectator Router]\n    Routers --&gt; Account[Account Router]\n    Routers --&gt; Champion[Champion Router]\n    Routers --&gt; Clash[Clash Router]\n    Routers --&gt; Challenges[Challenges Router]\n    Routers --&gt; Platform[Platform Router]\n</code></pre>"},{"location":"architecture/overview/#router-responsibilities","title":"Router Responsibilities","text":"<p>Each router handles: - Path Parameter Validation: Pydantic models for route parameters - Query Parameter Handling: Optional parameters and defaults - Response Transformation: Standardized response format - Error Handling: Consistent error responses - Caching Integration: Automatic cache integration per endpoint</p>"},{"location":"architecture/overview/#example-router-structure","title":"Example Router Structure","text":"<pre><code># app/routers/summoner.py\nrouter = APIRouter(prefix=\"/summoner\", tags=[\"summoner\"])\n\n@router.get(\"/by-name/{summonerName}\")\nasync def get_summoner_by_name(\n    summonerName: str,\n    region: str = Query(default=\"euw1\"),\n    riot_client: RiotClient = Depends(),\n    cache: RedisCache = Depends()\n) -&gt; SummonerDto:\n    \"\"\"Get summoner by summoner name.\"\"\"\n    # Implementation with caching and error handling\n</code></pre>"},{"location":"architecture/overview/#data-flow-architecture","title":"Data Flow Architecture","text":""},{"location":"architecture/overview/#request-processing-flow","title":"Request Processing Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant G as Gateway\n    participant RL as Rate Limiter\n    participant Cache as Redis Cache\n    participant RC as Riot Client\n    participant R as Riot API\n\n    C-&gt;&gt;G: HTTP Request\n    G-&gt;&gt;RL: Check Rate Limit\n    alt Rate Limit Exceeded\n        RL--&gt;&gt;C: 429 Too Many Requests\n    else Rate Limit OK\n        RL--&gt;&gt;G: Rate Limit Approved\n        G-&gt;&gt;Cache: Check Cache\n        alt Cache Hit\n            Cache--&gt;&gt;G: Cached Response\n            G--&gt;&gt;C: HTTP Response\n        else Cache Miss\n            G-&gt;&gt;RC: Make API Request\n            RC-&gt;&gt;R: Riot API Call\n            alt API Success\n                R--&gt;&gt;RC: API Response\n                RC--&gt;&gt;G: Process Response\n                G-&gt;&gt;Cache: Store in Cache\n                G--&gt;&gt;C: HTTP Response\n            else API Error\n                R--&gt;&gt;RC: Error Response\n                RC--&gt;&gt;G: Process Error\n                G--&gt;&gt;C: Error Response\n            end\n        end\n    end\n</code></pre>"},{"location":"architecture/overview/#caching-strategy","title":"Caching Strategy","text":"<p>Cache Key Pattern: <pre><code>lolstonks:{endpoint}:{region}:{identifier}\n</code></pre></p> <p>TTL Configuration: - Summoner Data: 1 hour (relatively stable) - Match Data: 24 hours (historical data) - League Data: 30 minutes (competitive data) - Champion Data: 1 week (static data)</p>"},{"location":"architecture/overview/#error-handling-flow","title":"Error Handling Flow","text":"<pre><code>graph TD\n    Request[Incoming Request] --&gt; Validation[Request Validation]\n    Validation --&gt; ValidationError{Validation Valid?}\n\n    ValidationError --&gt;|No| ValidationResponse[Return 400 Bad Request]\n    ValidationError --&gt;|Yes| RateCheck[Rate Limit Check]\n\n    RateCheck --&gt; RateError{Rate Limited?}\n    RateError --&gt;|Yes| RateResponse[Return 429 Too Many Requests]\n    RateError --&gt;|No| CacheCheck[Cache Check]\n\n    CacheCheck --&gt; CacheError{Cache Available?}\n    CacheError --&gt;|No| CacheFail[Continue to API]\n    CacheError --&gt;|Yes| CacheHit{Cache Hit?}\n\n    CacheHit --&gt;|Yes| CachedResponse[Return Cached Data]\n    CacheHit --&gt;|No| APIRequest[Make Riot API Request]\n\n    APIRequest --&gt; APIError{API Success?}\n    APIError --&gt;|Yes| StoreCache[Store in Cache]\n    APIError --&gt;|No| ErrorType{Error Type?}\n\n    ErrorType --&gt;|429| RetryWithBackoff[Retry with Exponential Backoff]\n    ErrorType --&gt;|404| NotFound[Return 404]\n    ErrorType --&gt;|Timeout| TimeoutError[Return 408 Request Timeout]\n    ErrorType --&gt;|Other| ServerError[Return 500]\n\n    RetryWithBackoff --&gt; APIError\n    StoreCache --&gt; SuccessResponse[Return Success Response]\n    ValidationResponse --&gt; ErrorResponse[Return Error Response]\n    RateResponse --&gt; ErrorResponse\n    NotFound --&gt; ErrorResponse\n    TimeoutError --&gt; ErrorResponse\n    ServerError --&gt; ErrorResponse\n</code></pre>"},{"location":"architecture/overview/#configuration-architecture","title":"Configuration Architecture","text":""},{"location":"architecture/overview/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<ol> <li>Environment Variables: Primary configuration source</li> <li><code>.env</code> File: Local development configuration</li> <li>Defaults: Built-in fallback values</li> <li>Runtime: Dynamic configuration updates</li> </ol>"},{"location":"architecture/overview/#configuration-management","title":"Configuration Management","text":"<pre><code># app/config.py\nclass Settings(BaseSettings):\n    \"\"\"Configuration settings with environment variable support.\"\"\"\n\n    # Riot API Configuration\n    riot_api_key: str\n    riot_default_region: str = \"euw1\"\n\n    # Server Configuration\n    host: str = \"0.0.0.0\"\n    port: int = 8080\n    log_level: str = \"INFO\"\n\n    # Redis Configuration\n    redis_host: str = \"localhost\"\n    redis_port: int = 6379\n\n    class Config:\n        env_file = \".env\"\n        case_sensitive = False\n</code></pre>"},{"location":"architecture/overview/#performance-architecture","title":"Performance Architecture","text":""},{"location":"architecture/overview/#performance-optimizations","title":"Performance Optimizations","text":"<ol> <li>Async Processing: Non-blocking I/O throughout the stack</li> <li>Connection Pooling: Efficient database and HTTP connections</li> <li>Intelligent Caching: Multi-layer caching strategy</li> <li>Rate Limiting: Protects against API abuse and ensures compliance</li> <li>Batch Operations: Support for concurrent requests</li> </ol>"},{"location":"architecture/overview/#scalability-considerations","title":"Scalability Considerations","text":"<ul> <li>Horizontal Scaling: Stateless design allows multiple instances</li> <li>Redis Cluster: Support for distributed caching</li> <li>Load Balancing: Compatible with standard load balancers</li> <li>Monitoring: Built-in health checks and metrics</li> </ul>"},{"location":"architecture/overview/#security-architecture","title":"Security Architecture","text":""},{"location":"architecture/overview/#security-layers","title":"Security Layers","text":"<ol> <li>API Key Management: Secure storage and rotation of Riot API keys</li> <li>Input Validation: Comprehensive request validation using Pydantic</li> <li>Rate Limiting: Protection against abuse and DoS attacks</li> <li>Error Sanitization: Prevents information leakage in error messages</li> <li>CORS Configuration: Configurable cross-origin resource sharing</li> </ol>"},{"location":"architecture/overview/#best-practices","title":"Best Practices","text":"<ul> <li>Principle of Least Privilege: Minimal required permissions</li> <li>Defense in Depth: Multiple security layers</li> <li>Secure Defaults: Secure configuration out of the box</li> <li>Audit Logging: Comprehensive request and error logging</li> </ul>"},{"location":"architecture/overview/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"architecture/overview/#health-checks","title":"Health Checks","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Comprehensive health check endpoint.\"\"\"\n    return {\n        \"status\": \"ok\",\n        \"timestamp\": datetime.utcnow(),\n        \"version\": \"1.0.0\",\n        \"dependencies\": {\n            \"redis\": await check_redis_health(),\n            \"riot_api\": await check_riot_api_health()\n        }\n    }\n</code></pre>"},{"location":"architecture/overview/#logging-strategy","title":"Logging Strategy","text":"<ul> <li>Structured Logging: JSON-formatted logs for easy parsing</li> <li>Request Tracking: Unique request IDs for tracing</li> <li>Performance Metrics: Request timing and cache hit rates</li> <li>Error Tracking: Comprehensive error logging and alerting</li> </ul>"},{"location":"architecture/overview/#future-architecture-considerations","title":"Future Architecture Considerations","text":""},{"location":"architecture/overview/#planned-enhancements","title":"Planned Enhancements","text":"<ol> <li>Metrics Collection: Prometheus metrics integration</li> <li>Distributed Tracing: OpenTelemetry support</li> <li>API Versioning: Versioned API endpoints</li> <li>Webhook Support: Real-time event notifications</li> <li>Admin Interface: Management dashboard for operations</li> </ol>"},{"location":"architecture/overview/#scalability-roadmap","title":"Scalability Roadmap","text":"<ul> <li>Multi-Region Deployment: Geographic distribution</li> <li>Circuit Breakers: Fault tolerance for external dependencies</li> <li>Event Streaming: Kafka/Redis Streams for real-time data</li> <li>GraphQL Support: Alternative API interface</li> </ul>"},{"location":"architecture/overview/#design-principles","title":"Design Principles","text":"<p>The LOLStonks API Gateway follows these design principles:</p> <ol> <li>Performance First: Optimized for high throughput and low latency</li> <li>Developer Experience: Clear APIs and comprehensive documentation</li> <li>Reliability: Graceful degradation and error handling</li> <li>Observability: Built-in monitoring and debugging capabilities</li> <li>Security: Secure by design with defense in depth</li> <li>Scalability: Designed to scale horizontally and vertically</li> </ol>"},{"location":"architecture/overview/#production-deployment","title":"Production Deployment","text":""},{"location":"architecture/overview/#deployment-architecture","title":"Deployment Architecture","text":"<p>For production deployments, the API Gateway should be run behind a reverse proxy with proper process management:</p> <pre><code>graph TB\n    Internet[Internet] --&gt; LB[Load Balancer/Nginx]\n    LB --&gt; Gateway1[API Gateway Instance 1]\n    LB --&gt; Gateway2[API Gateway Instance 2]\n    LB --&gt; GatewayN[API Gateway Instance N]\n\n    Gateway1 --&gt; Redis[Redis Cluster]\n    Gateway2 --&gt; Redis\n    GatewayN --&gt; Redis\n\n    Gateway1 --&gt; Riot[Riot API]\n    Gateway2 --&gt; Riot\n    GatewayN --&gt; Riot\n\n    subgraph \"Monitoring\"\n        Prometheus[Prometheus]\n        Grafana[Grafana]\n        Alerts[Alert Manager]\n    end\n\n    Gateway1 --&gt; Prometheus\n    Gateway2 --&gt; Prometheus\n    GatewayN --&gt; Prometheus\n    Prometheus --&gt; Grafana\n    Prometheus --&gt; Alerts\n</code></pre>"},{"location":"architecture/overview/#production-requirements","title":"Production Requirements","text":"<ol> <li>Process Management: Use systemd, supervisor, or similar process manager</li> <li>Reverse Proxy: Nginx or similar for SSL termination and load balancing</li> <li>Environment Variables: Secure configuration management for API keys</li> <li>Monitoring: Health checks, metrics collection, and alerting</li> <li>Logging: Centralized log aggregation and analysis</li> <li>Security: Firewall, rate limiting, and access controls</li> </ol>"},{"location":"architecture/overview/#scaling-considerations","title":"Scaling Considerations","text":"<ul> <li>Horizontal Scaling: Stateless design enables multiple instances</li> <li>Redis Cluster: Distributed caching for high availability</li> <li>Database Connection Pooling: Efficient resource utilization</li> <li>Circuit Breakers: Fault tolerance for external dependencies</li> </ul> <p>This architecture provides a solid foundation for a production-ready API Gateway that can handle high traffic while maintaining reliability and performance.</p>"},{"location":"architecture/rate-limiting/","title":"Rate Limiting Architecture","text":"<p>This section details the rate limiting implementation in the LOLStonks API Gateway, designed to ensure compliance with Riot Games API rate limits while providing optimal performance.</p> <p>\ud83d\udcdd Documentation Note: This document describes the conceptual architecture and best practices for rate limiting. The actual implementation uses the aiolimiter library, which provides a production-ready token bucket algorithm. Some code examples below are simplified for educational purposes.</p>"},{"location":"architecture/rate-limiting/#overview","title":"Overview","text":"<p>The rate limiting system uses a token bucket algorithm to control the flow of requests to the Riot Games API, preventing rate limit violations and ensuring fair usage.</p>"},{"location":"architecture/rate-limiting/#token-bucket-algorithm","title":"Token Bucket Algorithm","text":""},{"location":"architecture/rate-limiting/#algorithm-description","title":"Algorithm Description","text":"<p>The token bucket algorithm works as follows:</p> <ol> <li>Bucket Capacity: Maximum number of tokens that can be stored</li> <li>Refill Rate: Number of tokens added per second</li> <li>Token Consumption: Each request consumes one token</li> <li>Wait Strategy: Requests wait when tokens are unavailable</li> </ol> <pre><code>graph TD\n    Bucket[Token Bucket] --&gt; Refill[Refill: 20 tokens/sec]\n    Bucket --&gt; Capacity[Max Capacity: 100 tokens]\n\n    Request1[Request 1] --&gt; Consume1[Consume 1 token]\n    Request2[Request 2] --&gt; Consume2[Consume 1 token]\n    Request3[Request 3] --&gt; Consume3[Consume 1 token]\n\n    Consume1 --&gt; Available{Tokens Available?}\n    Consume2 --&gt; Available\n    Consume3 --&gt; Available\n\n    Available --&gt;|Yes| Process[Process Request]\n    Available --&gt;|No| Wait[Wait for Refill]\n\n    Wait --&gt; Available\n    Process --&gt; Bucket\n</code></pre>"},{"location":"architecture/rate-limiting/#implementation-details","title":"Implementation Details","text":"<p>\ud83d\udca1 Actual Implementation: The real code in <code>app/riot/rate_limiter.py</code> uses <code>aiolimiter.AsyncLimiter</code> for simplicity and reliability. The example below shows a conceptual implementation for educational purposes.</p> <pre><code># Conceptual implementation (not actual code)\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nclass RateLimiter:\n    \"\"\"\n    Token bucket rate limiter for Riot API compliance.\n\n    Default configuration:\n    - 20 requests per second\n    - 100 token burst capacity\n    - 120-second refill period for burst capacity\n    \"\"\"\n\n    def __init__(self, rate: float = 20.0, capacity: int = 100):\n        self.rate = rate  # tokens per second\n        self.capacity = capacity  # maximum tokens\n        self.tokens = capacity  # current tokens\n        self.last_refill = datetime.utcnow()\n        self._lock = asyncio.Lock()\n\n    async def acquire(self) -&gt; None:\n        \"\"\"Acquire a token, waiting if necessary.\"\"\"\n        async with self._lock:\n            await self._refill()\n            if self.tokens &gt;= 1:\n                self.tokens -= 1\n                return\n\n            # Calculate wait time for next token\n            wait_time = 1.0 / self.rate\n            await asyncio.sleep(wait_time)\n            await self._refill()\n            self.tokens -= 1\n\n    async def _refill(self) -&gt; None:\n        \"\"\"Refill tokens based on elapsed time.\"\"\"\n        now = datetime.utcnow()\n        elapsed = (now - self.last_refill).total_seconds()\n        tokens_to_add = elapsed * self.rate\n\n        self.tokens = min(self.capacity, self.tokens + tokens_to_add)\n        self.last_refill = now\n</code></pre>"},{"location":"architecture/rate-limiting/#configuration","title":"Configuration","text":""},{"location":"architecture/rate-limiting/#environment-variables","title":"Environment Variables","text":"<pre><code># Rate limiting configuration\nRATE_LIMIT_RPS=20           # Requests per second\nRATE_LIMIT_BURST=100        # Burst capacity\nRATE_LIMIT_PERIOD=120       # Period for burst refill (seconds)\n</code></pre>"},{"location":"architecture/rate-limiting/#custom-rate-limits","title":"Custom Rate Limits","text":"<p>You can configure different rate limits for different endpoint types:</p> <pre><code># Custom rate limits per endpoint type\nRATE_LIMITS = {\n    \"summoner\": {\"rps\": 30, \"burst\": 150},    # Higher limit for summoner data\n    \"match\": {\"rps\": 10, \"burst\": 50},        # Lower limit for match data\n    \"league\": {\"rps\": 20, \"burst\": 100},      # Standard limit for league data\n    \"spectator\": {\"rps\": 5, \"burst\": 25}      # Very low limit for spectator\n}\n</code></pre>"},{"location":"architecture/rate-limiting/#integration-with-http-client","title":"Integration with HTTP Client","text":""},{"location":"architecture/rate-limiting/#rate-limited-http-client","title":"Rate-Limited HTTP Client","text":"<pre><code># app/riot/client.py\nimport httpx\nfrom app.riot.rate_limiter import RateLimiter\n\nclass RiotClient:\n    \"\"\"\n    HTTP client for Riot API with integrated rate limiting.\n    \"\"\"\n\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.client = httpx.AsyncClient()\n        self.rate_limiter = RateLimiter(\n            rate=float(os.getenv(\"RATE_LIMIT_RPS\", 20)),\n            capacity=int(os.getenv(\"RATE_LIMIT_BURST\", 100))\n        )\n\n    async def get(self, path: str, region: str, **kwargs) -&gt; dict:\n        \"\"\"\n        Make GET request with automatic rate limiting and retry.\n        \"\"\"\n        await self.rate_limiter.acquire()\n\n        # Make request\n        response = await self.client.get(\n            self._build_url(path, region),\n            headers=self._get_headers(),\n            **kwargs\n        )\n\n        # Handle rate limiting from Riot API\n        if response.status_code == 429:\n            retry_after = int(response.headers.get(\"Retry-After\", 1))\n            await asyncio.sleep(retry_after)\n            return await self.get(path, region, **kwargs)  # Retry\n\n        response.raise_for_status()\n        return response.json()\n</code></pre>"},{"location":"architecture/rate-limiting/#rate-limit-response-handling","title":"Rate Limit Response Handling","text":""},{"location":"architecture/rate-limiting/#429-response-handling","title":"429 Response Handling","text":"<p>When Riot API returns a 429 (Too Many Requests) response:</p> <pre><code>async def _handle_rate_limit_response(self, response: httpx.Response) -&gt; dict:\n    \"\"\"\n    Handle 429 responses from Riot API.\n\n    Riot API provides:\n    - Retry-After header: Seconds to wait before retrying\n    - X-Rate-Limit-* headers: Current rate limit status\n    \"\"\"\n    if response.status_code != 429:\n        response.raise_for_status()\n        return response.json()\n\n    # Extract retry information\n    retry_after = int(response.headers.get(\"Retry-After\", 1))\n    app_rate_limit = response.headers.get(\"X-App-Rate-Limit\", \"\")\n    app_rate_count = response.headers.get(\"X-App-Rate-Limit-Count\", \"\")\n\n    # Log rate limit information\n    logger.warning(\n        f\"Rate limited. Retry after {retry_after}s. \"\n        f\"App limit: {app_rate_count}/{app_rate_limit}\"\n    )\n\n    # Wait for the specified time\n    await asyncio.sleep(retry_after)\n\n    # The request will be retried by the calling method\n    raise RateLimitExceeded(retry_after=retry_after)\n</code></pre>"},{"location":"architecture/rate-limiting/#rate-limit-headers-monitoring","title":"Rate Limit Headers Monitoring","text":"<pre><code>def _monitor_rate_limits(self, response: httpx.Response) -&gt; None:\n    \"\"\"\n    Monitor rate limit headers for proactive management.\n\n    Riot API headers:\n    - X-App-Rate-Limit: application limits (e.g., \"20:1,100:120\")\n    - X-App-Rate-Limit-Count: current usage (e.g., \"5:1,17:120\")\n    - X-Method-Rate-Limit: method-specific limits\n    - X-Method-Rate-Limit-Count: current method usage\n    \"\"\"\n    app_limit = response.headers.get(\"X-App-Rate-Limit\", \"\")\n    app_count = response.headers.get(\"X-App-Rate-Limit-Count\", \"\")\n\n    if app_limit and app_count:\n        # Parse rate limit information\n        limits = self._parse_rate_limit_header(app_limit)\n        counts = self._parse_rate_limit_header(app_count)\n\n        # Check if we're approaching limits\n        for (limit_period, limit_count), (_, current_count) in zip(limits, counts):\n            usage_percentage = (current_count / limit_count) * 100\n\n            if usage_percentage &gt; 80:\n                logger.warning(\n                    f\"Approaching rate limit: {current_count}/{limit_count} \"\n                    f\"({usage_percentage:.1f}%) for {limit_period}s period\"\n                )\n</code></pre>"},{"location":"architecture/rate-limiting/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/rate-limiting/#rate-limiter-performance","title":"Rate Limiter Performance","text":"<pre><code># Optimized rate limiter with minimal blocking\nclass HighPerformanceRateLimiter:\n    \"\"\"\n    High-performance rate limiter using async primitives.\n    \"\"\"\n\n    def __init__(self, rate: float, capacity: int):\n        self.rate = rate\n        self.capacity = capacity\n        self.tokens = capacity\n        self.last_refill = time.time()\n        self._lock = asyncio.Lock()\n        self._not_empty = asyncio.Condition(self._lock)\n\n    async def acquire(self) -&gt; None:\n        \"\"\"Acquire token with efficient waiting.\"\"\"\n        async with self._not_empty:\n            while self.tokens &lt; 1:\n                # Calculate wait time more precisely\n                now = time.time()\n                time_since_refill = now - self.last_refill\n                tokens_needed = 1 - self.tokens\n                wait_time = max(0, tokens_needed / self.rate - time_since_refill)\n\n                if wait_time &gt; 0:\n                    await asyncio.sleep(wait_time)\n                else:\n                    await self._refill()\n\n            self.tokens -= 1\n            self._not_empty.notify()\n</code></pre>"},{"location":"architecture/rate-limiting/#connection-pooling-with-rate-limiting","title":"Connection Pooling with Rate Limiting","text":"<pre><code># HTTP client configuration optimized for rate limiting\nclass OptimizedRiotClient:\n    def __init__(self, api_key: str):\n        self.client = httpx.AsyncClient(\n            limits=httpx.Limits(\n                max_keepalive_connections=20,\n                max_connections=100,\n                keepalive_expiry=30.0\n            ),\n            timeout=httpx.Timeout(30.0, connect=5.0)\n        )\n        self.rate_limiter = RateLimiter(rate=20, capacity=100)\n</code></pre>"},{"location":"architecture/rate-limiting/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"architecture/rate-limiting/#rate-limit-metrics","title":"Rate Limit Metrics","text":"<pre><code># Metrics collection for rate limiting\nclass RateLimitMetrics:\n    \"\"\"\n    Collect and report rate limiting metrics.\n    \"\"\"\n\n    def __init__(self):\n        self.requests_total = 0\n        self.requests_limited = 0\n        self.wait_time_total = 0.0\n        self.tokens_consumed = 0\n\n    def record_request(self, wait_time: float, was_limited: bool = False) -&gt; None:\n        \"\"\"Record a request with its wait time.\"\"\"\n        self.requests_total += 1\n        self.wait_time_total += wait_time\n        if was_limited:\n            self.requests_limited += 1\n        self.tokens_consumed += 1\n\n    def get_metrics(self) -&gt; dict:\n        \"\"\"Get current metrics.\"\"\"\n        return {\n            \"requests_total\": self.requests_total,\n            \"requests_limited\": self.requests_limited,\n            \"limit_rate\": self.requests_limited / self.requests_total * 100,\n            \"average_wait_time\": self.wait_time_total / self.requests_total,\n            \"tokens_consumed\": self.tokens_consumed\n        }\n</code></pre>"},{"location":"architecture/rate-limiting/#health-check-integration","title":"Health Check Integration","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check including rate limiting status.\"\"\"\n    rate_limiter_metrics = riot_client.rate_limiter.get_metrics()\n\n    return {\n        \"status\": \"ok\",\n        \"rate_limiting\": {\n            \"status\": \"healthy\",\n            \"current_tokens\": rate_limiter_metrics[\"current_tokens\"],\n            \"requests_per_second\": rate_limiter_metrics[\"current_rate\"],\n            \"limit_rate\": rate_limiter_metrics[\"limit_rate_percentage\"]\n        }\n    }\n</code></pre>"},{"location":"architecture/rate-limiting/#advanced-features","title":"Advanced Features","text":""},{"location":"architecture/rate-limiting/#adaptive-rate-limiting","title":"Adaptive Rate Limiting","text":"<pre><code>class AdaptiveRateLimiter(RateLimiter):\n    \"\"\"\n    Rate limiter that adapts based on Riot API responses.\n    \"\"\"\n\n    def __init__(self, initial_rate: float, initial_capacity: int):\n        super().__init__(initial_rate, initial_capacity)\n        self.adaptive_mode = True\n        self.consecutive_429s = 0\n        self.last_adjustment = time.time()\n\n    async def adapt_after_429(self, retry_after: int) -&gt; None:\n        \"\"\"Adjust rate limits after receiving 429 response.\"\"\"\n        self.consecutive_429s += 1\n\n        if self.consecutive_429s &gt;= 3:\n            # Reduce rate limit if we get multiple 429s\n            new_rate = max(1, self.rate * 0.8)\n            self.rate = new_rate\n            logger.warning(f\"Reduced rate limit to {new_rate} RPS due to 429s\")\n\n    async def adapt_success(self) -&gt; None:\n        \"\"\"Gradually increase rate limit on success.\"\"\"\n        if self.consecutive_429s == 0 and time.time() - self.last_adjustment &gt; 300:\n            # Gradually increase if no recent 429s\n            self.rate = min(30, self.rate * 1.1)\n            self.last_adjustment = time.time()\n</code></pre>"},{"location":"architecture/rate-limiting/#distributed-rate-limiting","title":"Distributed Rate Limiting","text":"<p>For multi-instance deployments:</p> <pre><code>class DistributedRateLimiter:\n    \"\"\"\n    Rate limiter using Redis for distributed coordination.\n    \"\"\"\n\n    def __init__(self, redis_client, rate: float, capacity: int):\n        self.redis = redis_client\n        self.rate = rate\n        self.capacity = capacity\n        self.key = \"rate_limiter:tokens\"\n\n    async def acquire(self) -&gt; None:\n        \"\"\"Acquire token using Redis-based rate limiting.\"\"\"\n        script = \"\"\"\n        local key = KEYS[1]\n        local capacity = tonumber(ARGV[1])\n        local tokens = tonumber(ARGV[2])\n        local interval = tonumber(ARGV[3])\n\n        local current = redis.call('GET', key)\n        if not current then\n            current = capacity\n        else\n            current = tonumber(current)\n        end\n\n        if current &gt;= 1 then\n            redis.call('SET', key, current - 1)\n            redis.call('EXPIRE', key, interval)\n            return 1\n        else\n            return 0\n        end\n        \"\"\"\n\n        result = await self.redis.eval(\n            script,\n            keys=[self.key],\n            args=[self.capacity, 1, self.capacity / self.rate]\n        )\n\n        if result == 0:\n            # No tokens available, wait\n            await asyncio.sleep(1.0 / self.rate)\n            await self.acquire()\n</code></pre>"},{"location":"architecture/rate-limiting/#best-practices","title":"Best Practices","text":""},{"location":"architecture/rate-limiting/#configuration-guidelines","title":"Configuration Guidelines","text":"<ol> <li>Conservative Rate Limits: Start with conservative limits and adjust based on usage</li> <li>Monitor Usage: Regularly monitor rate limit headers and adjust accordingly</li> <li>Graceful Degradation: Handle rate limit errors gracefully without failing completely</li> <li>Burst Capacity: Maintain adequate burst capacity for traffic spikes</li> </ol>"},{"location":"architecture/rate-limiting/#error-handling","title":"Error Handling","text":"<ol> <li>Exponential Backoff: Use exponential backoff for retries</li> <li>Circuit Breaker: Implement circuit breaker for repeated failures</li> <li>Logging: Comprehensive logging of rate limit events</li> <li>Alerting: Set up alerts for high rate limit usage</li> </ol>"},{"location":"architecture/rate-limiting/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Async Operations: Use async/await throughout the stack</li> <li>Connection Pooling: Reuse HTTP connections efficiently</li> <li>Batch Operations: Batch requests when possible</li> <li>Caching: Cache responses to reduce API calls</li> </ol> <p>The rate limiting system ensures reliable operation while respecting Riot Games API limits, providing a robust foundation for high-volume API access.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to LOLStonks API Gateway! This guide will help you get started with contributing to the project.</p>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to be respectful, inclusive, and constructive in all interactions. We expect contributors to:</p> <ul> <li>Be respectful of differing viewpoints and experiences</li> <li>Accept constructive criticism gracefully</li> <li>Focus on what is best for the community</li> <li>Show empathy towards other community members</li> </ul>"},{"location":"development/contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are many ways to contribute to this project:</p> <ul> <li>Report bugs: Submit detailed bug reports with reproduction steps</li> <li>Suggest features: Propose new features or enhancements</li> <li>Improve documentation: Fix typos, clarify instructions, or add examples</li> <li>Submit code: Fix bugs or implement new features</li> <li>Review pull requests: Help review and test other contributors' code</li> </ul>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#development-environment-setup","title":"Development Environment Setup","text":"<ol> <li>Fork and clone the repository:</li> </ol> <pre><code>git clone https://github.com/YOUR_USERNAME/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code># Using UV (recommended)\nuv pip install -e \".[dev,docs]\"\n\n# Or using pip\npip install -e \".[dev,docs]\"\n</code></pre> <ol> <li>Set up environment variables:</li> </ol> <pre><code>cp .env.example .env\n# Edit .env and add your Riot API key\n</code></pre> <ol> <li>Start Redis (required for development):</li> </ol> <pre><code># Using Docker\ndocker-compose up -d redis\n\n# Or install Redis locally\n</code></pre> <ol> <li>Run the development server:</li> </ol> <pre><code>python -m app.main\n</code></pre>"},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>lolstonks-api-gateway/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 main.py              # Application entry point\n\u2502   \u251c\u2500\u2500 config.py            # Configuration management\n\u2502   \u251c\u2500\u2500 routers/             # API endpoint routers\n\u2502   \u251c\u2500\u2500 riot/                # Riot API client and rate limiting\n\u2502   \u251c\u2500\u2500 cache/               # Caching and match tracking\n\u2502   \u2514\u2500\u2500 models/              # Data models\n\u251c\u2500\u2500 docs/                    # Documentation source\n\u251c\u2500\u2500 tests/                   # Test suite\n\u2514\u2500\u2500 scripts/                 # Utility scripts\n</code></pre>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<p>Create a feature branch from <code>main</code> or <code>develop</code>:</p> <pre><code>git checkout -b feat/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre> <p>Branch naming conventions: - <code>feat/</code> - New features - <code>fix/</code> - Bug fixes - <code>docs/</code> - Documentation changes - <code>refactor/</code> - Code refactoring - <code>test/</code> - Test additions or modifications - <code>chore/</code> - Maintenance tasks</p>"},{"location":"development/contributing/#2-make-your-changes","title":"2. Make Your Changes","text":"<ul> <li>Follow the existing code style and patterns</li> <li>Write clear, concise commit messages</li> <li>Keep changes focused and atomic</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> </ul>"},{"location":"development/contributing/#3-test-your-changes","title":"3. Test Your Changes","text":"<p>Before submitting, ensure your changes pass all checks:</p> <pre><code># Run tests (when available)\npytest\n\n# Run type checking (if configured)\nmypy app\n\n# Run linting (if configured)\nruff check app\n</code></pre>"},{"location":"development/contributing/#4-commit-your-changes","title":"4. Commit Your Changes","text":"<p>Write clear commit messages following this format:</p> <pre><code>git commit -m \"feat: add support for new Riot API endpoint\"\ngit commit -m \"fix: resolve rate limiting issue with burst requests\"\ngit commit -m \"docs: update installation instructions\"\n</code></pre> <p>Commit message format: - Use present tense (\"add feature\" not \"added feature\") - Use imperative mood (\"move cursor to...\" not \"moves cursor to...\") - Limit first line to 72 characters - Reference issues and pull requests when relevant</p>"},{"location":"development/contributing/#5-push-and-create-pull-request","title":"5. Push and Create Pull Request","text":"<pre><code>git push origin feat/your-feature-name\n</code></pre> <p>Then open a pull request on GitHub with:</p> <ul> <li>Clear title describing the change</li> <li>Detailed description of what changed and why</li> <li>Reference to any related issues</li> <li>Screenshots or examples if applicable</li> </ul>"},{"location":"development/contributing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<ul> <li>Follow PEP 8 guidelines</li> <li>Use type hints for function parameters and return values</li> <li>Write docstrings for all public functions and classes</li> <li>Keep functions focused and single-purpose</li> <li>Use meaningful variable and function names</li> </ul> <p>Example:</p> <pre><code>from typing import Optional\n\nasync def get_summoner_by_name(\n    summoner_name: str,\n    region: str = \"euw1\"\n) -&gt; Optional[dict]:\n    \"\"\"\n    Retrieve summoner information by name.\n\n    Args:\n        summoner_name: The summoner's in-game name\n        region: The game region (default: euw1)\n\n    Returns:\n        Summoner data dictionary or None if not found\n    \"\"\"\n    # Implementation here\n    pass\n</code></pre>"},{"location":"development/contributing/#documentation-style","title":"Documentation Style","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples for complex features</li> <li>Keep line length reasonable (80-100 characters)</li> <li>Use proper markdown formatting</li> <li>Avoid jargon and explain technical terms</li> </ul>"},{"location":"development/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"development/contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Write tests for all new functionality</li> <li>Ensure tests are isolated and reproducible</li> <li>Use descriptive test names</li> <li>Test both success and failure cases</li> <li>Mock external API calls</li> </ul> <p>Example test structure:</p> <pre><code>import pytest\nfrom app.riot.client import RiotClient\n\n@pytest.mark.asyncio\nasync def test_get_summoner_by_name_success():\n    \"\"\"Test successful summoner retrieval.\"\"\"\n    client = RiotClient(api_key=\"test-key\")\n    # Test implementation\n    pass\n\n@pytest.mark.asyncio\nasync def test_get_summoner_by_name_not_found():\n    \"\"\"Test summoner not found scenario.\"\"\"\n    # Test implementation\n    pass\n</code></pre>"},{"location":"development/contributing/#documentation-guidelines","title":"Documentation Guidelines","text":""},{"location":"development/contributing/#updating-documentation","title":"Updating Documentation","text":"<p>When making changes that affect documentation:</p> <ol> <li>Update relevant <code>.md</code> files in the <code>docs/</code> directory</li> <li>Test documentation locally:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <ol> <li>Ensure all links work correctly</li> <li>Add code examples for new features</li> <li>Update API reference if endpoints change</li> </ol>"},{"location":"development/contributing/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Getting Started: Installation and quick start guides</li> <li>API Reference: Endpoint documentation</li> <li>Architecture: System design and component documentation</li> <li>Development: Contributing and development guides</li> <li>Operations: Deployment and maintenance guides</li> </ul>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Before submitting:</li> <li>Ensure all tests pass</li> <li>Update documentation</li> <li>Rebase on latest main/develop</li> <li> <p>Resolve any merge conflicts</p> </li> <li> <p>PR requirements:</p> </li> <li>Clear description of changes</li> <li>Link to related issue (if applicable)</li> <li>Tests pass and coverage maintained</li> <li>Documentation updated</li> <li> <p>Code reviewed by at least one maintainer</p> </li> <li> <p>After submission:</p> </li> <li>Respond to review comments</li> <li>Make requested changes</li> <li>Keep PR updated with main branch</li> <li>Be patient and respectful</li> </ol>"},{"location":"development/contributing/#issue-reporting","title":"Issue Reporting","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, include:</p> <ul> <li>Clear, descriptive title</li> <li>Steps to reproduce</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Environment details (OS, Python version, etc.)</li> <li>Error messages and stack traces</li> <li>Relevant logs</li> </ul> <p>Example:</p> <pre><code>## Bug Description\nRate limiter fails under high concurrent load\n\n## Steps to Reproduce\n1. Start gateway with default configuration\n2. Send 100 concurrent requests\n3. Observe rate limit errors\n\n## Expected Behavior\nAll requests should be properly rate limited\n\n## Actual Behavior\nSome requests bypass rate limiter\n\n## Environment\n- Python: 3.12.0\n- OS: Ubuntu 22.04\n- Redis: 7.0.5\n</code></pre>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>When suggesting features, include:</p> <ul> <li>Clear description of the feature</li> <li>Use case and motivation</li> <li>Proposed implementation (optional)</li> <li>Potential impact on existing functionality</li> </ul>"},{"location":"development/contributing/#contributor-license-agreement","title":"Contributor License Agreement","text":"<p>By contributing to this repository, you agree that:</p> <ul> <li>Your contributions will be licensed under the MIT License</li> <li>You have the right to contribute the code/documentation</li> <li>You understand your contributions may be modified or rejected</li> </ul>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<p>If you need help with contributing:</p> <ul> <li>Check existing documentation</li> <li>Search existing issues and pull requests</li> <li>Open a discussion on GitHub</li> <li>Ask questions in pull request comments</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>All contributors will be recognized in the project. Significant contributions may be highlighted in release notes.</p>"},{"location":"development/contributing/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub Flow Guide</li> <li>Writing Good Commit Messages</li> <li>Python Type Hints</li> <li>FastAPI Documentation</li> </ul> <p>Thank you for contributing to LOLStonks API Gateway!</p>"},{"location":"development/documentation/","title":"Documentation Guide","text":"<p>This guide explains how to contribute to and maintain the documentation for the LOLStonks API Gateway.</p>"},{"location":"development/documentation/#documentation-system-overview","title":"Documentation System Overview","text":"<p>The project uses MkDocs with the mkdocstrings plugin to generate documentation directly from Python docstrings. This ensures that the documentation stays in sync with the codebase.</p>"},{"location":"development/documentation/#documentation-stack","title":"Documentation Stack","text":"<ul> <li>MkDocs: Static site generator</li> <li>mkdocstrings: Automatic API documentation from docstrings</li> <li>Material for MkDocs: Modern documentation theme</li> <li>Markdown: Source format for all documentation</li> </ul>"},{"location":"development/documentation/#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md                   # Homepage and project overview\n\u251c\u2500\u2500 getting-started/           # User guides\n\u2502   \u251c\u2500\u2500 installation.md\n\u2502   \u251c\u2500\u2500 quick-start.md\n\u2502   \u2514\u2500\u2500 configuration.md\n\u251c\u2500\u2500 api/                       # API reference (auto-generated)\n\u2502   \u251c\u2500\u2500 overview.md\n\u2502   \u251c\u2500\u2500 riot-client.md\n\u2502   \u251c\u2500\u2500 models.md\n\u2502   \u251c\u2500\u2500 routers.md\n\u2502   \u2514\u2500\u2500 cache.md\n\u251c\u2500\u2500 architecture/              # Architecture documentation\n\u2502   \u251c\u2500\u2500 overview.md\n\u2502   \u251c\u2500\u2500 rate-limiting.md\n\u2502   \u2514\u2500\u2500 caching.md\n\u251c\u2500\u2500 development/               # Developer documentation\n\u2502   \u251c\u2500\u2500 contributing.md\n\u2502   \u251c\u2500\u2500 testing.md\n\u2502   \u2514\u2500\u2500 documentation.md\n\u251c\u2500\u2500 legacy/                    # Legacy documentation\n\u2502   \u251c\u2500\u2500 api.md\n\u2502   \u251c\u2500\u2500 setup.md\n\u2502   \u2514\u2500\u2500 architecture.md\n\u2514\u2500\u2500 data/                      # Generated data files\n    \u2514\u2500\u2500 openapi.json\n</code></pre>"},{"location":"development/documentation/#writing-documentation","title":"Writing Documentation","text":""},{"location":"development/documentation/#markdown-guidelines","title":"Markdown Guidelines","text":""},{"location":"development/documentation/#headers","title":"Headers","text":"<pre><code># Level 1 Header (Page Title)\n## Level 2 Header\n### Level 3 Header\n#### Level 4 Header\n</code></pre>"},{"location":"development/documentation/#code-blocks","title":"Code Blocks","text":"<pre><code># Inline code\nUse `inline code` for short code snippets.\n\n# Fenced code blocks\n```python\ndef example_function():\n    \"\"\"Example function with docstring.\"\"\"\n    return \"Hello, World!\"\n</code></pre>"},{"location":"development/documentation/#code-blocks-with-syntax-highlighting","title":"Code blocks with syntax highlighting","text":"<p><pre><code>def api_request():\n    \"\"\"Make API request with error handling.\"\"\"\n    try:\n        response = await client.get(\"/api/endpoint\")\n        return response.json()\n    except httpx.HTTPError as e:\n        logger.error(f\"API error: {e}\")\n        return None\n</code></pre> <pre><code>#### Lists\n\n```markdown\n# Unordered list\n- Item 1\n- Item 2\n  - Nested item\n  - Another nested item\n\n# Ordered list\n1. First step\n2. Second step\n   1. Sub-step 2.1\n   2. Sub-step 2.2\n3. Third step\n</code></pre></p>"},{"location":"development/documentation/#tables","title":"Tables","text":"<pre><code>| Parameter | Type | Description | Required |\n|-----------|------|-------------|----------|\n| region | str | Riot API region | Yes |\n| count | int | Number of results | No |\n| start | int | Starting index | No |\n</code></pre>"},{"location":"development/documentation/#admonitions","title":"Admonitions","text":"<pre><code>!!! note \"Note Title\"\n    This is a note admonition.\n\n!!! tip \"Tip\"\n    This is a tip for users.\n\n!!! warning \"Warning\"\n    This is a warning message.\n\n!!! danger \"Danger\"\n    This indicates a dangerous action.\n</code></pre>"},{"location":"development/documentation/#links","title":"Links","text":"<pre><code># Internal links\n[Link to installation guide](getting-started/installation.md)\n\n# External links\n[Riot Developer Portal](https://developer.riotgames.com/)\n\n# Reference links\n[API Reference][api-reference]\n\n[api-reference]: api/overview.md\n</code></pre>"},{"location":"development/documentation/#docstring-standards","title":"Docstring Standards","text":""},{"location":"development/documentation/#google-style-docstrings","title":"Google Style Docstrings","text":"<p>The project uses Google Style docstrings for consistency and mkdocstrings compatibility.</p>"},{"location":"development/documentation/#functionmethod-docstrings","title":"Function/Method Docstrings","text":"<pre><code>async def get_summoner_by_name(\n    summonerName: str,\n    region: str = \"euw1\",\n    riot_client: RiotClient = Depends(),\n    cache: RedisCache = Depends()\n) -&gt; SummonerDto:\n    \"\"\"\n    Get summoner information by summoner name.\n\n    Retrieves comprehensive summoner data including profile information,\n    level, and account details from the Riot API.\n\n    Args:\n        summonerName: The summoner name to search for (case-insensitive)\n        region: Riot API region code (default: \"euw1\")\n        riot_client: Dependency-injected Riot API client\n        cache: Dependency-injected Redis cache instance\n\n    Returns:\n        SummonerDto: Summoner information including:\n            - id: Summoner ID\n            - accountId: Account ID\n            - puuid: Player UUID\n            - name: Summoner name\n            - profileIconId: Profile icon ID\n            - summonerLevel: Summoner level\n            - revisionDate: Last data revision timestamp\n\n    Raises:\n        ValueError: If summonerName is empty or invalid\n        httpx.HTTPStatusError: If Riot API returns an error\n        CacheError: If cache operations fail\n\n    Example:\n        &gt;&gt;&gt; summoner = await get_summoner_by_name(\"Faker\", \"kr\")\n        &gt;&gt;&gt; print(f\"Summoner: {summoner['name']} (Level {summoner['summonerLevel']})\")\n        Summoner: Faker (Level 523)\n\n    Note:\n        This endpoint is rate limited and cached for 1 hour to improve\n        performance and reduce API load.\n    \"\"\"\n</code></pre>"},{"location":"development/documentation/#class-docstrings","title":"Class Docstrings","text":"<pre><code>class RiotClient:\n    \"\"\"\n    HTTP client for Riot API with rate limiting and retry logic.\n\n    Provides a robust wrapper around httpx for making requests to the Riot Games API\n    with automatic rate limiting, retry on 429 responses, and proper error handling.\n\n    Attributes:\n        api_key: Riot Games API key for authentication\n        client: Underlying httpx AsyncClient instance\n        rate_limiter: Rate limiter for API request throttling\n\n    Example:\n        &gt;&gt;&gt; client = RiotClient(\"RGAPI-example-key\")\n        &gt;&gt;&gt; summoner = await client.get(\n        ...     \"/lol/summoner/v4/summoners/by-name/Faker\",\n        ...     region=\"kr\"\n        ... )\n        &gt;&gt;&gt; print(summoner[\"name\"])\n        Faker\n    \"\"\"\n</code></pre>"},{"location":"development/documentation/#module-docstrings","title":"Module Docstrings","text":"<pre><code>\"\"\"\nRiot API HTTP client with rate limiting and automatic retries.\n\nThis module provides a comprehensive client for interacting with Riot Games APIs,\nincluding:\n\n- Automatic rate limiting using token bucket algorithm\n- Intelligent retry logic with exponential backoff\n- Region-aware URL routing\n- Comprehensive error handling and logging\n- Support for all Riot API endpoints\n\nThe client is designed to be production-ready with proper error handling,\nlogging, and monitoring capabilities.\n\nExample:\n    &gt;&gt;&gt; from app.riot.client import RiotClient\n    &gt;&gt;&gt; client = RiotClient(\"your-api-key\")\n    &gt;&gt;&gt; data = await client.get(\"/lol/summoner/v4/summoners/by-name/Faker\", \"kr\")\n\"\"\"\n</code></pre>"},{"location":"development/documentation/#api-documentation","title":"API Documentation","text":""},{"location":"development/documentation/#auto-generated-api-docs","title":"Auto-Generated API Docs","text":"<p>API documentation is automatically generated from docstrings using mkdocstrings.</p>"},{"location":"development/documentation/#creating-api-reference-pages","title":"Creating API Reference Pages","text":"<pre><code># Riot Client\n\nThis section documents the Riot API client implementation.\n\n## RiotClient\n\n::: app.riot.client.RiotClient\n    options:\n      show_source: true\n      show_root_heading: true\n      show_root_members_full_path: false\n      members_order: source\n\n## RateLimiter\n\n::: app.riot.rate_limiter.RateLimiter\n    options:\n      show_source: true\n      show_root_heading: true\n      show_root_members_full_path: false\n      members_order: source\n</code></pre>"},{"location":"development/documentation/#mkdocstrings-configuration-options","title":"mkdocstrings Configuration Options","text":"<pre><code>plugins:\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            docstring_style: google\n            show_source: true\n            show_root_heading: true\n            show_root_members_full_path: false\n            show_signature_annotations: true\n            signature_crossrefs: true\n            merge_init_into_class: true\n            members_order: source\n          paths: [.]\n</code></pre>"},{"location":"development/documentation/#cross-references","title":"Cross-References","text":"<p>Use automatic cross-references to link between documentation:</p> <pre><code># Link to specific class/methods\nUse the [`RiotClient`][app.riot.client.RiotClient] for API requests.\n\n# Link to specific method\nCall the [`get()`][app.riot.client.RiotClient.get] method.\n\n# Link with custom text\nThe [rate limiting][app.riot.rate_limiter.RateLimiter] system prevents API abuse.\n</code></pre>"},{"location":"development/documentation/#diagrams-and-visualizations","title":"Diagrams and Visualizations","text":""},{"location":"development/documentation/#mermaid-diagrams","title":"Mermaid Diagrams","text":"<p>Use Mermaid for architecture diagrams and flowcharts:</p> <p><pre><code>### Request Flow\n\n```mermaid\nsequenceDiagram\n    participant C as Client\n    participant G as Gateway\n    participant RL as Rate Limiter\n    participant Cache as Redis Cache\n    participant API as Riot API\n\n    C-&gt;&gt;G: HTTP Request\n    G-&gt;&gt;RL: Check Rate Limit\n    RL--&gt;&gt;G: Rate Limit OK\n    G-&gt;&gt;Cache: Check Cache\n\n    alt Cache Hit\n        Cache--&gt;&gt;G: Cached Response\n        G--&gt;&gt;C: HTTP Response\n    else Cache Miss\n        G-&gt;&gt;API: Make API Request\n        API--&gt;&gt;G: API Response\n        G-&gt;&gt;Cache: Store in Cache\n        G--&gt;&gt;C: HTTP Response\n    end\n</code></pre> <pre><code>### Architecture Diagrams\n\n```markdown\n### System Architecture\n\n```mermaid\ngraph TB\n    Client[Client Applications] --&gt; Gateway[API Gateway]\n    Gateway --&gt; RateLimiter[Rate Limiter]\n    Gateway --&gt; Cache[Redis Cache]\n    Gateway --&gt; RiotAPI[Riot Games API]\n\n    subgraph \"Gateway Components\"\n        Gateway --&gt; FastAPI[FastAPI App]\n        Gateway --&gt; Routers[API Routers]\n        Gateway --&gt; Client[Riot Client]\n    end\n\n    subgraph \"External Services\"\n        Redis[(Redis Server)]\n        Riot[Riot Developer Portal]\n    end\n\n    Cache --&gt; Redis\n    Client --&gt; Riot\n</code></pre> <pre><code>## Local Documentation Development\n\n### Setup\n\n```bash\n# Install documentation dependencies (using UV - recommended)\nuv pip install -e \".[docs]\"\n# or using pip:\npip install -e \".[docs]\"\n</code></pre></p>"},{"location":"development/documentation/#running-local-development-server","title":"Running Local Development Server","text":"<pre><code># Start MkDocs development server\nmkdocs serve\n\n# Start with live reload on specific port\nmkdocs serve --dev-addr=127.0.0.1:8001\n\n# Start with strict mode (better error checking)\nmkdocs serve --strict\n</code></pre>"},{"location":"development/documentation/#building-documentation","title":"Building Documentation","text":"<pre><code># Build documentation\nmkdocs build\n\n# Build with clean output\nmkdocs build --clean\n\n# Build to specific directory\nmkdocs build --site-dir /path/to/output\n</code></pre>"},{"location":"development/documentation/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Make Changes <pre><code># Edit documentation files\nvim docs/getting-started/installation.md\n</code></pre></p> </li> <li> <p>Preview Changes <pre><code># Start development server\nmkdocs serve\n# Visit http://127.0.0.1:8000\n</code></pre></p> </li> <li> <p>Check for Issues <pre><code># Build with strict checking\nmkdocs build --strict\n\n# Check for broken links\nmkdocs build --strict --verbose\n</code></pre></p> </li> <li> <p>Test Documentation <pre><code># Verify API documentation generates correctly\ncurl http://127.0.0.1:8000/api/riot-client/\n</code></pre></p> </li> </ol>"},{"location":"development/documentation/#documentation-quality","title":"Documentation Quality","text":""},{"location":"development/documentation/#review-checklist","title":"Review Checklist","text":"<p>Before submitting documentation changes:</p> <ul> <li>[ ] Accuracy: Information is correct and up-to-date</li> <li>[ ] Clarity: Language is clear and easy to understand</li> <li>[ ] Completeness: All necessary information is included</li> <li>[ ] Consistency: Style and terminology are consistent</li> <li>[ ] Formatting: Markdown formatting is correct</li> <li>[ ] Links: All links work and point to correct locations</li> <li>[ ] Code Examples: Code examples are tested and working</li> <li>[ ] Diagrams: Diagrams are clear and accurate</li> </ul>"},{"location":"development/documentation/#style-guidelines","title":"Style Guidelines","text":"<ol> <li>Active Voice: Use active voice (\"Click here\" not \"The button should be clicked\")</li> <li>Present Tense: Use present tense for instructions (\"Open the file\" not \"Open the file\")</li> <li>Simple Language: Avoid jargon and complex terminology</li> <li>Consistent Terminology: Use the same terms throughout the documentation</li> <li>Examples: Provide concrete examples for complex concepts</li> </ol>"},{"location":"development/documentation/#automated-documentation","title":"Automated Documentation","text":""},{"location":"development/documentation/#api-documentation-generation","title":"API Documentation Generation","text":"<p>The existing script generates API documentation from the running FastAPI app:</p> <pre><code># scripts/generate_api_docs.py\nimport asyncio\nimport httpx\nimport json\nfrom pathlib import Path\n\nasync def generate_api_docs():\n    \"\"\"Generate comprehensive API documentation.\"\"\"\n\n    # Get OpenAPI schema from running app\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\"http://localhost:8000/openapi.json\")\n        openapi_schema = response.json()\n\n    # Generate documentation pages\n    generate_endpoints_overview(openapi_schema)\n    generate_schemas_documentation(openapi_schema)\n</code></pre>"},{"location":"development/documentation/#cicd-integration","title":"CI/CD Integration","text":"<p>Documentation is automatically built and deployed:</p> <pre><code># .github/workflows/docs.yml\nname: Deploy Documentation\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.12'\n\n    - name: Install dependencies\n      run: |\n        pip install -e \".[docs]\"\n\n    - name: Build documentation\n      run: mkdocs build\n\n    - name: Deploy to GitHub Pages\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: ./site\n</code></pre>"},{"location":"development/documentation/#contributing-to-documentation","title":"Contributing to Documentation","text":""},{"location":"development/documentation/#adding-new-documentation","title":"Adding New Documentation","text":"<ol> <li>Create the file in the appropriate directory</li> <li>Follow the style guidelines for formatting and structure</li> <li>Add cross-references to related documentation</li> <li>Update the navigation in <code>mkdocs.yml</code></li> <li>Test locally with <code>mkdocs serve</code></li> <li>Submit pull request with clear description</li> </ol>"},{"location":"development/documentation/#updating-existing-documentation","title":"Updating Existing Documentation","text":"<ol> <li>Make minimal changes to fix issues</li> <li>Preserve existing style and structure</li> <li>Update related documentation if necessary</li> <li>Test changes thoroughly</li> <li>Document the changes in pull request</li> </ol>"},{"location":"development/documentation/#documentation-review-process","title":"Documentation Review Process","text":"<ol> <li>Self-review your changes before submitting</li> <li>Check links and formatting</li> <li>Test code examples to ensure they work</li> <li>Request review from maintainers</li> <li>Address feedback promptly</li> </ol>"},{"location":"development/documentation/#best-practices","title":"Best Practices","text":""},{"location":"development/documentation/#documentation-maintenance","title":"Documentation Maintenance","text":"<ol> <li>Keep documentation current with code changes</li> <li>Review regularly for accuracy and completeness</li> <li>Update examples when APIs change</li> <li>Remove outdated information promptly</li> <li>Add new features to documentation as they're added</li> </ol>"},{"location":"development/documentation/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Optimize images for web (compress, appropriate formats)</li> <li>Minimize external dependencies in documentation</li> <li>Use code highlighting efficiently</li> <li>Avoid excessive nesting in documentation structure</li> </ol>"},{"location":"development/documentation/#accessibility","title":"Accessibility","text":"<ol> <li>Use semantic HTML in generated output</li> <li>Provide alt text for images and diagrams</li> <li>Ensure sufficient color contrast in diagrams</li> <li>Use descriptive link text instead of \"click here\"</li> </ol> <p>This documentation system ensures that the LOLStonks API Gateway has comprehensive, maintainable, and user-friendly documentation that stays synchronized with the codebase.</p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide covers testing strategies, tools, and best practices for the LOLStonks API Gateway.</p>"},{"location":"development/testing/#testing-overview","title":"Testing Overview","text":"<p>The project uses a comprehensive testing approach with multiple test types:</p> <ul> <li>Unit Tests: Test individual components in isolation</li> <li>Integration Tests: Test component interactions</li> <li>End-to-End Tests: Test complete request flows</li> <li>Performance Tests: Test system performance under load</li> </ul>"},{"location":"development/testing/#test-setup","title":"Test Setup","text":""},{"location":"development/testing/#installation","title":"Installation","text":"<pre><code># Install test dependencies\npip install -e \".[dev]\"\n\n# Or with uv\nuv install --extra dev\n</code></pre>"},{"location":"development/testing/#test-configuration","title":"Test Configuration","text":"<p>Create a test environment file:</p> <pre><code># .env.test\nRIOT_API_KEY=test-key-for-testing\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=1  # Separate database for testing\nLOG_LEVEL=DEBUG\nRATE_LIMIT_RPS=1000  # High limits for testing\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#basic-test-commands","title":"Basic Test Commands","text":"<pre><code># Run all tests\npytest\n\n# Run tests with coverage\npytest --cov=app --cov-report=html\n\n# Run specific test file\npytest tests/test_summoner.py\n\n# Run tests with specific marker\npytest -m unit\npytest -m integration\npytest -m slow\n</code></pre>"},{"location":"development/testing/#test-configuration_1","title":"Test Configuration","text":"<pre><code># pytest.ini\n[tool:pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\naddopts =\n    --strict-markers\n    --strict-config\n    --tb=short\n    -v\nmarkers =\n    unit: Unit tests (fast, no external dependencies)\n    integration: Integration tests (requires external services)\n    slow: Slow tests (performance, load testing)\n    external: Tests that hit external APIs\n</code></pre>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Pytest configuration and fixtures\n\u251c\u2500\u2500 unit/                    # Unit tests\n\u2502   \u251c\u2500\u2500 test_rate_limiter.py\n\u2502   \u251c\u2500\u2500 test_cache.py\n\u2502   \u2514\u2500\u2500 test_models.py\n\u251c\u2500\u2500 integration/             # Integration tests\n\u2502   \u251c\u2500\u2500 test_client.py\n\u2502   \u251c\u2500\u2500 test_cache_integration.py\n\u2502   \u2514\u2500\u2500 test_routers.py\n\u251c\u2500\u2500 end_to_end/              # End-to-end tests\n\u2502   \u251c\u2500\u2500 test_api_flows.py\n\u2502   \u2514\u2500\u2500 test_full_scenarios.py\n\u251c\u2500\u2500 performance/             # Performance tests\n\u2502   \u251c\u2500\u2500 test_load.py\n\u2502   \u2514\u2500\u2500 test_stress.py\n\u2514\u2500\u2500 fixtures/                # Test data\n    \u251c\u2500\u2500 summoner_data.json\n    \u251c\u2500\u2500 match_data.json\n    \u2514\u2500\u2500 league_data.json\n</code></pre>"},{"location":"development/testing/#fixtures-and-configuration","title":"Fixtures and Configuration","text":""},{"location":"development/testing/#conftestpy","title":"conftest.py","text":"<pre><code># tests/conftest.py\nimport pytest\nimport asyncio\nimport json\nfrom pathlib import Path\nfrom unittest.mock import AsyncMock, MagicMock\nfrom httpx import AsyncClient\n\nfrom app.main import app\nfrom app.riot.client import RiotClient\nfrom app.cache.redis_cache import RedisCache\nfrom app.cache.tracking import MatchTracker\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create an instance of the default event loop for the test session.\"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\nasync def client():\n    \"\"\"Test client for FastAPI app.\"\"\"\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        yield ac\n\n@pytest.fixture\ndef mock_redis():\n    \"\"\"Mock Redis client for testing.\"\"\"\n    redis_mock = AsyncMock()\n    redis_mock.get.return_value = None\n    redis_mock.setex.return_value = True\n    redis_mock.delete.return_value = True\n    redis_mock.sismember.return_value = False\n    redis_mock.sadd.return_value = True\n    return redis_mock\n\n@pytest.fixture\ndef cache(mock_redis):\n    \"\"\"Redis cache fixture with mocked Redis.\"\"\"\n    cache = RedisCache()\n    cache.redis = mock_redis\n    return cache\n\n@pytest.fixture\ndef mock_riot_client():\n    \"\"\"Mock Riot client for testing.\"\"\"\n    client = AsyncMock()\n    return client\n\n@pytest.fixture\ndef rate_limiter():\n    \"\"\"Rate limiter fixture for testing.\"\"\"\n    from app.riot.rate_limiter import RateLimiter\n    return RateLimiter(rate=100, capacity=1000)  # High limits for tests\n\n@pytest.fixture\ndef match_tracker(cache):\n    \"\"\"Match tracker fixture.\"\"\"\n    return MatchTracker(cache)\n\n@pytest.fixture\ndef sample_summoner_data():\n    \"\"\"Sample summoner data for testing.\"\"\"\n    return {\n        \"id\": \"test-summoner-id\",\n        \"accountId\": \"test-account-id\",\n        \"puuid\": \"test-puuid\",\n        \"name\": \"TestSummoner\",\n        \"profileIconId\": 1,\n        \"revisionDate\": 1234567890,\n        \"summonerLevel\": 30\n    }\n\n@pytest.fixture\ndef sample_match_data():\n    \"\"\"Sample match data for testing.\"\"\"\n    return {\n        \"gameId\": 1234567890,\n        \"gameDuration\": 1800,\n        \"gameMode\": \"CLASSIC\",\n        \"gameType\": \"MATCHED_GAME\",\n        \"participants\": [],\n        \"teams\": []\n    }\n\ndef load_fixture(filename):\n    \"\"\"Load test data from JSON fixture.\"\"\"\n    fixture_path = Path(__file__).parent / \"fixtures\" / filename\n    with open(fixture_path, 'r') as f:\n        return json.load(f)\n</code></pre>"},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":""},{"location":"development/testing/#rate-limiter-tests","title":"Rate Limiter Tests","text":"<pre><code># tests/unit/test_rate_limiter.py\nimport pytest\nimport asyncio\nfrom unittest.mock import patch\nfrom datetime import datetime, timedelta\n\nfrom app.riot.rate_limiter import RateLimiter\n\nclass TestRateLimiter:\n    \"\"\"Test the rate limiter implementation.\"\"\"\n\n    @pytest.mark.unit\n    def test_rate_limiter_initialization(self):\n        \"\"\"Test rate limiter initialization.\"\"\"\n        limiter = RateLimiter(rate=10, capacity=50)\n        assert limiter.rate == 10\n        assert limiter.capacity == 50\n        assert limiter.tokens == 50\n\n    @pytest.mark.unit\n    async def test_token_consumption(self):\n        \"\"\"Test token consumption.\"\"\"\n        limiter = RateLimiter(rate=10, capacity=50)\n\n        # Should consume one token\n        await limiter.acquire()\n        assert limiter.tokens == 49\n\n    @pytest.mark.unit\n    async def test_token_refill(self):\n        \"\"\"Test token refill over time.\"\"\"\n        limiter = RateLimiter(rate=10, capacity=50)\n\n        # Consume all tokens\n        for _ in range(50):\n            await limiter.acquire()\n\n        assert limiter.tokens == 0\n\n        # Wait for refill (mock time passage)\n        with patch('datetime.datetime') as mock_datetime:\n            mock_datetime.utcnow.return_value = datetime.utcnow() + timedelta(seconds=2)\n            await limiter._refill()\n\n            # Should have 20 tokens after 2 seconds (10 * 2)\n            assert limiter.tokens == 20\n\n    @pytest.mark.unit\n    async def test_rate_limit_exceeded(self):\n        \"\"\"Test behavior when rate limit is exceeded.\"\"\"\n        limiter = RateLimiter(rate=1, capacity=2)\n\n        # Consume all tokens\n        await limiter.acquire()\n        await limiter.acquire()\n\n        # Next acquire should wait\n        start_time = asyncio.get_event_loop().time()\n        await limiter.acquire()\n        end_time = asyncio.get_event_loop().time()\n\n        # Should have waited at least 1 second\n        assert end_time - start_time &gt;= 1.0\n\n    @pytest.mark.unit\n    async def test_concurrent_acquisition(self):\n        \"\"\"Test concurrent token acquisition.\"\"\"\n        limiter = RateLimiter(rate=100, capacity=100)\n\n        async def acquire_tokens():\n            for _ in range(10):\n                await limiter.acquire()\n\n        # Run multiple concurrent tasks\n        tasks = [acquire_tokens() for _ in range(10)]\n        await asyncio.gather(*tasks)\n\n        # Should have consumed exactly 100 tokens\n        assert limiter.tokens == 0\n</code></pre>"},{"location":"development/testing/#cache-tests","title":"Cache Tests","text":"<pre><code># tests/unit/test_cache.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\nimport json\n\nfrom app.cache.redis_cache import RedisCache\n\nclass TestRedisCache:\n    \"\"\"Test Redis cache implementation.\"\"\"\n\n    @pytest.mark.unit\n    def test_cache_key_generation(self):\n        \"\"\"Test cache key generation.\"\"\"\n        cache = RedisCache()\n\n        key = cache._generate_key(\"summoner\", \"euw1\", \"test-id\")\n        assert key == \"lolstonks:summoner:euw1:test-id\"\n\n    @pytest.mark.unit\n    async def test_cache_set_and_get(self, mock_redis):\n        \"\"\"Test setting and getting cache values.\"\"\"\n        cache = RedisCache()\n        cache.redis = mock_redis\n\n        test_data = {\"id\": \"test\", \"name\": \"Test User\"}\n\n        # Set cache\n        result = await cache.set(\"summoner\", \"euw1\", \"test-id\", test_data, ttl=3600)\n        assert result is True\n\n        # Configure mock for get\n        mock_redis.get.return_value = json.dumps(test_data)\n\n        # Get cache\n        result = await cache.get(\"summoner\", \"euw1\", \"test-id\")\n        assert result == test_data\n\n    @pytest.mark.unit\n    async def test_cache_miss(self, mock_redis):\n        \"\"\"Test cache miss scenario.\"\"\"\n        cache = RedisCache()\n        cache.redis = mock_redis\n\n        # Configure mock to return None (cache miss)\n        mock_redis.get.return_value = None\n\n        result = await cache.get(\"summoner\", \"euw1\", \"nonexistent\")\n        assert result is None\n\n    @pytest.mark.unit\n    async def test_cache_delete(self, mock_redis):\n        \"\"\"Test cache deletion.\"\"\"\n        cache = RedisCache()\n        cache.redis = mock_redis\n\n        result = await cache.delete(\"summoner\", \"euw1\", \"test-id\")\n        assert result is True\n\n        mock_redis.delete.assert_called_once_with(\"lolstonks:summoner:euw1:test-id\")\n\n    @pytest.mark.unit\n    async def test_cache_error_handling(self, mock_redis):\n        \"\"\"Test cache error handling.\"\"\"\n        cache = RedisCache()\n        cache.redis = mock_redis\n\n        # Configure mock to raise exception\n        mock_redis.get.side_effect = Exception(\"Redis error\")\n\n        result = await cache.get(\"summoner\", \"euw1\", \"test-id\")\n        assert result is None\n\n    @pytest.mark.unit\n    def test_ttl_config_loading(self, monkeypatch):\n        \"\"\"Test TTL configuration loading.\"\"\"\n        # Set environment variables\n        monkeypatch.setenv(\"CACHE_TTL_SUMMONER\", \"7200\")\n        monkeypatch.setenv(\"CACHE_TTL_MATCH\", \"86400\")\n\n        cache = RedisCache()\n\n        assert cache.ttl_config[\"summoner\"] == 7200\n        assert cache.ttl_config[\"match\"] == 86400\n</code></pre>"},{"location":"development/testing/#model-tests","title":"Model Tests","text":"<pre><code># tests/unit/test_models.py\nimport pytest\nfrom pydantic import ValidationError\n\nfrom app.models.summoner import SummonerDto, SummonerByNameParams\nfrom app.models.match import MatchDto, MatchIdsByPuuidParams\n\nclass TestModels:\n    \"\"\"Test Pydantic models.\"\"\"\n\n    @pytest.mark.unit\n    def test_summoner_dto_validation(self, sample_summoner_data):\n        \"\"\"Test SummonerDto validation.\"\"\"\n        summoner = SummonerDto(**sample_summoner_data)\n\n        assert summoner.id == \"test-summoner-id\"\n        assert summoner.name == \"TestSummoner\"\n        assert summoner.summonerLevel == 30\n\n    @pytest.mark.unit\n    def test_summoner_dto_missing_required_fields(self):\n        \"\"\"Test SummonerDto validation with missing fields.\"\"\"\n        invalid_data = {\n            \"id\": \"test-id\",\n            # Missing required fields\n        }\n\n        with pytest.raises(ValidationError):\n            SummonerDto(**invalid_data)\n\n    @pytest.mark.unit\n    def test_summoner_by_name_params(self):\n        \"\"\"Test SummonerByNameParams validation.\"\"\"\n        params = SummonerByNameParams(summonerName=\"TestSummoner\")\n        assert params.summonerName == \"TestSummoner\"\n\n    @pytest.mark.unit\n    def test_match_ids_by_puuid_params(self):\n        \"\"\"Test MatchIdsByPuuidParams validation.\"\"\"\n        params = MatchIdsByPuuidParams(\n            puuid=\"test-puuid\",\n            count=10,\n            start=0\n        )\n        assert params.puuid == \"test-puuid\"\n        assert params.count == 10\n        assert params.start == 0\n\n    @pytest.mark.unit\n    def test_model_serialization(self, sample_summoner_data):\n        \"\"\"Test model serialization.\"\"\"\n        summoner = SummonerDto(**sample_summoner_data)\n\n        serialized = summoner.model_dump()\n        assert serialized[\"id\"] == \"test-summoner-id\"\n        assert serialized[\"name\"] == \"TestSummoner\"\n\n    @pytest.mark.unit\n    def test_model_json_serialization(self, sample_summoner_data):\n        \"\"\"Test model JSON serialization.\"\"\"\n        summoner = SummonerDto(**sample_summoner_data)\n\n        json_str = summoner.model_dump_json()\n        assert \"test-summoner-id\" in json_str\n        assert \"TestSummoner\" in json_str\n</code></pre>"},{"location":"development/testing/#integration-tests","title":"Integration Tests","text":""},{"location":"development/testing/#client-integration-tests","title":"Client Integration Tests","text":"<pre><code># tests/integration/test_client.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\nimport httpx\n\nfrom app.riot.client import RiotClient, RateLimitExceeded\n\nclass TestRiotClient:\n    \"\"\"Test Riot client integration.\"\"\"\n\n    @pytest.mark.integration\n    async def test_successful_request(self, mock_riot_client, rate_limiter):\n        \"\"\"Test successful API request.\"\"\"\n        mock_riot_client.get.return_value = {\"id\": \"test-summoner-id\"}\n\n        client = RiotClient(\"test-api-key\")\n        client.client = mock_riot_client\n        client.rate_limiter = rate_limiter\n\n        result = await client.get(\"/summoner/v4/summoners/by-name/test\", \"euw1\")\n\n        assert result[\"id\"] == \"test-summoner-id\"\n\n    @pytest.mark.integration\n    async def test_rate_limit_handling(self, mock_riot_client, rate_limiter):\n        \"\"\"Test rate limit handling.\"\"\"\n        # Mock 429 response\n        mock_response = AsyncMock()\n        mock_response.status_code = 429\n        mock_response.headers = {\"Retry-After\": \"1\"}\n        mock_riot_client.get.return_value = mock_response\n\n        client = RiotClient(\"test-api-key\")\n        client.client = mock_riot_client\n        client.rate_limiter = rate_limiter\n\n        with pytest.raises(RateLimitExceeded):\n            await client.get(\"/summoner/v4/summoners/by-name/test\", \"euw1\")\n\n    @pytest.mark.integration\n    async def test_retry_mechanism(self, mock_riot_client, rate_limiter):\n        \"\"\"Test retry mechanism.\"\"\"\n        # First call returns 429, second call succeeds\n        mock_429_response = AsyncMock()\n        mock_429_response.status_code = 429\n        mock_429_response.headers = {\"Retry-After\": \"1\"}\n\n        mock_success_response = AsyncMock()\n        mock_success_response.status_code = 200\n        mock_success_response.json.return_value = {\"id\": \"test-summoner-id\"}\n\n        mock_riot_client.get.side_effect = [mock_429_response, mock_success_response]\n\n        client = RiotClient(\"test-api-key\")\n        client.client = mock_riot_client\n        client.rate_limiter = rate_limiter\n\n        with patch('asyncio.sleep'):  # Skip actual sleep\n            result = await client.get(\"/summoner/v4/summoners/by-name/test\", \"euw1\")\n\n        assert result[\"id\"] == \"test-summoner-id\"\n        assert mock_riot_client.get.call_count == 2\n</code></pre>"},{"location":"development/testing/#router-integration-tests","title":"Router Integration Tests","text":"<pre><code># tests/integration/test_routers.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\nfrom fastapi.testclient import TestClient\n\nfrom app.main import app\n\nclass TestRouters:\n    \"\"\"Test router integration.\"\"\"\n\n    @pytest.mark.integration\n    async def test_summoner_by_name_endpoint(self, client, mock_riot_client):\n        \"\"\"Test summoner by name endpoint.\"\"\"\n        sample_response = {\n            \"id\": \"test-summoner-id\",\n            \"name\": \"TestSummoner\",\n            \"summonerLevel\": 30\n        }\n\n        with patch('app.routers.summoner.riot_client', mock_riot_client):\n            mock_riot_client.get.return_value = sample_response\n\n            response = await client.get(\n                \"/summoner/by-name/TestSummoner?region=euw1\"\n            )\n\n            assert response.status_code == 200\n            data = response.json()\n            assert data[\"id\"] == \"test-summoner-id\"\n            assert data[\"name\"] == \"TestSummoner\"\n\n    @pytest.mark.integration\n    async def test_summoner_not_found(self, client, mock_riot_client):\n        \"\"\"Test summoner not found scenario.\"\"\"\n        with patch('app.routers.summoner.riot_client', mock_riot_client):\n            mock_riot_client.get.side_effect = httpx.HTTPStatusError(\n                \"Not Found\", request=AsyncMock(), response=AsyncMock(status_code=404)\n            )\n\n            response = await client.get(\n                \"/summoner/by-name/NonexistentSummoner?region=euw1\"\n            )\n\n            assert response.status_code == 404\n\n    @pytest.mark.integration\n    async def test_health_check_endpoint(self, client):\n        \"\"\"Test health check endpoint.\"\"\"\n        response = await client.get(\"/health\")\n\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"status\"] == \"ok\"\n\n    @pytest.mark.integration\n    async def test_rate_limit_headers(self, client, mock_riot_client):\n        \"\"\"Test rate limit headers in response.\"\"\"\n        sample_response = {\"id\": \"test-id\"}\n\n        with patch('app.routers.summoner.riot_client', mock_riot_client):\n            mock_riot_client.get.return_value = sample_response\n\n            response = await client.get(\n                \"/summoner/by-name/Test?region=euw1\"\n            )\n\n            # Check for rate limit headers\n            assert \"X-Rate-Limit-Remaining\" in response.headers\n            assert \"X-Rate-Limit-Limit\" in response.headers\n</code></pre>"},{"location":"development/testing/#performance-tests","title":"Performance Tests","text":""},{"location":"development/testing/#load-testing","title":"Load Testing","text":"<pre><code># tests/performance/test_load.py\nimport pytest\nimport asyncio\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\nfrom app.riot.rate_limiter import RateLimiter\nfrom app.cache.redis_cache import RedisCache\n\n@pytest.mark.slow\nclass TestPerformance:\n    \"\"\"Performance and load tests.\"\"\"\n\n    @pytest.mark.slow\n    async def test_rate_limiter_performance(self):\n        \"\"\"Test rate limiter under load.\"\"\"\n        limiter = RateLimiter(rate=100, capacity=1000)\n\n        start_time = time.time()\n\n        # Make 1000 concurrent requests\n        tasks = [limiter.acquire() for _ in range(1000)]\n        await asyncio.gather(*tasks)\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        # Should complete in reasonable time (within 15 seconds)\n        assert duration &lt; 15.0\n\n        # Rate limiter should still work\n        assert limiter.tokens &gt;= 0\n\n    @pytest.mark.slow\n    async def test_cache_performance(self, cache):\n        \"\"\"Test cache performance under load.\"\"\"\n        test_data = {\"id\": \"test\", \"data\": \"x\" * 1000}  # 1KB data\n\n        start_time = time.time()\n\n        # Perform 1000 cache operations\n        tasks = []\n        for i in range(1000):\n            tasks.append(cache.set(\"test\", \"euw1\", f\"key{i}\", test_data))\n            tasks.append(cache.get(\"test\", \"euw1\", f\"key{i}\"))\n\n        await asyncio.gather(*tasks)\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        # Should complete quickly (within 5 seconds)\n        assert duration &lt; 5.0\n\n        # Performance: at least 200 operations per second\n        operations_per_second = 2000 / duration\n        assert operations_per_second &gt; 200\n\n    @pytest.mark.slow\n    async def test_concurrent_api_requests(self, client):\n        \"\"\"Test concurrent API request handling.\"\"\"\n        async def make_request():\n            response = await client.get(\"/health\")\n            return response.status_code\n\n        start_time = time.time()\n\n        # Make 100 concurrent requests\n        tasks = [make_request() for _ in range(100)]\n        results = await asyncio.gather(*tasks)\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        # All requests should succeed\n        assert all(status == 200 for status in results)\n\n        # Should complete quickly (within 2 seconds)\n        assert duration &lt; 2.0\n\n        # Performance: at least 50 requests per second\n        requests_per_second = 100 / duration\n        assert requests_per_second &gt; 50\n</code></pre>"},{"location":"development/testing/#external-api-tests","title":"External API Tests","text":""},{"location":"development/testing/#real-api-tests","title":"Real API Tests","text":"<pre><code># tests/integration/test_external_api.py\nimport pytest\nimport os\n\nfrom app.riot.client import RiotClient\n\n@pytest.mark.external\n@pytest.mark.slow\nclass TestExternalAPI:\n    \"\"\"Tests against real Riot API (requires API key).\"\"\"\n\n    @pytest.fixture\n    def real_riot_client(self):\n        \"\"\"Real Riot client using actual API key.\"\"\"\n        api_key = os.getenv(\"RIOT_API_KEY\")\n        if not api_key:\n            pytest.skip(\"No RIOT_API_KEY environment variable set\")\n\n        return RiotClient(api_key)\n\n    @pytest.mark.external\n    async def test_real_summoner_lookup(self, real_riot_client):\n        \"\"\"Test real summoner lookup.\"\"\"\n        try:\n            result = await real_riot_client.get(\n                \"/lol/summoner/v4/summoners/by-name/Faker\",\n                \"kr\"\n            )\n\n            assert \"id\" in result\n            assert \"name\" in result\n            assert result[\"name\"] == \"Faker\"\n        except Exception as e:\n            pytest.skip(f\"External API test failed: {e}\")\n\n    @pytest.mark.external\n    async def test_real_challenger_lookup(self, real_riot_client):\n        \"\"\"Test real challenger league lookup.\"\"\"\n        try:\n            result = await real_riot_client.get(\n                \"/lol/league/v4/challengerleagues/by-queue/RANKED_SOLO_5x5\",\n                \"kr\"\n            )\n\n            assert \"tier\" in result\n            assert \"entries\" in result\n            assert result[\"tier\"] == \"CHALLENGER\"\n        except Exception as e:\n            pytest.skip(f\"External API test failed: {e}\")\n</code></pre>"},{"location":"development/testing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/testing/#common-test-issues","title":"Common Test Issues","text":"<ol> <li> <p>Redis Connection Errors <pre><code># Make sure Redis is running\nredis-server\n\n# Or run in Docker\ndocker run -d -p 6379:6379 redis:7-alpine\n</code></pre></p> </li> <li> <p>Rate Limiting in Tests <pre><code># Set high rate limits for tests\nRATE_LIMIT_RPS=1000\nRATE_LIMIT_BURST=10000\n</code></pre></p> </li> <li> <p>Test Database Issues <pre><code># Use separate Redis database for testing\nREDIS_DB=1\n\n# Flush test database between runs\nredis-cli -n 1 FLUSHDB\n</code></pre></p> </li> <li> <p>Import Errors <pre><code># Make sure you're in the project root\ncd /path/to/lolstonks-api-gateway\n\n# Install in development mode\npip install -e \".[dev]\"\n</code></pre></p> </li> </ol>"},{"location":"development/testing/#debugging-tests","title":"Debugging Tests","text":"<pre><code># Run with verbose output\npytest -v -s\n\n# Stop on first failure\npytest -x\n\n# Run with debugger\npytest --pdb\n\n# Show local variables on failure\npytest -l\n\n# Run specific test with debug\npytest tests/unit/test_rate_limiter.py::TestRateLimiter::test_token_consumption -v -s\n</code></pre> <p>This comprehensive testing strategy ensures the LOLStonks API Gateway is reliable, performant, and maintainable across different scenarios and conditions.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>This guide covers all configuration options available for the LOLStonks API Gateway.</p>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>The gateway uses environment variables for configuration. You can set these in a <code>.env</code> file or as system environment variables.</p>"},{"location":"getting-started/configuration/#required-variables","title":"Required Variables","text":"<pre><code># Riot Games API Key\nRIOT_API_KEY=RGAPI-your-api-key-here\n</code></pre> <p>Get your API key from the Riot Developer Portal.</p>"},{"location":"getting-started/configuration/#optional-variables","title":"Optional Variables","text":""},{"location":"getting-started/configuration/#core-configuration","title":"Core Configuration","text":"<pre><code># Default Riot API region (default: euw1)\nRIOT_DEFAULT_REGION=euw1\n\n# Server configuration\nHOST=0.0.0.0\nPORT=8080\n\n# Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\nLOG_LEVEL=INFO\n</code></pre>"},{"location":"getting-started/configuration/#redis-configuration","title":"Redis Configuration","text":"<pre><code># Redis connection settings\nREDIS_HOST=redis\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=\n</code></pre> <p>Note: Connection pooling is handled automatically by aiocache library.</p>"},{"location":"getting-started/configuration/#rate-limiting-configuration","title":"Rate Limiting Configuration","text":"<pre><code># Rate limiting settings (Riot API compliance)\nRIOT_RATE_LIMIT_PER_SECOND=20    # Requests per second (short-term limit)\nRIOT_RATE_LIMIT_PER_2MIN=100     # Requests per 2 minutes (long-term limit)\nRIOT_REQUEST_TIMEOUT=10          # HTTP request timeout in seconds\n</code></pre> <p>Note: These limits use a dual-layer token bucket algorithm. Both limits must be satisfied for a request to proceed.</p>"},{"location":"getting-started/configuration/#caching-configuration","title":"Caching Configuration","text":"<pre><code># Cache TTL settings (in seconds) - Organized by API service\n\n# ACCOUNT-V1: Account and active shard endpoints\nCACHE_TTL_ACCOUNT=3600              # 1 hour - Account data (by puuid/riotId)\nCACHE_TTL_ACCOUNT_SHARD=600         # 10 minutes - Active shard (can change)\n\n# SUMMONER-V4: Summoner profile data\nCACHE_TTL_SUMMONER=3600             # 1 hour\n\n# MATCH-V5: Match history and details\nCACHE_TTL_MATCH=86400               # 24 hours - Match data (immutable)\nCACHE_TTL_TIMELINE=86400            # 24 hours - Match timeline (immutable)\n\n# LEAGUE-V4: Ranked league data\nCACHE_TTL_LEAGUE=3600               # 1 hour\n\n# CHAMPION-MASTERY-V4: Champion mastery points\nCACHE_TTL_MASTERY=3600              # 1 hour\n\n# CHALLENGES-V1: Player challenges and leaderboards\nCACHE_TTL_CHALLENGES_CONFIG=86400   # 24 hours - Challenge configs (static)\nCACHE_TTL_CHALLENGES_LEADERBOARD=600    # 10 minutes - Leaderboards (dynamic)\nCACHE_TTL_CHALLENGES_PERCENTILES=3600   # 1 hour - Percentile data\nCACHE_TTL_CHALLENGES_PLAYER=3600    # 1 hour - Player challenges\n\n# CLASH-V1: Clash tournament data\nCACHE_TTL_CLASH_PLAYER=300          # 5 minutes - Player info (changes during tournaments)\nCACHE_TTL_CLASH_TEAM=300            # 5 minutes - Team info (changes during tournaments)\nCACHE_TTL_CLASH_TOURNAMENT=600      # 10 minutes - Tournament schedule\n\n# CHAMPION-V3: Champion rotation\nCACHE_TTL_CHAMPION_ROTATION=86400   # 24 hours - Rotation changes weekly\n\n# LOL-STATUS-V4: Platform status\nCACHE_TTL_PLATFORM_STATUS=300       # 5 minutes - Status can change frequently\n\n# SPECTATOR-V5: Live game data\nCACHE_TTL_SPECTATOR_ACTIVE=30       # 30 seconds - Active game (very dynamic)\nCACHE_TTL_SPECTATOR_FEATURED=120    # 2 minutes - Featured games\n\n# DATA-DRAGON: Static game data (champions, items, etc.)\nCACHE_TTL_DDRAGON=604800            # 7 days - Static data updated per patch\n\n# Default TTL for any uncategorized cache\nCACHE_TTL_DEFAULT=3600              # 1 hour\n</code></pre> <p>Note: Match tracking uses Redis SET with NO TTL for permanent storage. These are separate from TTL cache entries.</p>"},{"location":"getting-started/configuration/#complete-env-example","title":"Complete .env Example","text":"<pre><code># =============================================================================\n# Riot API Configuration\n# =============================================================================\nRIOT_API_KEY=RGAPI-your-actual-api-key-here\nRIOT_DEFAULT_REGION=euw1\nRIOT_REQUEST_TIMEOUT=10\n\n# =============================================================================\n# Server Configuration\n# =============================================================================\nHOST=0.0.0.0\nPORT=8080\nLOG_LEVEL=INFO\n\n# =============================================================================\n# Redis Configuration\n# =============================================================================\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=\n\n# =============================================================================\n# Rate Limiting Configuration\n# =============================================================================\nRIOT_RATE_LIMIT_PER_SECOND=20\nRIOT_RATE_LIMIT_PER_2MIN=100\n\n# =============================================================================\n# Caching Configuration (All TTL values in seconds)\n# =============================================================================\n\n# ACCOUNT-V1\nCACHE_TTL_ACCOUNT=3600\nCACHE_TTL_ACCOUNT_SHARD=600\n\n# SUMMONER-V4\nCACHE_TTL_SUMMONER=3600\n\n# MATCH-V5\nCACHE_TTL_MATCH=86400\nCACHE_TTL_TIMELINE=86400\n\n# LEAGUE-V4\nCACHE_TTL_LEAGUE=3600\n\n# CHAMPION-MASTERY-V4\nCACHE_TTL_MASTERY=3600\n\n# CHALLENGES-V1\nCACHE_TTL_CHALLENGES_CONFIG=86400\nCACHE_TTL_CHALLENGES_LEADERBOARD=600\nCACHE_TTL_CHALLENGES_PERCENTILES=3600\nCACHE_TTL_CHALLENGES_PLAYER=3600\n\n# CLASH-V1\nCACHE_TTL_CLASH_PLAYER=300\nCACHE_TTL_CLASH_TEAM=300\nCACHE_TTL_CLASH_TOURNAMENT=600\n\n# CHAMPION-V3\nCACHE_TTL_CHAMPION_ROTATION=86400\n\n# LOL-STATUS-V4\nCACHE_TTL_PLATFORM_STATUS=300\n\n# SPECTATOR-V5\nCACHE_TTL_SPECTATOR_ACTIVE=30\nCACHE_TTL_SPECTATOR_FEATURED=120\n\n# DATA-DRAGON\nCACHE_TTL_DDRAGON=604800\n\n# Default\nCACHE_TTL_DEFAULT=3600\n</code></pre>"},{"location":"getting-started/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"getting-started/configuration/#env-file","title":".env File","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code># Copy the example file\ncp .env.example .env\n\n# Edit with your configuration\nnano .env  # or use your preferred editor\n</code></pre>"},{"location":"getting-started/configuration/#docker-compose-configuration","title":"Docker Compose Configuration","text":"<p>When using Docker Compose, you can override environment variables:</p> <pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  api-gateway:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      - RIOT_API_KEY=${RIOT_API_KEY}\n      - REDIS_HOST=redis\n      - LOG_LEVEL=DEBUG\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n</code></pre>"},{"location":"getting-started/configuration/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"getting-started/configuration/#custom-rate-limiting","title":"Custom Rate Limiting","text":"<p>You can customize rate limiting by modifying the environment variables:</p> <pre><code># For high-traffic production API key\nRIOT_RATE_LIMIT_PER_SECOND=50\nRIOT_RATE_LIMIT_PER_2MIN=500\n\n# For development/testing with personal API key\nRIOT_RATE_LIMIT_PER_SECOND=20\nRIOT_RATE_LIMIT_PER_2MIN=100\n</code></pre> <p>Note: Ensure your custom limits comply with your Riot API key tier restrictions.</p>"},{"location":"getting-started/configuration/#redis-configuration-notes","title":"Redis Configuration Notes","text":"<p>For production deployments with Redis:</p> <pre><code># Standard Redis configuration (current implementation uses aiocache)\nREDIS_HOST=redis.example.com\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=your-secure-password\n</code></pre> <p>Note: The current implementation uses aiocache library which handles connection pooling automatically. Redis Cluster support would require custom implementation.</p>"},{"location":"getting-started/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"getting-started/configuration/#development","title":"Development","text":"<pre><code># .env.development\nLOG_LEVEL=DEBUG\nREDIS_HOST=localhost\nCACHE_TTL_SUMMONER=300                 # 5 minutes for development\nCACHE_TTL_MATCH=3600                   # 1 hour (faster refresh)\nRIOT_RATE_LIMIT_PER_SECOND=100         # Higher limits for testing\nRIOT_RATE_LIMIT_PER_2MIN=500\n</code></pre>"},{"location":"getting-started/configuration/#production","title":"Production","text":"<pre><code># .env.production\nLOG_LEVEL=WARNING\nREDIS_HOST=redis.example.com\nREDIS_PASSWORD=strong-redis-password\nCACHE_TTL_SUMMONER=3600                # 1 hour\nCACHE_TTL_MATCH=86400                  # 24 hours\nRIOT_RATE_LIMIT_PER_SECOND=20          # Conservative limits\nRIOT_RATE_LIMIT_PER_2MIN=100\n</code></pre>"},{"location":"getting-started/configuration/#testing","title":"Testing","text":"<pre><code># .env.testing\nLOG_LEVEL=ERROR\nREDIS_HOST=localhost\nCACHE_TTL_SUMMONER=1                   # Very short cache for tests\nCACHE_TTL_MATCH=1\nRIOT_RATE_LIMIT_PER_SECOND=1000        # Very high limits for tests\nRIOT_RATE_LIMIT_PER_2MIN=5000\n</code></pre>"},{"location":"getting-started/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>The gateway validates configuration on startup. Here are common validation checks:</p>"},{"location":"getting-started/configuration/#api-key-validation","title":"API Key Validation","text":"<pre><code># The gateway will check if your API key is valid\n# Invalid or expired keys will cause startup to fail\n</code></pre>"},{"location":"getting-started/configuration/#redis-connection-test","title":"Redis Connection Test","text":"<pre><code># The gateway tests Redis connectivity during startup\n# Connection failures will be logged but won't prevent startup\n</code></pre>"},{"location":"getting-started/configuration/#region-validation","title":"Region Validation","text":"<pre><code># Supported regions are validated\n# Invalid regions will fall back to the default region\n</code></pre>"},{"location":"getting-started/configuration/#performance-tuning","title":"Performance Tuning","text":""},{"location":"getting-started/configuration/#rate-limiting-optimization","title":"Rate Limiting Optimization","text":"<pre><code># For high-traffic applications (production API key)\nRIOT_RATE_LIMIT_PER_SECOND=50\nRIOT_RATE_LIMIT_PER_2MIN=500\n\n# For low-traffic applications (development API key)\nRIOT_RATE_LIMIT_PER_SECOND=20\nRIOT_RATE_LIMIT_PER_2MIN=100\n</code></pre>"},{"location":"getting-started/configuration/#cache-optimization","title":"Cache Optimization","text":"<pre><code># Aggressive caching for better performance (fewer API calls)\nCACHE_TTL_SUMMONER=7200                    # 2 hours\nCACHE_TTL_MATCH=172800                     # 2 days\nCACHE_TTL_LEAGUE=7200                      # 2 hours\nCACHE_TTL_SPECTATOR_ACTIVE=60              # 1 minute\nCACHE_TTL_CHALLENGES_LEADERBOARD=1800      # 30 minutes\n\n# Minimal caching for fresh data (more accurate, more API calls)\nCACHE_TTL_SUMMONER=300                     # 5 minutes\nCACHE_TTL_MATCH=3600                       # 1 hour\nCACHE_TTL_LEAGUE=600                       # 10 minutes\nCACHE_TTL_SPECTATOR_ACTIVE=10              # 10 seconds\nCACHE_TTL_CHALLENGES_LEADERBOARD=60        # 1 minute\n</code></pre> <p>Note: Longer cache TTL improves performance but may show slightly outdated data. Balance based on your application's needs.</p>"},{"location":"getting-started/configuration/#security-configuration","title":"Security Configuration","text":""},{"location":"getting-started/configuration/#api-key-protection","title":"API Key Protection","text":"<pre><code># Never commit API keys to version control\n# Use environment variables or secret management systems\nRIOT_API_KEY=${RIOT_API_KEY_SECRET}\n</code></pre>"},{"location":"getting-started/configuration/#network-security","title":"Network Security","text":"<pre><code># Bind to specific interface in production\nHOST=127.0.0.1              # Local access only\n# or\nHOST=10.0.0.1               # Specific network interface\n</code></pre>"},{"location":"getting-started/configuration/#logging-security","title":"Logging Security","text":"<pre><code># Sanitize logs to avoid logging sensitive data\nLOG_SANITIZE_SECRETS=true\nLOG_LEVEL=WARNING           # Reduce log verbosity in production\n</code></pre>"},{"location":"getting-started/configuration/#monitoring-configuration","title":"Monitoring Configuration","text":""},{"location":"getting-started/configuration/#health-checks","title":"Health Checks","text":"<pre><code># Enable detailed health checks\nHEALTH_CHECK_DETAILED=true\nHEALTH_CHECK_REDIS=true\nHEALTH_CHECK_RIOT_API=true\n</code></pre>"},{"location":"getting-started/configuration/#metrics","title":"Metrics","text":"<pre><code># Enable metrics collection\nMETRICS_ENABLED=true\nMETRICS_PORT=9090\nMETRICS_PATH=/metrics\n</code></pre>"},{"location":"getting-started/configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"getting-started/configuration/#common-issues","title":"Common Issues","text":"<ol> <li> <p>API Key Not Working <pre><code># Check that your API key is valid and not expired\n# Verify it doesn't have IP restrictions\nRIOT_API_KEY=RGAPI-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n</code></pre></p> </li> <li> <p>Redis Connection Failed <pre><code># Check Redis is running and accessible\nREDIS_HOST=localhost\nREDIS_PORT=6379\n# Verify network connectivity and firewall rules\n</code></pre></p> </li> <li> <p>Rate Limiting Too Aggressive <pre><code># Adjust rate limits based on your Riot API key tier\nRIOT_RATE_LIMIT_PER_SECOND=20\nRIOT_RATE_LIMIT_PER_2MIN=100\n</code></pre></p> </li> <li> <p>Cache Not Working <pre><code># Check Redis connection and cache TTL settings\nREDIS_HOST=localhost\nCACHE_TTL_SUMMONER=3600\n</code></pre></p> </li> </ol>"},{"location":"getting-started/configuration/#configuration-debugging","title":"Configuration Debugging","text":"<p>Enable debug logging to troubleshoot configuration issues:</p> <pre><code>LOG_LEVEL=DEBUG\n</code></pre> <p>This will show: - Environment variable loading - Redis connection attempts - Rate limiting configuration - Cache configuration details</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Configure your development environment</li> <li>Set up monitoring and logging</li> <li>Review the API Reference for endpoint details</li> </ul>"},{"location":"getting-started/configuration/#getting-help","title":"Getting Help","text":"<p>If you need help with configuration:</p> <ol> <li>Check the GitHub Issues</li> <li>Review the troubleshooting guide</li> <li>Create a new issue with your configuration details (without sensitive data)</li> </ol>"},{"location":"getting-started/deployment/","title":"Production Deployment","text":"<p>This guide covers deploying the LOLStonks API Gateway to production environments with proper security, monitoring, and scalability considerations.</p>"},{"location":"getting-started/deployment/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/deployment/#system-requirements","title":"System Requirements","text":"<ul> <li>CPU: 2+ cores (4+ recommended for high traffic)</li> <li>RAM: 4GB+ (8GB+ recommended for production)</li> <li>Storage: 20GB+ SSD for logs and caching</li> <li>Network: Stable internet connection with low latency to Riot API servers</li> <li>Operating System: Linux (Ubuntu 20.04+, CentOS 8+, or similar)</li> </ul>"},{"location":"getting-started/deployment/#external-dependencies","title":"External Dependencies","text":"<ul> <li>Redis Server: 6.0+ for caching and session management</li> <li>Reverse Proxy: Nginx 1.18+ or similar for SSL termination</li> <li>Process Manager: systemd, supervisor, or similar</li> <li>SSL Certificate: Valid SSL certificate for HTTPS</li> </ul>"},{"location":"getting-started/deployment/#installation","title":"Installation","text":""},{"location":"getting-started/deployment/#1-system-preparation","title":"1. System Preparation","text":"<pre><code># Update system packages\nsudo apt update &amp;&amp; sudo apt upgrade -y\n\n# Install required system packages\nsudo apt install -y python3.12 python3.12-venv python3-pip nginx redis-server\n\n# Create application user\nsudo useradd -m -s /bin/bash lolstonks\nsudo usermod -aG sudo lolstonks\n</code></pre>"},{"location":"getting-started/deployment/#2-application-setup","title":"2. Application Setup","text":"<pre><code># Switch to application user\nsudo su - lolstonks\n\n# Install UV\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nsource ~/.bashrc\n\n# Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Install dependencies\nuv pip install -e \".[docs]\"\n\n# Create environment file\ncp .env.example .env\nnano .env  # Edit with your configuration\n</code></pre>"},{"location":"getting-started/deployment/#3-environment-configuration","title":"3. Environment Configuration","text":"<p>Create a secure <code>.env</code> file:</p> <pre><code># Production Configuration\nRIOT_API_KEY=RGAPI-your-production-api-key\nRIOT_DEFAULT_REGION=euw1\n\n# Server Configuration\nHOST=127.0.0.1\nPORT=8080\nLOG_LEVEL=INFO\nENVIRONMENT=production\n\n# Redis Configuration\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=your-redis-password\n\n# Rate Limiting (adjust based on your API key limits)\nRIOT_RATE_LIMIT_PER_SECOND=20\nRIOT_RATE_LIMIT_PER_2MIN=100\n\n# Security\nCORS_ORIGINS=https://yourdomain.com\nALLOWED_HOSTS=yourdomain.com\n\n# Monitoring\nENABLE_METRICS=true\nMETRICS_PORT=9090\n</code></pre>"},{"location":"getting-started/deployment/#process-management","title":"Process Management","text":""},{"location":"getting-started/deployment/#systemd-service-recommended","title":"Systemd Service (Recommended)","text":"<p>Create a systemd service file:</p> <pre><code>sudo nano /etc/systemd/system/lolstonks-api.service\n</code></pre> <pre><code>[Unit]\nDescription=LOLStonks API Gateway\nAfter=network.target redis.service\n\n[Service]\nType=exec\nUser=lolstonks\nGroup=lolstonks\nWorkingDirectory=/home/lolstonks/lolstonks-api-gateway\nEnvironment=PATH=/home/lolstonks/.local/bin:/usr/local/bin:/usr/bin:/bin\nEnvironmentFile=/home/lolstonks/lolstonks-api-gateway/.env\nExecStart=/home/lolstonks/.local/bin/uv run uvicorn app.main:app --host 0.0.0.0 --port 8080\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\n\n# Security settings\nNoNewPrivileges=true\nPrivateTmp=true\nProtectSystem=strict\nProtectHome=true\nReadWritePaths=/home/lolstonks/lolstonks-api-gateway/logs\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Enable and start the service:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable lolstonks-api.service\nsudo systemctl start lolstonks-api.service\n</code></pre>"},{"location":"getting-started/deployment/#supervisor-alternative","title":"Supervisor Alternative","text":"<p>If using supervisor, create <code>/etc/supervisor/conf.d/lolstonks-api.conf</code>:</p> <pre><code>[program:lolstonks-api]\ncommand=/home/lolstonks/.local/bin/uv run uvicorn app.main:app --host 0.0.0.0 --port 8080\ndirectory=/home/lolstonks/lolstonks-api-gateway\nuser=lolstonks\nautostart=true\nautorestart=true\nredirect_stderr=true\nstdout_logfile=/var/log/lolstonks/api.log\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nenvironment=PATH=\"/home/lolstonks/.local/bin:/usr/local/bin\"\n</code></pre>"},{"location":"getting-started/deployment/#reverse-proxy-configuration","title":"Reverse Proxy Configuration","text":""},{"location":"getting-started/deployment/#nginx-configuration","title":"Nginx Configuration","text":"<p>Create <code>/etc/nginx/sites-available/lolstonks-api</code>:</p> <pre><code>server {\n    listen 80;\n    server_name yourdomain.com www.yourdomain.com;\n    return 301 https://$server_name$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name yourdomain.com www.yourdomain.com;\n\n    # SSL Configuration\n    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n\n    # Security Headers\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\";\n\n    # Rate Limiting\n    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n    limit_req zone=api burst=20 nodelay;\n\n    location / {\n        proxy_pass http://127.0.0.1:8080;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Timeouts\n        proxy_connect_timeout 30s;\n        proxy_send_timeout 30s;\n        proxy_read_timeout 30s;\n\n        # Buffer settings\n        proxy_buffering on;\n        proxy_buffer_size 4k;\n        proxy_buffers 8 4k;\n    }\n\n    # Health endpoint (no rate limiting)\n    location /health {\n        proxy_pass http://127.0.0.1:8080/health;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n\n    # API documentation\n    location /docs {\n        proxy_pass http://127.0.0.1:8080/docs;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre> <p>Enable the site:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/lolstonks-api /etc/nginx/sites-enabled/\nsudo nginx -t\nsudo systemctl reload nginx\n</code></pre>"},{"location":"getting-started/deployment/#redis-configuration","title":"Redis Configuration","text":""},{"location":"getting-started/deployment/#production-redis-setup","title":"Production Redis Setup","text":"<p>Edit <code>/etc/redis/redis.conf</code>:</p> <pre><code># Security\nbind 127.0.0.1\nrequirepass your-redis-password\nport 6379\n\n# Memory management\nmaxmemory 2gb\nmaxmemory-policy allkeys-lru\n\n# Persistence\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# Logging\nlogfile /var/log/redis/redis-server.log\nloglevel notice\n\n# Performance\ntcp-keepalive 300\ntimeout 0\n</code></pre> <p>Restart Redis:</p> <pre><code>sudo systemctl restart redis-server\nsudo systemctl enable redis-server\n</code></pre>"},{"location":"getting-started/deployment/#ssl-certificate-setup","title":"SSL Certificate Setup","text":""},{"location":"getting-started/deployment/#lets-encrypt-recommended","title":"Let's Encrypt (Recommended)","text":"<pre><code># Install certbot\nsudo apt install certbot python3-certbot-nginx\n\n# Obtain certificate\nsudo certbot --nginx -d yourdomain.com -d www.yourdomain.com\n\n# Set up auto-renewal\nsudo crontab -e\n# Add this line:\n0 12 * * * /usr/bin/certbot renew --quiet\n</code></pre>"},{"location":"getting-started/deployment/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"getting-started/deployment/#log-management","title":"Log Management","text":"<p>Create log directories:</p> <pre><code>sudo mkdir -p /var/log/lolstonks\nsudo chown lolstonks:lolstonks /var/log/lolstonks\n</code></pre> <p>Configure log rotation:</p> <pre><code>sudo nano /etc/logrotate.d/lolstonks-api\n</code></pre> <pre><code>/var/log/lolstonks/*.log {\n    daily\n    missingok\n    rotate 30\n    compress\n    delaycompress\n    notifempty\n    create 644 lolstonks lolstonks\n    postrotate\n        systemctl reload lolstonks-api.service\n    endscript\n}\n</code></pre>"},{"location":"getting-started/deployment/#health-monitoring","title":"Health Monitoring","text":"<p>Set up monitoring for the health endpoint:</p> <pre><code># Simple monitoring script\ncat &gt; /home/lolstonks/health_check.sh &lt;&lt; 'EOF'\n#!/bin/bash\nHEALTH_URL=\"http://127.0.0.1:8080/health\"\nRESPONSE=$(curl -s -o /dev/null -w \"%{http_code}\" $HEALTH_URL)\n\nif [ $RESPONSE -ne 200 ]; then\n    echo \"Health check failed with status $RESPONSE\"\n    # Send alert (configure your preferred alerting method)\n    systemctl restart lolstonks-api.service\nfi\nEOF\n\nchmod +x /home/lolstonks/health_check.sh\n\n# Add to crontab for monitoring every minute\necho \"* * * * * /home/lolstonks/health_check.sh\" | crontab -u lolstonks -\n</code></pre>"},{"location":"getting-started/deployment/#performance-optimization","title":"Performance Optimization","text":""},{"location":"getting-started/deployment/#system-tuning","title":"System Tuning","text":"<pre><code># Increase file descriptor limits\necho \"lolstonks soft nofile 65536\" | sudo tee -a /etc/security/limits.conf\necho \"lolstonks hard nofile 65536\" | sudo tee -a /etc/security/limits.conf\n\n# Optimize network settings\necho \"net.core.somaxconn = 65535\" | sudo tee -a /etc/sysctl.conf\necho \"net.ipv4.tcp_max_syn_backlog = 65535\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n</code></pre>"},{"location":"getting-started/deployment/#application-performance","title":"Application Performance","text":"<p>Update <code>.env</code> for production:</p> <pre><code># Performance settings\nUVICORN_WORKERS=4  # Number of worker processes\nUVICORN_WORKER_CONNECTIONS=1000\nUVICORN_BACKLOG=2048\n\n# Caching settings\nCACHE_TTL_SUMMONER=3600    # 1 hour\nCACHE_TTL_MATCH=86400      # 24 hours\nCACHE_TTL_LEAGUE=1800      # 30 minutes\n</code></pre>"},{"location":"getting-started/deployment/#security-hardening","title":"Security Hardening","text":""},{"location":"getting-started/deployment/#firewall-configuration","title":"Firewall Configuration","text":"<pre><code># Configure UFW firewall\nsudo ufw enable\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\n\n# Allow SSH (change port if needed)\nsudo ufw allow ssh\n\n# Allow HTTP/HTTPS\nsudo ufw allow 80\nsudo ufw allow 443\n\n# Allow Redis only locally\nsudo ufw allow from 127.0.0.1 to any port 6379\n</code></pre>"},{"location":"getting-started/deployment/#application-security","title":"Application Security","text":"<ol> <li>API Key Rotation: Implement regular API key rotation</li> <li>Input Validation: Ensure all inputs are validated (handled by Pydantic)</li> <li>Rate Limiting: Configure appropriate rate limits</li> <li>Access Controls: Implement IP whitelisting if needed</li> <li>Regular Updates: Keep system and dependencies updated</li> </ol>"},{"location":"getting-started/deployment/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"getting-started/deployment/#configuration-backup","title":"Configuration Backup","text":"<pre><code># Create backup script\ncat &gt; /home/lolstonks/backup.sh &lt;&lt; 'EOF'\n#!/bin/bash\nBACKUP_DIR=\"/home/lolstonks/backups\"\nDATE=$(date +%Y%m%d_%H%M%S)\n\nmkdir -p $BACKUP_DIR\n\n# Backup configuration\ntar -czf $BACKUP_DIR/config_$DATE.tar.gz \\\n    /home/lolstonks/lolstonks-api-gateway/.env \\\n    /etc/nginx/sites-available/lolstonks-api \\\n    /etc/systemd/system/lolstonks-api.service\n\n# Keep last 7 days\nfind $BACKUP_DIR -name \"config_*.tar.gz\" -mtime +7 -delete\nEOF\n\nchmod +x /home/lolstonks/backup.sh\n\n# Add to crontab for daily backup at 2 AM\necho \"0 2 * * * /home/lolstonks/backup.sh\" | crontab -u lolstonks -\n</code></pre>"},{"location":"getting-started/deployment/#disaster-recovery","title":"Disaster Recovery","text":"<ol> <li>Documentation: Keep deployment documentation updated</li> <li>Monitoring: Set up alerts for service failures</li> <li>Backups: Regular configuration and code backups</li> <li>Testing: Regular disaster recovery testing</li> </ol>"},{"location":"getting-started/deployment/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"getting-started/deployment/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>For high-traffic deployments:</p> <ol> <li>Load Balancer: Use HAProxy or cloud load balancer</li> <li>Multiple Instances: Run multiple API gateway instances</li> <li>Redis Cluster: Use Redis cluster for distributed caching</li> <li>Database Sharding: Consider database sharding if needed</li> </ol>"},{"location":"getting-started/deployment/#performance-monitoring","title":"Performance Monitoring","text":"<p>Monitor key metrics: - Request rate and response times - Error rates and types - Cache hit rates - Memory and CPU usage - Redis performance</p>"},{"location":"getting-started/deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/deployment/#common-issues","title":"Common Issues","text":"<ol> <li>Service Won't Start: Check logs with <code>journalctl -u lolstonks-api.service</code></li> <li>High Memory Usage: Check Redis memory usage and adjust limits</li> <li>Slow Responses: Check rate limiting and cache performance</li> <li>API Errors: Verify Riot API key and rate limits</li> </ol>"},{"location":"getting-started/deployment/#debug-commands","title":"Debug Commands","text":"<pre><code># Check service status\nsudo systemctl status lolstonks-api.service\n\n# View logs\nsudo journalctl -u lolstonks-api.service -f\n\n# Check Redis\nredis-cli -a your-password ping\n\n# Test API locally\ncurl http://127.0.0.1:8080/health\n\n# Check Nginx configuration\nsudo nginx -t\n\n# Monitor system resources\nhtop\niostat -x 1\n</code></pre> <p>This deployment guide provides a comprehensive foundation for running the LOLStonks API Gateway in production with proper security, monitoring, and scalability considerations.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers different installation methods for the LOLStonks API Gateway.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+ - The gateway requires Python 3.12 or higher</li> <li>Redis Server - Required for caching and match tracking</li> <li>Riot Developer API Key - Get one at developer.riotgames.com</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-using-uv-recommended","title":"Method 1: Using UV (Recommended)","text":"<p>UV is a fast Python package installer and resolver.</p> <pre><code># Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Install the project with documentation dependencies\nuv pip install -e \".[docs]\"\n\n# Activate the virtual environment\nsource .venv/bin/activate  # On Linux/macOS\n# or\n.venv\\Scripts\\activate     # On Windows\n</code></pre>"},{"location":"getting-started/installation/#method-2-using-pip","title":"Method 2: Using Pip","text":"<pre><code># Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Create virtual environment\npython -m venv .venv\n\n# Activate virtual environment\nsource .venv/bin/activate  # On Linux/macOS\n# or\n.venv\\Scripts\\activate     # On Windows\n\n# Upgrade pip\npip install --upgrade pip\n\n# Install the project in development mode\npip install -e \".[docs]\"\n</code></pre>"},{"location":"getting-started/installation/#method-3-docker-quick-start","title":"Method 3: Docker (Quick Start)","text":"<pre><code># Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Copy environment file\ncp .env.example .env\n\n# Edit .env with your Riot API key\n# nano .env\n\n# Start with Docker Compose\ndocker-compose up -d\n\n# Check logs\ndocker-compose logs -f\n</code></pre>"},{"location":"getting-started/installation/#redis-setup","title":"Redis Setup","text":""},{"location":"getting-started/installation/#option-1-docker-recommended-for-development","title":"Option 1: Docker (Recommended for Development)","text":"<pre><code># Start Redis with Docker\ndocker run -d --name redis -p 6379:6379 redis:7-alpine\n\n# Or use Docker Compose (included in project)\ndocker-compose up -d redis\n</code></pre>"},{"location":"getting-started/installation/#option-2-local-installation","title":"Option 2: Local Installation","text":"<pre><code># On Ubuntu/Debian\nsudo apt-get install redis-server\n\n# On macOS with Homebrew\nbrew install redis\n\n# On Windows\n# Download and install Redis from https://redis.io/download\n</code></pre>"},{"location":"getting-started/installation/#option-3-redis-cloud","title":"Option 3: Redis Cloud","text":"<p>For production deployments, consider using managed Redis services: - Redis Cloud - AWS ElastiCache - Azure Cache for Redis</p>"},{"location":"getting-started/installation/#riot-api-key-setup","title":"Riot API Key Setup","text":"<ol> <li>Visit Riot Developer Portal</li> <li>Sign in with your Riot Games account</li> <li>Create a new API key</li> <li>Copy your API key (starts with <code>RGAPI-</code>)</li> </ol>"},{"location":"getting-started/installation/#environment-configuration","title":"Environment Configuration","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code># Required\nRIOT_API_KEY=RGAPI-your-api-key-here\n\n# Optional (defaults shown)\nRIOT_DEFAULT_REGION=euw1\nREDIS_HOST=redis\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=\nHOST=0.0.0.0\nPORT=8080\nLOG_LEVEL=INFO\n\n# Rate limiting (requests per second)\nRATE_LIMIT_RPS=20\nRATE_LIMIT_BURST=100\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":""},{"location":"getting-started/installation/#check-python-environment","title":"Check Python Environment","text":"<pre><code>python --version  # Should show Python 3.12+\npip list | grep fastapi  # Should show FastAPI installed\n</code></pre>"},{"location":"getting-started/installation/#check-redis-connection","title":"Check Redis Connection","text":"<pre><code># Test Redis connection\nredis-cli ping\n# Should return: PONG\n</code></pre>"},{"location":"getting-started/installation/#test-application","title":"Test Application","text":"<pre><code># Start the application\npython -m app.main\n\n# In another terminal, test health endpoint\ncurl http://localhost:8080/health\n# Should return: {\"status\":\"ok\"}\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Python Version Error <pre><code># Error: Python 3.12+ required\npython --version  # Check your Python version\n# Install Python 3.12+ from python.org or pyenv\n</code></pre></p> </li> <li> <p>Redis Connection Failed <pre><code># Check if Redis is running\nredis-cli ping\n\n# Check connection settings in .env\n# Ensure REDIS_HOST and REDIS_PORT are correct\n</code></pre></p> </li> <li> <p>Import Errors <pre><code># Reinstall dependencies (using UV - recommended)\nuv pip install -e \".[docs]\"\n# or using pip:\npip install -e \".[docs]\"\n\n# Check virtual environment activation\nwhich python  # Should point to your venv\n</code></pre></p> </li> <li> <p>Permission Errors <pre><code># On Linux/macOS, check file permissions\nchmod +x scripts/*.py\n\n# On Windows, run as administrator if needed\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues during installation:</p> <ol> <li>Check the GitHub Issues</li> <li>Review the Troubleshooting Guide</li> <li>Create a new issue with:</li> <li>Your operating system</li> <li>Python version</li> <li>Error messages</li> <li>Steps to reproduce</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Read the Quick Start guide</li> <li>Configure your environment variables</li> <li>Explore the API Reference</li> <li>Set up development tools</li> </ol>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with the LOLStonks API Gateway in minutes.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Installation completed (see Installation Guide)</li> <li>\u2705 Redis server running</li> <li>\u2705 Riot API key configured in <code>.env</code></li> </ul>"},{"location":"getting-started/quick-start/#start-the-gateway","title":"Start the Gateway","text":""},{"location":"getting-started/quick-start/#option-1-development-mode","title":"Option 1: Development Mode","text":"<pre><code># Activate virtual environment\nsource .venv/bin/activate  # Linux/macOS\n# or\n.venv\\Scripts\\activate     # Windows\n\n# Start the server\npython -m app.main\n</code></pre>"},{"location":"getting-started/quick-start/#option-2-production-mode","title":"Option 2: Production Mode","text":"<pre><code># Using uvicorn directly\nuvicorn app.main:app --host 0.0.0.0 --port 8080\n\n# Using gunicorn (production)\ngunicorn app.main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8080\n</code></pre>"},{"location":"getting-started/quick-start/#option-3-docker","title":"Option 3: Docker","text":"<pre><code># Using docker-compose\ndocker-compose up -d\n\n# Check logs\ndocker-compose logs -f api-gateway\n</code></pre>"},{"location":"getting-started/quick-start/#verify-installation","title":"Verify Installation","text":""},{"location":"getting-started/quick-start/#health-check","title":"Health Check","text":"<pre><code>curl http://localhost:8080/health\n# Expected response: {\"status\":\"ok\"}\n</code></pre>"},{"location":"getting-started/quick-start/#interactive-documentation","title":"Interactive Documentation","text":"<p>Open your browser and navigate to: - Swagger UI: http://localhost:8080/docs - ReDoc: http://localhost:8080/redoc</p>"},{"location":"getting-started/quick-start/#basic-usage-examples","title":"Basic Usage Examples","text":""},{"location":"getting-started/quick-start/#1-get-summoner-information","title":"1. Get Summoner Information","text":"<pre><code># Get summoner by name\ncurl \"http://localhost:8080/summoner/by-name/Faker?region=kr\"\n\n# Response example\n{\n  \"id\": \"KqOw12p4b3bLp5b6p7\",\n  \"accountId\": \"3b3Lp5b6p7KqOw12p4b\",\n  \"puuid\": \"p7KqOw12p4b3bLp5b6p7\",\n  \"name\": \"Faker\",\n  \"profileIconId\": 3188,\n  \"revisionDate\": 1678901234567,\n  \"summonerLevel\": 523\n}\n</code></pre>"},{"location":"getting-started/quick-start/#2-get-current-match","title":"2. Get Current Match","text":"<pre><code># Get active game for a summoner\ncurl \"http://localhost:8080/spectator/active-game/KqOw12p4b3bLp5b6p7?region=kr\"\n\n# Response contains game information\n{\n  \"gameId\": 1234567890,\n  \"gameMode\": \"CLASSIC\",\n  \"gameQueueConfigId\": 420,\n  \"participants\": [...],\n  \"gameLength\": 542,\n  \"gameStartTime\": 1678901234567\n}\n</code></pre>"},{"location":"getting-started/quick-start/#3-get-match-history","title":"3. Get Match History","text":"<pre><code># Get recent match IDs\ncurl \"http://localhost:8080/match/ids/by-puuid/p7KqOw12p4b3bLp5b6p7?region=kr&amp;count=5\"\n\n# Response: Array of match IDs\n[\"KR_1234567890\", \"KR_1234567891\", \"KR_1234567892\", \"KR_1234567893\", \"KR_1234567894\"]\n</code></pre>"},{"location":"getting-started/quick-start/#4-get-league-information","title":"4. Get League Information","text":"<pre><code># Get challenger league\ncurl \"http://localhost:8080/league/challenger/RANKED_SOLO_5x5?region=kr\"\n\n# Get master league\ncurl \"http://localhost:8080/league/master/RANKED_SOLO_5x5?region=kr\"\n</code></pre>"},{"location":"getting-started/quick-start/#5-get-champion-mastery","title":"5. Get Champion Mastery","text":"<pre><code># Get top masteries for summoner\ncurl \"http://localhost:8080/champion-mastery/top/KqOw12p4b3bLp5b6p7?region=kr&amp;count=5\"\n\n# Get mastery for specific champion\ncurl \"http://localhost:8080/champion-mastery/by-champion/KqOw12p4b3bLp5b6p7/157?region=kr\"\n</code></pre>"},{"location":"getting-started/quick-start/#python-client-examples","title":"Python Client Examples","text":""},{"location":"getting-started/quick-start/#using-httpx-recommended","title":"Using httpx (Recommended)","text":"<pre><code>import httpx\nimport asyncio\n\nasync def get_summoner_data():\n    \"\"\"Get basic summoner information\"\"\"\n    async with httpx.AsyncClient() as client:\n        # Get summoner by name\n        response = await client.get(\n            \"http://localhost:8080/summoner/by-name/Faker\",\n            params={\"region\": \"kr\"}\n        )\n        summoner = response.json()\n        print(f\"Summoner: {summoner['name']} (Level: {summoner['summonerLevel']})\")\n\n        # Get current match\n        response = await client.get(\n            f\"http://localhost:8080/spectator/active-game/{summoner['id']}\",\n            params={\"region\": \"kr\"}\n        )\n\n        if response.status_code == 200:\n            game = response.json()\n            print(f\"Currently in game: {game['gameMode']}\")\n        else:\n            print(\"Not currently in a game\")\n\n# Run the example\nasyncio.run(get_summoner_data())\n</code></pre>"},{"location":"getting-started/quick-start/#using-requests-synchronous","title":"Using requests (Synchronous)","text":"<pre><code>import requests\n\ndef get_league_data():\n    \"\"\"Get challenger league information\"\"\"\n    response = requests.get(\n        \"http://localhost:8080/league/challenger/RANKED_SOLO_5x5\",\n        params={\"region\": \"euw1\"}\n    )\n\n    if response.status_code == 200:\n        league = response.json()\n        print(f\"League: {league['name']}\")\n        print(f\"Tier: {league['tier']}\")\n        print(f\"Number of players: {len(league['entries'])}\")\n\n        # Show top 3 players\n        for i, entry in enumerate(league['entries'][:3], 1):\n            print(f\"{i}. {entry['summonerName']} - {entry['leaguePoints']} LP\")\n\nget_league_data()\n</code></pre>"},{"location":"getting-started/quick-start/#common-operations","title":"Common Operations","text":""},{"location":"getting-started/quick-start/#batch-operations","title":"Batch Operations","text":"<pre><code>import asyncio\nimport httpx\n\nasync def get_multiple_summoners(names, region=\"kr\"):\n    \"\"\"Get data for multiple summoners concurrently\"\"\"\n    async with httpx.AsyncClient() as client:\n        tasks = []\n        for name in names:\n            task = client.get(\n                \"http://localhost:8080/summoner/by-name/\" + name,\n                params={\"region\": region}\n            )\n            tasks.append(task)\n\n        responses = await asyncio.gather(*tasks)\n        return [r.json() for r in responses if r.status_code == 200]\n\n# Usage\nsummoners = asyncio.run(get_multiple_summoners([\"Faker\", \"ShowMaker\", \"Canyon\"]))\nfor summoner in summoners:\n    print(f\"{summoner['name']}: Level {summoner['summonerLevel']}\")\n</code></pre>"},{"location":"getting-started/quick-start/#error-handling","title":"Error Handling","text":"<pre><code>import httpx\n\nasync def safe_api_call(endpoint, params=None):\n    \"\"\"Safe API call with error handling\"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"http://localhost:8080{endpoint}\",\n                params=params\n            )\n            response.raise_for_status()\n            return response.json()\n\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            print(\"Resource not found\")\n        elif e.response.status_code == 429:\n            print(\"Rate limit exceeded - please wait\")\n        elif e.response.status_code == 503:\n            print(\"Service temporarily unavailable\")\n        else:\n            print(f\"HTTP error: {e.response.status_code}\")\n        return None\n\n    except httpx.RequestError as e:\n        print(f\"Request error: {e}\")\n        return None\n\n# Usage\ndata = await safe_api_call(\"/summoner/by-name/Faker\", {\"region\": \"kr\"})\nif data:\n    print(f\"Successfully retrieved: {data['name']}\")\n</code></pre>"},{"location":"getting-started/quick-start/#monitoring-the-gateway","title":"Monitoring the Gateway","text":""},{"location":"getting-started/quick-start/#health-checks","title":"Health Checks","text":"<pre><code># Basic health check\ncurl http://localhost:8080/health\n\n# Check specific endpoints\ncurl http://localhost:8080/docs  # Should load Swagger UI\ncurl http://localhost:8080/redoc  # Should load ReDoc\n</code></pre>"},{"location":"getting-started/quick-start/#log-monitoring","title":"Log Monitoring","text":"<pre><code># View application logs\npython -m app.main  # Logs will appear in console\n\n# Or use docker logs if running with Docker\ndocker-compose logs -f api-gateway\n</code></pre>"},{"location":"getting-started/quick-start/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use Appropriate Cache TTLs: Configure cache durations based on data volatility</li> <li>Batch Requests: Use concurrent requests for multiple API calls</li> <li>Region Selection: Use the correct region parameter for optimal performance</li> <li>Error Handling: Implement proper retry logic and error handling</li> <li>Rate Limit Awareness: Be mindful of Riot's rate limits</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Configuration Guide for advanced settings</li> <li>Explore the complete API Reference</li> <li>Set up development tools</li> <li>Review the Architecture Overview</li> </ul>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues:</p> <ol> <li>Connection Refused: Check if the gateway is running on the correct port</li> <li>401 Unauthorized: Verify your Riot API key in the <code>.env</code> file</li> <li>404 Not Found: Check the endpoint path and parameters</li> <li>429 Rate Limited: The gateway handles this automatically, but you may need to wait</li> <li>503 Service Unavailable: Riot API may be temporarily down</li> </ol> <p>For more help, see the Development Documentation.</p>"},{"location":"operations/implementation-status/","title":"Implementation Status","text":"<p>This document provides a clear overview of which features described in the Operations documentation are currently implemented versus potential future enhancements.</p> <p>Last Updated: 2025-10-29</p>"},{"location":"operations/implementation-status/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Monitoring &amp; Observability</li> <li>Security</li> <li>Summary Table</li> <li>How to Read This Document</li> </ul>"},{"location":"operations/implementation-status/#monitoring-observability","title":"Monitoring &amp; Observability","text":""},{"location":"operations/implementation-status/#currently-implemented","title":"\u2705 Currently Implemented","text":"Feature Description Location Basic Health Check Simple <code>/health</code> endpoint returning <code>{\"status\": \"ok\"}</code> <code>app/routers/health.py</code> Loguru Logging Colored console logging with configurable log levels <code>app/main.py:28-35</code> Startup/Shutdown Logging Application lifecycle event logging <code>app/main.py:38-59</code> Error Logging Automatic exception logging via Loguru Throughout app"},{"location":"operations/implementation-status/#not-yet-implemented-documented-as-potential-enhancements","title":"\u274c Not Yet Implemented (Documented as Potential Enhancements)","text":"Feature Description Documentation Prometheus Metrics Request counters, histograms, gauges <code>monitoring.md</code> - Custom Metrics Implementation Grafana Dashboards Visual monitoring dashboards <code>monitoring.md</code> - Grafana Dashboard Advanced Health Checks Redis connectivity, Riot API status, system resources <code>monitoring.md</code> - Comprehensive Health Endpoint ELK Stack Integration Elasticsearch, Logstash, Kibana for log aggregation <code>monitoring.md</code> - Log Management OpenTelemetry Tracing Distributed tracing with Jaeger <code>monitoring.md</code> - Advanced Monitoring JSON Structured Logging Custom JSON formatter for logs <code>monitoring.md</code> - Logging Strategy Request Logging Middleware Detailed request/response logging <code>monitoring.md</code> - Request Logging Middleware Custom Business Metrics Summoner lookups, match lookups, API usage tracking <code>monitoring.md</code> - Custom Metrics Alert Configuration Prometheus alerting rules <code>monitoring.md</code> - Alerting Notification Channels Email/Slack alerts via Alertmanager <code>monitoring.md</code> - Notification Channels"},{"location":"operations/implementation-status/#security","title":"Security","text":""},{"location":"operations/implementation-status/#currently-implemented_1","title":"\u2705 Currently Implemented","text":"Feature Description Location Pydantic Input Validation Type validation and constraints on all inputs <code>app/models/*.py</code> Enum Validation Region, queue type, tier validation via Python Enums <code>app/models/common.py</code> Riot API Rate Limiting Token bucket rate limiting for Riot API calls <code>app/riot/rate_limiter.py</code> Environment Variable Configuration API keys loaded from <code>.env</code> file <code>app/config.py</code> Redis Password Auth Optional password for Redis connection <code>app/config.py:27</code>"},{"location":"operations/implementation-status/#partially-implemented-infrastructure-level","title":"\u26a0\ufe0f Partially Implemented / Infrastructure Level","text":"Feature Description Status SSL/TLS HTTPS encryption \u26a0\ufe0f Handled by Nginx (infrastructure level) Firewall Rules Network-level access control \u26a0\ufe0f System-level (ufw/iptables) Security Headers HSTS, X-Frame-Options, CSP, etc. \u26a0\ufe0f Configured in Nginx, not app"},{"location":"operations/implementation-status/#not-yet-implemented-documented-as-potential-enhancements_1","title":"\u274c Not Yet Implemented (Documented as Potential Enhancements)","text":"Feature Description Documentation API Key Rotation Automated key rotation system <code>security.md</code> - Key Rotation Strategy Advanced Input Sanitization SecurityValidator class for string sanitization <code>security.md</code> - Advanced Input Sanitization IP-Based Rate Limiting Per-IP request throttling with slowapi <code>security.md</code> - Multi-Level Rate Limiting IP Blocking System Automatic blocking of malicious IPs <code>security.md</code> - IP-Based Blocking CORS Middleware Cross-origin resource sharing configuration <code>security.md</code> - CORS Configuration HTTPS Redirect Middleware Force HTTPS in production <code>security.md</code> - Application SSL Settings TrustedHost Middleware Restrict allowed hostnames <code>security.md</code> - Application SSL Settings Admin API Authentication API key auth for admin endpoints <code>security.md</code> - API Key Authentication Security Event Logging Dedicated security log file <code>security.md</code> - Security Logging Security Metrics Prometheus metrics for security events <code>security.md</code> - Security Monitoring Automated Security Audits Scheduled security check scripts <code>security.md</code> - Regular Security Checks"},{"location":"operations/implementation-status/#summary-table","title":"Summary Table","text":""},{"location":"operations/implementation-status/#overall-implementation-status","title":"Overall Implementation Status","text":"Category Implemented Not Implemented Percentage Monitoring &amp; Observability 4 features 10 features 29% Security 5 features 11 features 31% Infrastructure 3 features 0 features 100% (external) Overall 12 features 21 features 36%"},{"location":"operations/implementation-status/#feature-categories-by-status","title":"Feature Categories by Status","text":""},{"location":"operations/implementation-status/#production-ready-currently-implemented","title":"\u2705 Production Ready (Currently Implemented)","text":"<p>These features are fully implemented and tested:</p> <ol> <li>Basic health check endpoint</li> <li>Loguru logging system</li> <li>Pydantic input validation</li> <li>Riot API rate limiting (aiolimiter)</li> <li>Environment-based configuration</li> <li>Redis password authentication</li> </ol>"},{"location":"operations/implementation-status/#infrastructure-level-external-to-application","title":"\u26a0\ufe0f Infrastructure Level (External to Application)","text":"<p>These are handled at deployment/infrastructure level:</p> <ol> <li>SSL/TLS (Nginx)</li> <li>Firewall rules (ufw/iptables)</li> <li>Security headers (Nginx)</li> </ol>"},{"location":"operations/implementation-status/#potential-future-enhancements","title":"\u274c Potential Future Enhancements","text":"<p>These are documented but not implemented:</p> <ol> <li>Prometheus + Grafana monitoring stack</li> <li>ELK stack for log aggregation</li> <li>OpenTelemetry distributed tracing</li> <li>IP-based rate limiting and blocking</li> <li>CORS middleware</li> <li>Security event logging</li> <li>API key rotation automation</li> <li>Admin endpoint authentication</li> <li>Advanced health checks</li> <li>Custom business metrics</li> </ol>"},{"location":"operations/implementation-status/#how-to-read-this-document","title":"How to Read This Document","text":""},{"location":"operations/implementation-status/#status-indicators","title":"Status Indicators","text":"<ul> <li>\u2705 Currently Implemented: Fully functional in the codebase</li> <li>\u26a0\ufe0f Partially Implemented: Basic version exists or handled externally</li> <li>\u274c Not Implemented: Documented as potential enhancement only</li> </ul>"},{"location":"operations/implementation-status/#documentation-cross-references","title":"Documentation Cross-References","text":"<p>When a feature shows \"Not Implemented\", refer to the linked documentation to see: - Why it might be useful (benefits, use cases) - How it could be implemented (code examples, configurations) - When to implement it (recommended for production, optional, etc.)</p>"},{"location":"operations/implementation-status/#implementation-priority-levels","title":"Implementation Priority Levels","text":"<p>Based on production requirements:</p>"},{"location":"operations/implementation-status/#priority-1-consider-for-production","title":"Priority 1: Consider for Production \ud83d\udd34","text":"<ul> <li>Prometheus + Grafana: Essential for production monitoring</li> <li>Advanced Health Checks: Important for load balancer integration</li> <li>Security Event Logging: Critical for audit trails</li> <li>CORS Middleware: Required if serving web frontends</li> </ul>"},{"location":"operations/implementation-status/#priority-2-recommended-enhancements","title":"Priority 2: Recommended Enhancements \ud83d\udfe1","text":"<ul> <li>IP-Based Rate Limiting: Prevents abuse from individual users</li> <li>ELK Stack: Helpful for large-scale deployments</li> <li>OpenTelemetry: Useful for microservice architectures</li> <li>API Key Rotation: Good security practice</li> </ul>"},{"location":"operations/implementation-status/#priority-3-nice-to-have","title":"Priority 3: Nice to Have \ud83d\udfe2","text":"<ul> <li>Custom Business Metrics: Useful but not critical</li> <li>Automated Security Audits: Can be done manually</li> <li>Admin API Authentication: Only if admin features exist</li> </ul>"},{"location":"operations/implementation-status/#development-roadmap","title":"Development Roadmap","text":""},{"location":"operations/implementation-status/#phase-1-core-monitoring-recommended-for-production","title":"Phase 1: Core Monitoring (Recommended for Production)","text":"<ol> <li>Implement Prometheus metrics endpoint</li> <li>Create basic Grafana dashboard</li> <li>Add advanced health checks (Redis, Riot API status)</li> <li>Set up basic alerting rules</li> </ol> <p>Estimated Effort: 2-3 days Priority: High</p>"},{"location":"operations/implementation-status/#phase-2-enhanced-security-recommended-for-production","title":"Phase 2: Enhanced Security (Recommended for Production)","text":"<ol> <li>Implement IP-based rate limiting</li> <li>Add CORS middleware</li> <li>Set up security event logging</li> <li>Create security metrics</li> </ol> <p>Estimated Effort: 2-3 days Priority: High</p>"},{"location":"operations/implementation-status/#phase-3-advanced-features-optional","title":"Phase 3: Advanced Features (Optional)","text":"<ol> <li>ELK stack integration</li> <li>OpenTelemetry distributed tracing</li> <li>API key rotation automation</li> <li>Admin endpoint authentication</li> </ol> <p>Estimated Effort: 5-7 days Priority: Medium-Low</p>"},{"location":"operations/implementation-status/#contributing","title":"Contributing","text":"<p>If you implement any of the \"Not Yet Implemented\" features:</p> <ol> <li>Update this document to move the feature to \"Currently Implemented\"</li> <li>Add location in codebase (file:line)</li> <li>Update the documentation to reflect actual implementation</li> <li>Add tests for the new feature</li> <li>Update the percentage in the summary table</li> </ol>"},{"location":"operations/implementation-status/#notes","title":"Notes","text":""},{"location":"operations/implementation-status/#why-document-unimplemented-features","title":"Why Document Unimplemented Features?","text":"<p>The Operations documentation includes best practices and potential implementations for several reasons:</p> <ol> <li>Educational Value: Shows what a production-ready system looks like</li> <li>Future Planning: Provides a roadmap for enhancements</li> <li>Architecture Decisions: Helps understand why certain features might be needed</li> <li>Copy-Paste Ready: Code examples can be adapted when implementing</li> </ol>"},{"location":"operations/implementation-status/#keeping-documentation-and-code-in-sync","title":"Keeping Documentation and Code in Sync","text":"<ul> <li>\u2705 This document bridges the gap between documentation and reality</li> <li>\u2705 Clear labels (\"NOT IMPLEMENTED\", \"Example:\") in code blocks</li> <li>\u2705 Disclaimer banners in documentation files</li> <li>\u2705 Regular updates to this status document</li> </ul> <p>Last Updated: 2025-10-29 For questions or updates, see the contributing guide.</p>"},{"location":"operations/monitoring/","title":"Monitoring and Observability","text":"<p>This guide covers monitoring, logging, and observability for the LOLStonks API Gateway in production environments.</p> <p>\ud83d\udcdd Documentation Note: This document describes best practices and potential implementations for production monitoring. Many of these features represent future enhancements rather than current implementation.</p> <p>Currently Implemented \u2705: - Basic health check endpoint (<code>/health</code> returns <code>{\"status\": \"ok\"}</code>) - Loguru logging to stderr - Basic application startup/shutdown logging</p> <p>Not Yet Implemented \u274c (Potential Future Enhancements): - Prometheus metrics collection - Grafana dashboards - ELK stack integration - OpenTelemetry distributed tracing - Advanced health checks (Redis/Riot API status) - Custom metrics middleware</p> <p>For actual implementation details, see Implementation Details.</p>"},{"location":"operations/monitoring/#overview","title":"Overview","text":"<p>Effective monitoring ensures: - Proactive Issue Detection: Identify problems before users notice - Performance Optimization: Track and optimize system performance - Capacity Planning: Understand resource usage and scaling needs - Security Monitoring: Detect unusual activity and potential threats</p>"},{"location":"operations/monitoring/#core-monitoring-components","title":"Core Monitoring Components","text":""},{"location":"operations/monitoring/#1-application-metrics","title":"1. Application Metrics","text":""},{"location":"operations/monitoring/#key-performance-indicators-kpis","title":"Key Performance Indicators (KPIs)","text":"Metric Description Target Alert Threshold Request Rate API requests per second Variable &gt; 1000 req/s Response Time Average API response time &lt; 200ms &gt; 500ms Error Rate Percentage of failed requests &lt; 1% &gt; 5% Cache Hit Rate Percentage of requests served from cache &gt; 80% &lt; 60% Memory Usage Application memory consumption &lt; 2GB &gt; 3GB CPU Usage Application CPU utilization &lt; 70% &gt; 85%"},{"location":"operations/monitoring/#custom-metrics-implementation","title":"Custom Metrics Implementation","text":"<p>\ud83d\udca1 Potential Implementation: The code below shows how to implement Prometheus metrics. This is not currently implemented in the codebase.</p> <pre><code># Example: app/monitoring.py (NOT IMPLEMENTED)\nfrom prometheus_client import Counter, Histogram, Gauge, generate_latest\nimport time\nimport logging\n\n# Define metrics\nREQUEST_COUNT = Counter(\n    'lolstonks_requests_total',\n    'Total number of API requests',\n    ['method', 'endpoint', 'status']\n)\n\nREQUEST_DURATION = Histogram(\n    'lolstonks_request_duration_seconds',\n    'Request duration in seconds',\n    ['method', 'endpoint']\n)\n\nCACHE_HIT_RATE = Gauge(\n    'lolstonks_cache_hit_rate',\n    'Cache hit rate percentage'\n)\n\nACTIVE_CONNECTIONS = Gauge(\n    'lolstonks_active_connections',\n    'Number of active connections'\n)\n\nclass MetricsMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] == \"http\":\n            start_time = time.time()\n\n            # Process request\n            await self.app(scope, receive, send)\n\n            # Record metrics\n            duration = time.time() - start_time\n            REQUEST_DURATION.labels(\n                method=scope[\"method\"],\n                endpoint=scope[\"path\"]\n            ).observe(duration)\n\n            REQUEST_COUNT.labels(\n                method=scope[\"method\"],\n                endpoint=scope[\"path\"],\n                status=\"200\"  # Would be set from actual response\n            ).inc()\n        else:\n            await self.app(scope, receive, send)\n</code></pre>"},{"location":"operations/monitoring/#2-health-checks","title":"2. Health Checks","text":""},{"location":"operations/monitoring/#current-implementation","title":"Current Implementation","text":"<p>The actual health check endpoint is very simple:</p> <pre><code># app/routers/health.py (ACTUAL IMPLEMENTATION)\n@router.get(\"/health\")\nasync def health():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"operations/monitoring/#comprehensive-health-endpoint-potential-enhancement","title":"Comprehensive Health Endpoint (Potential Enhancement)","text":"<p>\ud83d\udca1 Potential Implementation: Below is an example of an advanced health check. This is not currently implemented.</p> <pre><code># Example: Comprehensive health check (NOT IMPLEMENTED)\nfrom fastapi import APIRouter, Depends\nfrom app.cache.redis_cache import RedisCache\nfrom app.riot.client import RiotClient\nimport asyncio\nimport time\n\nrouter = APIRouter()\n\n@router.get(\"/health\")\nasync def health_check():\n    \"\"\"Comprehensive health check endpoint.\"\"\"\n    start_time = time.time()\n\n    health_status = {\n        \"status\": \"healthy\",\n        \"timestamp\": time.time(),\n        \"version\": \"1.0.0\",\n        \"checks\": {},\n        \"duration_ms\": 0\n    }\n\n    # Check Redis\n    try:\n        redis_health = await check_redis_health()\n        health_status[\"checks\"][\"redis\"] = redis_health\n    except Exception as e:\n        health_status[\"checks\"][\"redis\"] = {\n            \"status\": \"unhealthy\",\n            \"error\": str(e)\n        }\n        health_status[\"status\"] = \"degraded\"\n\n    # Check Riot API connectivity\n    try:\n        riot_health = await check_riot_api_health()\n        health_status[\"checks\"][\"riot_api\"] = riot_health\n    except Exception as e:\n        health_status[\"checks\"][\"riot_api\"] = {\n            \"status\": \"unhealthy\",\n            \"error\": str(e)\n        }\n        health_status[\"status\"] = \"degraded\"\n\n    # Check system resources\n    try:\n        system_health = check_system_health()\n        health_status[\"checks\"][\"system\"] = system_health\n    except Exception as e:\n        health_status[\"checks\"][\"system\"] = {\n            \"status\": \"unhealthy\",\n            \"error\": str(e)\n        }\n        health_status[\"status\"] = \"unhealthy\"\n\n    health_status[\"duration_ms\"] = int((time.time() - start_time) * 1000)\n\n    return health_status\n\nasync def check_redis_health():\n    \"\"\"Check Redis connectivity and performance.\"\"\"\n    cache = RedisCache()\n\n    # Test basic connectivity\n    start_time = time.time()\n    await cache.set(\"health_check\", \"ok\", ttl=10)\n    result = await cache.get(\"health_check\")\n    duration = time.time() - start_time\n\n    if result != \"ok\":\n        raise Exception(\"Redis read/write test failed\")\n\n    # Get Redis info\n    import redis\n    redis_client = redis.Redis(\n        host=cache.redis_host,\n        port=cache.redis_port,\n        password=cache.redis_password,\n        decode_responses=True\n    )\n\n    info = redis_client.info()\n\n    return {\n        \"status\": \"healthy\",\n        \"response_time_ms\": int(duration * 1000),\n        \"memory_usage\": info.get(\"used_memory_human\"),\n        \"connected_clients\": info.get(\"connected_clients\"),\n        \"uptime_seconds\": info.get(\"uptime_in_seconds\")\n    }\n\nasync def check_riot_api_health():\n    \"\"\"Check Riot API connectivity.\"\"\"\n    client = RiotClient()\n\n    start_time = time.time()\n    response = await client.get(\n        \"/lol/status/v4/platform-data\",\n        region=\"na1\"\n    )\n    duration = time.time() - start_time\n\n    if response.status_code != 200:\n        raise Exception(f\"Riot API returned status {response.status_code}\")\n\n    return {\n        \"status\": \"healthy\",\n        \"response_time_ms\": int(duration * 1000),\n        \"status_code\": response.status_code\n    }\n\ndef check_system_health():\n    \"\"\"Check system resources.\"\"\"\n    import psutil\n\n    # CPU usage\n    cpu_percent = psutil.cpu_percent(interval=1)\n\n    # Memory usage\n    memory = psutil.virtual_memory()\n    disk = psutil.disk_usage('/')\n\n    # Network connections\n    connections = len(psutil.net_connections())\n\n    system_health = {\n        \"status\": \"healthy\",\n        \"cpu_percent\": cpu_percent,\n        \"memory_percent\": memory.percent,\n        \"memory_available_gb\": round(memory.available / (1024**3), 2),\n        \"disk_percent\": disk.percent,\n        \"disk_free_gb\": round(disk.free / (1024**3), 2),\n        \"network_connections\": connections\n    }\n\n    # Determine overall status\n    if cpu_percent &gt; 90 or memory.percent &gt; 90 or disk.percent &gt; 90:\n        system_health[\"status\"] = \"critical\"\n    elif cpu_percent &gt; 80 or memory.percent &gt; 80 or disk.percent &gt; 80:\n        system_health[\"status\"] = \"warning\"\n\n    return system_health\n</code></pre>"},{"location":"operations/monitoring/#3-logging-strategy","title":"3. Logging Strategy","text":""},{"location":"operations/monitoring/#current-implementation_1","title":"Current Implementation","text":"<p>The application uses Loguru for logging:</p> <pre><code># app/main.py (ACTUAL IMPLEMENTATION)\nfrom loguru import logger\n\nlogger.remove()  # Remove default handler\nlogger.add(\n    sys.stderr,\n    format=\"&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss}&lt;/green&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;\",\n    level=settings.log_level,\n    colorize=True,\n)\n</code></pre>"},{"location":"operations/monitoring/#structured-logging-configuration-potential-enhancement","title":"Structured Logging Configuration (Potential Enhancement)","text":"<p>\ud83d\udca1 Potential Implementation: Below is an example of JSON structured logging. This is not currently implemented.</p> <pre><code># Example: app/logging_config.py (NOT IMPLEMENTED)\nimport logging\nimport json\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\n\nclass JSONFormatter(logging.Formatter):\n    def format(self, record):\n        log_entry = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"message\": record.getMessage(),\n            \"module\": record.module,\n            \"function\": record.funcName,\n            \"line\": record.lineno\n        }\n\n        # Add exception info if present\n        if record.exc_info:\n            log_entry[\"exception\"] = self.formatException(record.exc_info)\n\n        # Add extra fields\n        for key, value in record.__dict__.items():\n            if key not in ['name', 'msg', 'args', 'levelname', 'levelno',\n                          'pathname', 'filename', 'module', 'exc_info',\n                          'exc_text', 'stack_info', 'lineno', 'funcName',\n                          'created', 'msecs', 'relativeCreated', 'thread',\n                          'threadName', 'processName', 'process', 'message']:\n                log_entry[key] = value\n\n        return json.dumps(log_entry)\n\ndef setup_logging():\n    \"\"\"Configure structured logging for the application.\"\"\"\n\n    # Create logs directory\n    log_dir = Path(\"/var/log/lolstonks\")\n    log_dir.mkdir(exist_ok=True)\n\n    # Configure root logger\n    logging.basicConfig(\n        level=logging.INFO,\n        handlers=[\n            logging.StreamHandler(sys.stdout),\n            logging.FileHandler(log_dir / \"api.log\")\n        ]\n    )\n\n    # Set JSON formatter for all handlers\n    for handler in logging.root.handlers:\n        handler.setFormatter(JSONFormatter())\n\n    # Configure specific loggers\n    loggers = [\n        \"uvicorn.access\",\n        \"uvicorn.error\",\n        \"app.riot.client\",\n        \"app.cache.redis_cache\"\n    ]\n\n    for logger_name in loggers:\n        logger = logging.getLogger(logger_name)\n        logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"operations/monitoring/#request-logging-middleware","title":"Request Logging Middleware","text":"<pre><code># app/middleware.py\nimport time\nimport uuid\nfrom fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass RequestLoggingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        # Generate unique request ID\n        request_id = str(uuid.uuid4())\n\n        # Log request start\n        start_time = time.time()\n\n        logger = logging.getLogger(\"request\")\n        logger.info(\n            \"Request started\",\n            extra={\n                \"request_id\": request_id,\n                \"method\": request.method,\n                \"url\": str(request.url),\n                \"client_ip\": request.client.host,\n                \"user_agent\": request.headers.get(\"user-agent\")\n            }\n        )\n\n        try:\n            # Process request\n            response = await call_next(request)\n\n            # Calculate duration\n            duration = time.time() - start_time\n\n            # Log request completion\n            logger.info(\n                \"Request completed\",\n                extra={\n                    \"request_id\": request_id,\n                    \"method\": request.method,\n                    \"url\": str(request.url),\n                    \"status_code\": response.status_code,\n                    \"duration_ms\": int(duration * 1000),\n                    \"response_size\": response.headers.get(\"content-length\", 0)\n                }\n            )\n\n            # Add request ID to response headers\n            response.headers[\"X-Request-ID\"] = request_id\n\n            return response\n\n        except Exception as e:\n            # Log request error\n            duration = time.time() - start_time\n            logger.error(\n                \"Request failed\",\n                extra={\n                    \"request_id\": request_id,\n                    \"method\": request.method,\n                    \"url\": str(request.url),\n                    \"duration_ms\": int(duration * 1000),\n                    \"error\": str(e),\n                    \"error_type\": type(e).__name__\n                }\n            )\n            raise\n</code></pre>"},{"location":"operations/monitoring/#monitoring-setup","title":"Monitoring Setup","text":"<p>\ud83d\udca1 Section Note: The monitoring tools described below (Prometheus, Grafana, ELK, OpenTelemetry) are not currently implemented. These are best practices and examples for potential future implementation.</p>"},{"location":"operations/monitoring/#prometheus-configuration","title":"Prometheus Configuration","text":"<p>Not Implemented: Prometheus is not currently set up for this project.</p>"},{"location":"operations/monitoring/#prometheusyml-example-configuration","title":"prometheus.yml (Example Configuration)","text":"<pre><code>global:\n  scrape_interval: 15s\n  evaluation_interval: 15s\n\nrule_files:\n  - \"alert_rules.yml\"\n\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n          - alertmanager:9093\n\nscrape_configs:\n  - job_name: 'lolstonks-api'\n    static_configs:\n      - targets: ['localhost:9090']\n    metrics_path: '/metrics'\n    scrape_interval: 5s\n    scrape_timeout: 5s\n\n  - job_name: 'redis'\n    static_configs:\n      - targets: ['localhost:9121']\n\n  - job_name: 'node'\n    static_configs:\n      - targets: ['localhost:9100']\n</code></pre>"},{"location":"operations/monitoring/#alert-rules","title":"Alert Rules","text":"<pre><code># alert_rules.yml\ngroups:\n  - name: lolstonks_alerts\n    rules:\n      - alert: HighErrorRate\n        expr: rate(lolstonks_requests_total{status!~\"2..\"}[5m]) / rate(lolstonks_requests_total[5m]) &gt; 0.05\n        for: 2m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High error rate detected\"\n          description: \"Error rate is {{ $value | humanizePercentage }} for the last 5 minutes\"\n\n      - alert: HighResponseTime\n        expr: histogram_quantile(0.95, rate(lolstonks_request_duration_seconds_bucket[5m])) &gt; 0.5\n        for: 2m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High response time detected\"\n          description: \"95th percentile response time is {{ $value }}s\"\n\n      - alert: LowCacheHitRate\n        expr: lolstonks_cache_hit_rate &lt; 0.6\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Low cache hit rate\"\n          description: \"Cache hit rate is {{ $value | humanizePercentage }}\"\n\n      - alert: HighMemoryUsage\n        expr: process_resident_memory_bytes / 1024 / 1024 &gt; 3000\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High memory usage\"\n          description: \"Memory usage is {{ $value }}MB\"\n\n      - alert: ServiceDown\n        expr: up{job=\"lolstonks-api\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Service is down\"\n          description: \"LOLStonks API Gateway has been down for more than 1 minute\"\n</code></pre>"},{"location":"operations/monitoring/#grafana-dashboard","title":"Grafana Dashboard","text":"<p>Not Implemented: Grafana dashboards are not currently configured.</p>"},{"location":"operations/monitoring/#dashboard-configuration-example","title":"Dashboard Configuration (Example)","text":"<pre><code>{\n  \"dashboard\": {\n    \"id\": null,\n    \"title\": \"LOLStonks API Gateway\",\n    \"tags\": [\"lolstonks\", \"api\"],\n    \"timezone\": \"browser\",\n    \"panels\": [\n      {\n        \"title\": \"Request Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(lolstonks_requests_total[5m])\",\n            \"legendFormat\": \"{{method}} {{endpoint}}\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Requests/sec\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Response Time\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"histogram_quantile(0.95, rate(lolstonks_request_duration_seconds_bucket[5m]))\",\n            \"legendFormat\": \"95th percentile\"\n          },\n          {\n            \"expr\": \"histogram_quantile(0.50, rate(lolstonks_request_duration_seconds_bucket[5m]))\",\n            \"legendFormat\": \"50th percentile\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Seconds\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Error Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(lolstonks_requests_total{status!~\\\"2..\\\"}[5m]) / rate(lolstonks_requests_total[5m])\",\n            \"legendFormat\": \"Error Rate\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Percentage\",\n            \"max\": 1,\n            \"min\": 0\n          }\n        ]\n      },\n      {\n        \"title\": \"Cache Hit Rate\",\n        \"type\": \"singlestat\",\n        \"targets\": [\n          {\n            \"expr\": \"lolstonks_cache_hit_rate\",\n            \"legendFormat\": \"Cache Hit Rate\"\n          }\n        ],\n        \"valueMaps\": [\n          {\n            \"value\": \"null\",\n            \"text\": \"N/A\"\n          }\n        ],\n        \"thresholds\": \"0.6,0.8\"\n      },\n      {\n        \"title\": \"Memory Usage\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"process_resident_memory_bytes / 1024 / 1024\",\n            \"legendFormat\": \"Memory (MB)\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"MB\"\n          }\n        ]\n      },\n      {\n        \"title\": \"CPU Usage\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(process_cpu_seconds_total[5m]) * 100\",\n            \"legendFormat\": \"CPU %\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Percentage\",\n            \"max\": 100,\n            \"min\": 0\n          }\n        ]\n      }\n    ],\n    \"time\": {\n      \"from\": \"now-1h\",\n      \"to\": \"now\"\n    },\n    \"refresh\": \"5s\"\n  }\n}\n</code></pre>"},{"location":"operations/monitoring/#log-management","title":"Log Management","text":"<p>Not Implemented: ELK Stack (Elasticsearch, Logstash, Kibana) is not currently configured.</p>"},{"location":"operations/monitoring/#log-aggregation-with-elk-stack-example","title":"Log Aggregation with ELK Stack (Example)","text":""},{"location":"operations/monitoring/#logstash-configuration-example","title":"Logstash Configuration (Example)","text":"<pre><code># logstash.conf\ninput {\n  file {\n    path =&gt; \"/var/log/lolstonks/api.log\"\n    start_position =&gt; \"beginning\"\n    codec =&gt; json\n  }\n}\n\nfilter {\n  # Parse timestamp\n  date {\n    match =&gt; [ \"timestamp\", \"ISO8601\" ]\n  }\n\n  # Add fields\n  mutate {\n    add_field =&gt; { \"service\" =&gt; \"lolstonks-api\" }\n    add_field =&gt; { \"environment\" =&gt; \"production\" }\n  }\n\n  # Parse request logs\n  if [request_id] {\n    mutate {\n      add_field =&gt; { \"log_type\" =&gt; \"request\" }\n    }\n  }\n\n  # Parse error logs\n  if [level] == \"ERROR\" or [level] == \"CRITICAL\" {\n    mutate {\n      add_field =&gt; { \"log_type\" =&gt; \"error\" }\n    }\n  }\n}\n\noutput {\n  elasticsearch {\n    hosts =&gt; [\"elasticsearch:9200\"]\n    index =&gt; \"lolstonks-logs-%{+YYYY.MM.dd}\"\n  }\n\n  # Also output to stdout for debugging\n  stdout {\n    codec =&gt; rubydebug\n  }\n}\n</code></pre>"},{"location":"operations/monitoring/#kibana-dashboard-configuration","title":"Kibana Dashboard Configuration","text":"<pre><code>// Kibana saved objects for LOLStonks monitoring\n{\n  \"dashboard\": {\n    \"title\": \"LOLStonks Logs\",\n    \"panels\": [\n      {\n        \"title\": \"Request Rate Over Time\",\n        \"type\": \"histogram\",\n        \"query\": \"log_type:request\",\n        \"timeField\": \"@timestamp\"\n      },\n      {\n        \"title\": \"Error Distribution\",\n        \"type\": \"pie\",\n        \"query\": \"level:ERROR OR level:CRITICAL\",\n        \"field\": \"error_type\"\n      },\n      {\n        \"title\": \"Response Time Distribution\",\n        \"type\": \"histogram\",\n        \"query\": \"duration_ms:*\",\n        \"field\": \"duration_ms\"\n      },\n      {\n        \"title\": \"Recent Errors\",\n        \"type\": \"table\",\n        \"query\": \"level:ERROR OR level:CRITICAL\",\n        \"sort\": [\"@timestamp\", \"desc\"],\n        \"columns\": [\"@timestamp\", \"message\", \"request_id\", \"endpoint\"]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"operations/monitoring/#advanced-monitoring","title":"Advanced Monitoring","text":"<p>Not Implemented: The advanced monitoring features below are not currently implemented.</p>"},{"location":"operations/monitoring/#distributed-tracing-with-opentelemetry-potential-enhancement","title":"Distributed Tracing with OpenTelemetry (Potential Enhancement)","text":"<p>Not Implemented: OpenTelemetry tracing is not currently configured.</p> <pre><code># Example: app/tracing.py (NOT IMPLEMENTED)\nfrom opentelemetry import trace\nfrom opentelemetry.exporter.jaeger.thrift import JaegerExporter\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\nfrom opentelemetry.instrumentation.fastapi import FastAPIInstrumentor\nfrom opentelemetry.instrumentation.httpx import HTTPXClientInstrumentor\nfrom opentelemetry.instrumentation.redis import RedisInstrumentor\n\ndef setup_tracing():\n    \"\"\"Configure OpenTelemetry tracing.\"\"\"\n\n    # Set up tracer\n    trace.set_tracer_provider(TracerProvider())\n    tracer = trace.get_tracer(__name__)\n\n    # Configure Jaeger exporter\n    jaeger_exporter = JaegerExporter(\n        agent_host_name=\"localhost\",\n        agent_port=6831,\n    )\n\n    # Add span processor\n    span_processor = BatchSpanProcessor(jaeger_exporter)\n    trace.get_tracer_provider().add_span_processor(span_processor)\n\n    # Instrument FastAPI\n    FastAPIInstrumentor.instrument()\n\n    # Instrument HTTP clients\n    HTTPXClientInstrumentor.instrument()\n\n    # Instrument Redis\n    RedisInstrumentor.instrument()\n</code></pre>"},{"location":"operations/monitoring/#custom-metrics-potential-enhancement","title":"Custom Metrics (Potential Enhancement)","text":"<p>Not Implemented: Custom business metrics are not currently tracked.</p> <pre><code># Example: app/custom_metrics.py (NOT IMPLEMENTED)\nfrom prometheus_client import Counter, Histogram, Gauge\nimport time\nimport functools\n\n# Business metrics\nSUMMONER_LOOKUPS = Counter(\n    'lolstonks_summoner_lookups_total',\n    'Total number of summoner lookups',\n    ['region', 'source_type']\n)\n\nMATCH_LOOKUPS = Counter(\n    'lolstonks_match_lookups_total',\n    'Total number of match lookups',\n    ['region', 'queue_type']\n)\n\nAPI_KEY_USAGE = Counter(\n    'lolstonks_api_key_requests_total',\n    'Total requests to Riot API',\n    ['endpoint', 'status_code']\n)\n\nRATE_LIMIT_HITS = Counter(\n    'lolstonks_rate_limit_hits_total',\n    'Number of rate limit hits',\n    ['endpoint', 'region']\n)\n\ndef timed(histogram):\n    \"\"\"Decorator to measure function execution time.\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        async def wrapper(*args, **kwargs):\n            start_time = time.time()\n            try:\n                result = await func(*args, **kwargs)\n                histogram.observe(time.time() - start_time)\n                return result\n            except Exception as e:\n                histogram.observe(time.time() - start_time)\n                raise\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"operations/monitoring/#alerting","title":"Alerting","text":"<p>Not Implemented: Alerting is not currently configured. The examples below show potential configurations.</p>"},{"location":"operations/monitoring/#alert-configuration-example","title":"Alert Configuration (Example)","text":"<pre><code># alerts.yml\ngroups:\n  - name: lolstonks_critical\n    rules:\n      - alert: ServiceDown\n        expr: up{job=\"lolstonks-api\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"LOLStonks API Gateway is down\"\n          description: \"Service has been down for more than 1 minute\"\n\n      - alert: HighErrorRate\n        expr: rate(lolstonks_requests_total{status!~\"2..\"}[5m]) / rate(lolstonks_requests_total[5m]) &gt; 0.1\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High error rate detected\"\n          description: \"Error rate is {{ $value | humanizePercentage }}\"\n\n  - name: lolstonks_warnings\n    rules:\n      - alert: HighResponseTime\n        expr: histogram_quantile(0.95, rate(lolstonks_request_duration_seconds_bucket[5m])) &gt; 1.0\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High response time detected\"\n          description: \"95th percentile response time is {{ $value }}s\"\n\n      - alert: LowCacheHitRate\n        expr: lolstonks_cache_hit_rate &lt; 0.7\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Low cache hit rate\"\n          description: \"Cache hit rate is {{ $value | humanizePercentage }}\"\n</code></pre>"},{"location":"operations/monitoring/#notification-channels","title":"Notification Channels","text":"<pre><code># alertmanager.yml\nglobal:\n  smtp_smarthost: 'localhost:587'\n  smtp_from: 'alerts@yourdomain.com'\n\nroute:\n  group_by: ['alertname']\n  group_wait: 10s\n  group_interval: 10s\n  repeat_interval: 1h\n  receiver: 'web.hook'\n\nreceivers:\n  - name: 'web.hook'\n    email_configs:\n      - to: 'team@yourdomain.com'\n        subject: '[LOLStonks Alert] {{ .GroupLabels.alertname }}'\n        body: |\n          {{ range .Alerts }}\n          Alert: {{ .Annotations.summary }}\n          Description: {{ .Annotations.description }}\n          {{ end }}\n\n    slack_configs:\n      - api_url: 'YOUR_SLACK_WEBHOOK_URL'\n        channel: '#alerts'\n        title: 'LOLStonks Alert'\n        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'\n</code></pre>"},{"location":"operations/monitoring/#summary","title":"Summary","text":"<p>This document outlines best practices and potential implementations for comprehensive monitoring.</p> <p>Current State: The API Gateway has basic logging (Loguru) and a simple health check endpoint.</p> <p>Future Enhancements: Implementing Prometheus metrics, Grafana dashboards, ELK stack, and OpenTelemetry would provide full observability and enable proactive issue detection and performance optimization.</p> <p>For the actual implementation status, see Implementation Status.</p>"},{"location":"operations/security/","title":"Security Best Practices","text":"<p>This guide covers security considerations and best practices for deploying and operating the LOLStonks API Gateway in production environments.</p> <p>\ud83d\udcdd Documentation Note: This document describes security best practices and potential implementations. Many advanced security features represent future enhancements rather than current implementation.</p> <p>Currently Implemented \u2705: - Input validation using Pydantic models - Basic rate limiting (Riot API level with aiolimiter) - API key loading from environment variables - Redis password authentication (if configured)</p> <p>Not Yet Implemented \u274c (Potential Future Enhancements): - API key rotation system - IP-based rate limiting and blocking - Advanced input sanitization - CORS middleware - HTTPS redirect middleware - Security event logging - Prometheus security metrics</p> <p>For actual implementation details, see Implementation Details.</p>"},{"location":"operations/security/#overview","title":"Overview","text":"<p>Security is implemented through multiple layers of protection:</p> <ol> <li>Input Validation: Comprehensive request validation using Pydantic models \u2705</li> <li>Rate Limiting: Protection against abuse and DoS attacks \u26a0\ufe0f (Riot API level only)</li> <li>Authentication &amp; Authorization: Secure API key management \u26a0\ufe0f (Basic environment variable)</li> <li>Network Security: Firewall rules and secure communications \u26a0\ufe0f (Infrastructure level)</li> <li>Monitoring &amp; Auditing: Comprehensive logging and threat detection \u274c (Not implemented)</li> </ol>"},{"location":"operations/security/#api-key-security","title":"API Key Security","text":""},{"location":"operations/security/#secure-key-management","title":"Secure Key Management","text":""},{"location":"operations/security/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code># Never hardcode API keys in source code\nRIOT_API_KEY=RGAPI-your-secure-api-key\n\n# Use separate keys for different environments\nRIOT_API_KEY_DEV=RGAPI-dev-key\nRIOT_API_KEY_STAGING=RGAPI-staging-key\nRIOT_API_KEY_PROD=RGAPI-production-key\n</code></pre>"},{"location":"operations/security/#current-implementation","title":"Current Implementation","text":"<pre><code># .env file (ACTUAL IMPLEMENTATION)\nRIOT_API_KEY=RGAPI-your-secure-api-key\n</code></pre> <p>The API key is loaded from environment variables using Pydantic Settings:</p> <pre><code># app/config.py (ACTUAL IMPLEMENTATION)\nclass Settings(BaseSettings):\n    riot_api_key: str  # Required from environment\n</code></pre>"},{"location":"operations/security/#key-rotation-strategy-potential-enhancement","title":"Key Rotation Strategy (Potential Enhancement)","text":"<p>Not Implemented: API key rotation is not currently automated. Keys must be rotated manually.</p> <pre><code># Example: app/security.py (NOT IMPLEMENTED)\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass APIKeyManager:\n    \"\"\"Manages Riot API key rotation and validation.\"\"\"\n\n    def __init__(self):\n        self.current_key = os.getenv(\"RIOT_API_KEY\")\n        self.backup_key = os.getenv(\"RIOT_API_KEY_BACKUP\")\n        self.last_rotation = datetime.now()\n        self.rotation_interval = timedelta(days=20)  # Riot API keys last 30 days\n\n    def get_active_key(self) -&gt; str:\n        \"\"\"Get the currently active API key.\"\"\"\n        # Check if key needs rotation\n        if datetime.now() - self.last_rotation &gt; self.rotation_interval:\n            logger.warning(\"API key rotation recommended\")\n\n        return self.current_key\n\n    def validate_key_format(self, key: str) -&gt; bool:\n        \"\"\"Validate API key format.\"\"\"\n        import re\n        pattern = r'^RGAPI-[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'\n        return bool(re.match(pattern, key))\n</code></pre>"},{"location":"operations/security/#key-storage-best-practices","title":"Key Storage Best Practices","text":"<ol> <li>Use Environment Variables: Never store keys in code or configuration files</li> <li>Separate Environments: Use different keys for dev, staging, and production</li> <li>Regular Rotation: Rotate keys every 20-25 days (Riot API keys expire in 30 days)</li> <li>Backup Keys: Maintain backup keys for failover scenarios</li> <li>Access Control: Limit access to API keys to only necessary personnel</li> </ol>"},{"location":"operations/security/#input-validation-sanitization","title":"Input Validation &amp; Sanitization","text":""},{"location":"operations/security/#pydantic-model-validation-currently-implemented","title":"Pydantic Model Validation (Currently Implemented \u2705)","text":"<p>All API inputs are validated using Pydantic models. This is currently implemented in the codebase:</p> <pre><code># app/models/security.py\nfrom pydantic import BaseModel, Field, validator\nimport re\nfrom typing import Optional\n\nclass SecureSummonerNameParams(BaseModel):\n    \"\"\"Securely validated summoner name parameters.\"\"\"\n\n    summonerName: str = Field(\n        min_length=1,\n        max_length=16,\n        description=\"Summoner name (1-16 characters)\"\n    )\n\n    @validator('summonerName')\n    def validate_summoner_name(cls, v):\n        \"\"\"Validate summoner name format.\"\"\"\n        # Remove potentially dangerous characters\n        cleaned = re.sub(r'[^\\w\\s]', '', v.strip())\n\n        # Check for allowed characters (letters, numbers, spaces)\n        if not re.match(r'^[a-zA-Z0-9\\s]+$', cleaned):\n            raise ValueError('Invalid summoner name format')\n\n        return cleaned\n\nclass SecureRegionQuery(BaseModel):\n    \"\"\"Securely validated region parameters.\"\"\"\n\n    region: str = Field(\n        default=\"euw1\",\n        description=\"Riot API region code\"\n    )\n\n    @validator('region')\n    def validate_region(cls, v):\n        \"\"\"Validate region code against allowed list.\"\"\"\n        allowed_regions = {\n            'euw1', 'eun1', 'tr1', 'ru',  # Europe\n            'na1', 'br1', 'la1', 'la2',   # Americas\n            'kr', 'jp1',                  # Asia\n            'oc1', 'ph2', 'sg2', 'th2', 'tw2', 'vn2'  # SEA/Oceania\n        }\n\n        if v.lower() not in allowed_regions:\n            raise ValueError(f'Invalid region: {v}')\n\n        return v.lower()\n</code></pre>"},{"location":"operations/security/#advanced-input-sanitization-potential-enhancement","title":"Advanced Input Sanitization (Potential Enhancement)","text":"<p>Not Implemented: Advanced input sanitization beyond Pydantic validation is not currently implemented.</p> <p>The current implementation relies on Pydantic validators (shown above). More advanced sanitization could be added:</p> <pre><code># Example: app/security/validation.py (NOT IMPLEMENTED)\nimport re\nfrom typing import Any, Dict, List\n\nclass SecurityValidator:\n    \"\"\"Security-focused input validation.\"\"\"\n\n    @staticmethod\n    def sanitize_string(input_str: str, max_length: int = 100) -&gt; str:\n        \"\"\"Sanitize string inputs.\"\"\"\n        if not isinstance(input_str, str):\n            raise TypeError(\"Input must be a string\")\n\n        # Remove potentially dangerous characters\n        sanitized = re.sub(r'[&lt;&gt;\"\\';\\\\&amp;]', '', input_str)\n\n        # Truncate to max length\n        sanitized = sanitized[:max_length]\n\n        return sanitized.strip()\n\n    @staticmethod\n    def validate_puuid(puuid: str) -&gt; bool:\n        \"\"\"Validate PUUID format.\"\"\"\n        pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'\n        return bool(re.match(pattern, puuid.lower()))\n\n    @staticmethod\n    def validate_match_id(match_id: str) -&gt; bool:\n        \"\"\"Validate match ID format.\"\"\"\n        pattern = r'^[A-Z0-9_]+$'\n        return bool(re.match(pattern, match_id))\n</code></pre>"},{"location":"operations/security/#rate-limiting-ddos-protection","title":"Rate Limiting &amp; DDoS Protection","text":""},{"location":"operations/security/#current-implementation_1","title":"Current Implementation","text":"<p>The application implements rate limiting only at the Riot API level using aiolimiter:</p> <pre><code># app/riot/rate_limiter.py (ACTUAL IMPLEMENTATION)\nfrom aiolimiter import AsyncLimiter\n\nclass RiotRateLimiter:\n    def __init__(self):\n        self.limiter_1s = AsyncLimiter(\n            max_rate=settings.riot_rate_limit_per_second,\n            time_period=1,\n        )\n        self.limiter_2min = AsyncLimiter(\n            max_rate=settings.riot_rate_limit_per_2min,\n            time_period=120,\n        )\n</code></pre> <p>Limitation: This only limits requests to the Riot API, not incoming requests from clients.</p>"},{"location":"operations/security/#ip-based-rate-limiting-potential-enhancement","title":"IP-Based Rate Limiting (Potential Enhancement)","text":"<p>Not Implemented: Per-IP rate limiting and DDoS protection are not currently implemented.</p> <pre><code># Example: app/security/rate_limiting.py (NOT IMPLEMENTED)\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.util import get_remote_address\nfrom slowapi.errors import RateLimitExceeded\nfrom fastapi import Request, HTTPException\nimport redis\nimport json\n\n# Initialize rate limiter with Redis backend\nredis_client = redis.Redis(\n    host='localhost',\n    port=6379,\n    password='your-redis-password',\n    decode_responses=True\n)\n\nlimiter = Limiter(\n    key_func=get_remote_address,\n    storage_uri=\"redis://localhost:6379\",\n    default_limits=[\"1000/hour\"]  # Global limit\n)\n\n# Custom rate limit exceeded handler\nasync def rate_limit_exceeded_handler(request: Request, exc: RateLimitExceeded):\n    \"\"\"Custom handler for rate limit exceeded.\"\"\"\n    client_ip = get_remote_address(request)\n    logger.warning(f\"Rate limit exceeded for IP: {client_ip}\")\n\n    raise HTTPException(\n        status_code=429,\n        detail={\n            \"error\": \"Rate limit exceeded\",\n            \"message\": \"Too many requests. Please try again later.\",\n            \"retry_after\": exc.detail  # Seconds to wait\n        }\n    )\n\n# Apply rate limiting to sensitive endpoints\n@app.get(\"/summoner/by-name/{summonerName}\")\n@limiter.limit(\"100/minute\")  # Stricter limit for summoner lookups\nasync def get_summoner_by_name(\n    request: Request,\n    summonerName: str,\n    region: str = \"euw1\"\n):\n    \"\"\"Get summoner by name with rate limiting.\"\"\"\n    pass\n</code></pre>"},{"location":"operations/security/#ip-based-blocking-potential-enhancement","title":"IP-Based Blocking (Potential Enhancement)","text":"<p>Not Implemented: IP blocking is not currently implemented.</p> <pre><code># Example: app/security/ip_blocking.py (NOT IMPLEMENTED)\nfrom typing import Set, Dict\nfrom datetime import datetime, timedelta\nimport json\n\nclass IPBlocker:\n    \"\"\"Manages IP blocking for malicious actors.\"\"\"\n\n    def __init__(self, redis_client):\n        self.redis = redis_client\n        self.block_duration = timedelta(hours=1)\n        self.permanent_block_threshold = 100  # Violations for permanent block\n\n    async def block_ip(self, ip: str, reason: str, permanent: bool = False):\n        \"\"\"Block an IP address.\"\"\"\n        block_data = {\n            \"ip\": ip,\n            \"reason\": reason,\n            \"timestamp\": datetime.now().isoformat(),\n            \"permanent\": permanent\n        }\n\n        if permanent:\n            await self.redis.set(f\"blocked_ip:{ip}\", json.dumps(block_data))\n        else:\n            await self.redis.setex(\n                f\"blocked_ip:{ip}\",\n                int(self.block_duration.total_seconds()),\n                json.dumps(block_data)\n            )\n\n    async def is_ip_blocked(self, ip: str) -&gt; bool:\n        \"\"\"Check if IP is blocked.\"\"\"\n        return await self.redis.exists(f\"blocked_ip:{ip}\")\n\n    async def record_violation(self, ip: str, violation_type: str):\n        \"\"\"Record a security violation.\"\"\"\n        violation_key = f\"violations:{ip}\"\n\n        # Increment violation count\n        count = await self.redis.incr(violation_key)\n        await self.redis.expire(violation_key, 86400)  # 24 hours\n\n        # Check if should be permanently blocked\n        if count &gt;= self.permanent_block_threshold:\n            await self.block_ip(ip, f\"Too many violations: {count}\", permanent=True)\n\n        return count\n\n# Middleware for IP blocking\n@app.middleware(\"http\")\nasync def ip_blocking_middleware(request: Request, call_next):\n    \"\"\"Check for blocked IPs before processing requests.\"\"\"\n    client_ip = get_remote_address(request)\n\n    if await ip_blocker.is_ip_blocked(client_ip):\n        raise HTTPException(\n            status_code=403,\n            detail=\"Access denied\"\n        )\n\n    response = await call_next(request)\n    return response\n</code></pre>"},{"location":"operations/security/#network-security","title":"Network Security","text":"<p>Infrastructure Level: Network security is typically handled at the infrastructure/deployment level, not in application code.</p>"},{"location":"operations/security/#ssltls-configuration","title":"SSL/TLS Configuration","text":""},{"location":"operations/security/#nginx-ssl-configuration-deployment-best-practice","title":"Nginx SSL Configuration (Deployment Best Practice \u2705)","text":"<pre><code># /etc/nginx/sites-available/lolstonks-api\nserver {\n    listen 443 ssl http2;\n    server_name api.yourdomain.com;\n\n    # SSL Configuration\n    ssl_certificate /etc/letsencrypt/live/api.yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/api.yourdomain.com/privkey.pem;\n\n    # Strong SSL Configuration\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n\n    # Security Headers\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n    add_header X-Frame-Options DENY always;\n    add_header X-Content-Type-Options nosniff always;\n    add_header X-XSS-Protection \"1; mode=block\" always;\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\n    add_header Content-Security-Policy \"default-src 'self'\"; always;\n\n    location / {\n        proxy_pass http://127.0.0.1:8080;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # SSL offloading\n        proxy_set_header X-Forwarded-Proto https;\n        proxy_set_header X-Forwarded-SSL on;\n    }\n}\n</code></pre>"},{"location":"operations/security/#application-ssl-settings-potential-enhancement","title":"Application SSL Settings (Potential Enhancement)","text":"<p>Not Implemented: HTTPS redirect and trusted host middleware are not currently configured in the application.</p> <pre><code># Example: app/security/ssl.py (NOT IMPLEMENTED)\nfrom fastapi import FastAPI\nfrom fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\n\ndef configure_security_middleware(app: FastAPI):\n    \"\"\"Configure security middleware for the FastAPI app.\"\"\"\n\n    # Force HTTPS in production\n    if os.getenv(\"ENVIRONMENT\") == \"production\":\n        app.add_middleware(HTTPSRedirectMiddleware)\n\n    # Only allow trusted hosts\n    allowed_hosts = os.getenv(\"ALLOWED_HOSTS\", \"localhost,127.0.0.1\").split(\",\")\n    app.add_middleware(\n        TrustedHostMiddleware,\n        allowed_hosts=allowed_hosts\n    )\n\n    return app\n</code></pre>"},{"location":"operations/security/#firewall-configuration-deployment-best-practice","title":"Firewall Configuration (Deployment Best Practice \u2705)","text":"<p>Infrastructure Level: Firewall configuration is handled at the system/deployment level.</p> <pre><code>#!/bin/bash\n# Example: firewall_setup.sh\n\n# Reset firewall rules\nsudo ufw --force reset\n\n# Default policies\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\n\n# Allow SSH (restrict to your IP if possible)\nsudo ufw allow 22/tcp\n\n# Allow HTTP/HTTPS\nsudo ufw allow 80/tcp\nsudo ufw allow 443/tcp\n\n# Allow Redis only from localhost\nsudo ufw allow from 127.0.0.1 to any port 6379\n\n# Rate limiting for HTTP\nsudo ufw limit 80/tcp\nsudo ufw limit 443/tcp\n\n# Enable firewall\nsudo ufw --force enable\n\n# Show status\nsudo ufw status verbose\n</code></pre>"},{"location":"operations/security/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<p>Not Implemented: Advanced authentication for admin endpoints is not currently implemented.</p> <p>The current implementation only uses the Riot API key for accessing Riot's services. There is no authentication for accessing the gateway itself.</p>"},{"location":"operations/security/#api-key-authentication-potential-enhancement","title":"API Key Authentication (Potential Enhancement)","text":"<p>Not Implemented: API key authentication for gateway endpoints is not currently implemented.</p> <pre><code># Example: app/security/auth.py (NOT IMPLEMENTED)\nfrom fastapi import HTTPException, Security, Depends\nfrom fastapi.security import APIKeyHeader\nimport os\nimport hashlib\nimport hmac\n\nclass APIKeyAuth:\n    \"\"\"API key authentication for admin endpoints.\"\"\"\n\n    def __init__(self):\n        self.api_key = os.getenv(\"ADMIN_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"ADMIN_API_KEY environment variable required\")\n\n    def verify_key(self, provided_key: str) -&gt; bool:\n        \"\"\"Verify provided API key using constant-time comparison.\"\"\"\n        return hmac.compare_digest(\n            hashlib.sha256(provided_key.encode()).hexdigest(),\n            hashlib.sha256(self.api_key.encode()).hexdigest()\n        )\n\n# Initialize API key authentication\napi_key_header = APIKeyHeader(name=\"X-API-Key\", auto_error=False)\nauth = APIKeyAuth()\n\nasync def verify_api_key(api_key: str = Security(api_key_header)):\n    \"\"\"Dependency for API key verification.\"\"\"\n    if not api_key or not auth.verify_key(api_key):\n        raise HTTPException(\n            status_code=403,\n            detail=\"Invalid or missing API key\"\n        )\n    return api_key\n\n# Usage in endpoints\n@app.get(\"/admin/stats\")\nasync def get_admin_stats(api_key: str = Depends(verify_api_key)):\n    \"\"\"Admin-only endpoint with API key authentication.\"\"\"\n    pass\n</code></pre>"},{"location":"operations/security/#cors-configuration-potential-enhancement","title":"CORS Configuration (Potential Enhancement)","text":"<p>Not Implemented: CORS middleware is not currently configured.</p> <pre><code># Example: app/security/cors.py (NOT IMPLEMENTED)\nfrom fastapi.middleware.cors import CORSMiddleware\nimport os\n\ndef configure_cors(app: FastAPI):\n    \"\"\"Configure CORS based on environment.\"\"\"\n\n    # Production CORS settings\n    if os.getenv(\"ENVIRONMENT\") == \"production\":\n        allowed_origins = os.getenv(\"CORS_ORIGINS\", \"https://yourdomain.com\").split(\",\")\n        app.add_middleware(\n            CORSMiddleware,\n            allow_origins=allowed_origins,\n            allow_credentials=True,\n            allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n            allow_headers=[\"*\"],\n            expose_headers=[\"X-Request-ID\"]\n        )\n    else:\n        # Development CORS settings\n        app.add_middleware(\n            CORSMiddleware,\n            allow_origins=[\"*\"],\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"]\n        )\n</code></pre>"},{"location":"operations/security/#logging-monitoring","title":"Logging &amp; Monitoring","text":""},{"location":"operations/security/#current-implementation_2","title":"Current Implementation","text":"<p>The application uses basic Loguru logging (see monitoring.md). Security-specific logging is not currently implemented.</p>"},{"location":"operations/security/#security-logging-potential-enhancement","title":"Security Logging (Potential Enhancement)","text":"<p>Not Implemented: Dedicated security event logging is not currently implemented.</p> <pre><code># Example: app/security/logging.py (NOT IMPLEMENTED)\nimport logging\nimport json\nfrom datetime import datetime\nfrom typing import Dict, Any\n\nclass SecurityLogger:\n    \"\"\"Specialized logger for security events.\"\"\"\n\n    def __init__(self):\n        self.logger = logging.getLogger(\"security\")\n\n        # Configure security logger\n        handler = logging.FileHandler(\"/var/log/lolstonks/security.log\")\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n\n    def log_security_event(self, event_type: str, details: Dict[str, Any]):\n        \"\"\"Log a security event.\"\"\"\n        event = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"event_type\": event_type,\n            \"details\": details\n        }\n\n        self.logger.info(json.dumps(event))\n\n    def log_blocked_request(self, ip: str, endpoint: str, reason: str):\n        \"\"\"Log a blocked request.\"\"\"\n        self.log_security_event(\"blocked_request\", {\n            \"ip\": ip,\n            \"endpoint\": endpoint,\n            \"reason\": reason\n        })\n\n    def log_rate_limit_violation(self, ip: str, endpoint: str):\n        \"\"\"Log rate limit violation.\"\"\"\n        self.log_security_event(\"rate_limit_violation\", {\n            \"ip\": ip,\n            \"endpoint\": endpoint\n        })\n\n    def log_authentication_failure(self, ip: str, key_provided: bool):\n        \"\"\"Log authentication failure.\"\"\"\n        self.log_security_event(\"auth_failure\", {\n            \"ip\": ip,\n            \"key_provided\": key_provided\n        })\n\n# Initialize security logger\nsecurity_logger = SecurityLogger()\n</code></pre>"},{"location":"operations/security/#security-monitoring-potential-enhancement","title":"Security Monitoring (Potential Enhancement)","text":"<p>Not Implemented: Security metrics are not currently tracked.</p> <pre><code># Example: app/security/monitoring.py (NOT IMPLEMENTED)\nfrom prometheus_client import Counter, Histogram\nimport time\nimport hashlib\n\n# Security metrics\nSECURITY_EVENTS = Counter(\n    'lolstonks_security_events_total',\n    'Total security events',\n    ['event_type', 'severity']\n)\n\nAUTHENTICATION_ATTEMPTS = Counter(\n    'lolstonks_authentication_attempts_total',\n    'Total authentication attempts',\n    ['result']\n)\n\nRATE_LIMIT_VIOLATIONS = Counter(\n    'lolstonks_rate_limit_violations_total',\n    'Total rate limit violations',\n    ['ip', 'endpoint']\n)\n\nclass SecurityMonitor:\n    \"\"\"Security monitoring and alerting.\"\"\"\n\n    @staticmethod\n    def track_security_event(event_type: str, severity: str = \"medium\"):\n        \"\"\"Track security events for metrics.\"\"\"\n        SECURITY_EVENTS.labels(event_type=event_type, severity=severity).inc()\n\n    @staticmethod\n    def track_authentication_attempt(success: bool, ip: str):\n        \"\"\"Track authentication attempts.\"\"\"\n        result = \"success\" if success else \"failure\"\n        AUTHENTICATION_ATTEMPTS.labels(result=result).inc()\n\n        # Log suspicious patterns\n        if not success:\n            SecurityMonitor.check_suspicious_ip(ip)\n\n    @staticmethod\n    def check_suspicious_ip(ip: str):\n        \"\"\"Check for suspicious IP patterns.\"\"\"\n        # Hash IP for privacy\n        ip_hash = hashlib.sha256(ip.encode()).hexdigest()[:16]\n\n        # In production, you might check against:\n        # - Known malicious IP databases\n        # - Geographic anomalies\n        # - Unusual request patterns\n        pass\n</code></pre>"},{"location":"operations/security/#security-auditing","title":"Security Auditing","text":""},{"location":"operations/security/#regular-security-checks-best-practice","title":"Regular Security Checks (Best Practice \u2705)","text":"<p>Recommended Practice: These scripts are examples for manual or automated security audits.</p> <pre><code>#!/bin/bash\n# Example: security_audit.sh\n\necho \"=== LOLStonks Security Audit ===\"\necho \"Date: $(date)\"\necho\n\n# Check for exposed API keys\necho \"1. Checking for exposed API keys...\"\nif grep -r \"RGAPI-\" /home/lolstonks/lolstonks-api-gateway/ --exclude-dir=.git; then\n    echo \"\u26a0\ufe0f  WARNING: Potential exposed API keys found!\"\nelse\n    echo \"\u2705 No exposed API keys found\"\nfi\n\n# Check file permissions\necho -e \"\\n2. Checking file permissions...\"\nfind /home/lolstonks/lolstonks-api-gateway/ -type f -name \"*.env\" -exec ls -la {} \\;\n\n# Check SSL certificate expiry\necho -e \"\\n3. Checking SSL certificate...\"\nif command -v certbot &gt;/dev/null 2&gt;&amp;1; then\n    certbot certificates\nelse\n    echo \"Certbot not installed\"\nfi\n\n# Check firewall status\necho -e \"\\n4. Checking firewall status...\"\nsudo ufw status\n\n# Check running services\necho -e \"\\n5. Checking running services...\"\nsystemctl list-units --type=service --state=running | grep -E \"(nginx|redis|lolstonks)\"\n\n# Check log for suspicious activity\necho -e \"\\n6. Recent security events...\"\nif [ -f /var/log/lolstonks/security.log ]; then\n    tail -20 /var/log/lolstonks/security.log\nelse\n    echo \"Security log not found\"\nfi\n\necho -e \"\\n=== Audit Complete ===\"\n</code></pre>"},{"location":"operations/security/#security-checklist","title":"Security Checklist","text":"<ul> <li>[ ] API Key Management</li> <li>[ ] API keys stored in environment variables only</li> <li>[ ] Regular key rotation (every 20-25 days)</li> <li>[ ] Separate keys for different environments</li> <li> <p>[ ] Backup keys available for failover</p> </li> <li> <p>[ ] Input Validation</p> </li> <li>[ ] All inputs validated using Pydantic models</li> <li>[ ] String inputs sanitized and length-limited</li> <li>[ ] Pattern validation for IDs and special formats</li> <li> <p>[ ] SQL injection prevention measures in place</p> </li> <li> <p>[ ] Rate Limiting</p> </li> <li>[ ] Global rate limits configured</li> <li>[ ] Endpoint-specific rate limits for sensitive operations</li> <li>[ ] IP-based blocking for abusive behavior</li> <li> <p>[ ] DDoS protection at multiple levels</p> </li> <li> <p>[ ] Network Security</p> </li> <li>[ ] HTTPS enforced in production</li> <li>[ ] Strong SSL/TLS configuration</li> <li>[ ] Security headers implemented</li> <li>[ ] Firewall rules configured</li> <li> <p>[ ] CORS properly configured</p> </li> <li> <p>[ ] Authentication</p> </li> <li>[ ] Admin endpoints protected with API keys</li> <li>[ ] Constant-time comparison for secrets</li> <li>[ ] Secure session management</li> <li> <p>[ ] Proper logout mechanisms</p> </li> <li> <p>[ ] Logging &amp; Monitoring</p> </li> <li>[ ] Security events logged separately</li> <li>[ ] Failed authentication attempts tracked</li> <li>[ ] Suspicious activity alerts configured</li> <li> <p>[ ] Log files properly secured and rotated</p> </li> <li> <p>[ ] Regular Maintenance</p> </li> <li>[ ] Security audits performed regularly</li> <li>[ ] Dependencies kept up to date</li> <li>[ ] SSL certificates monitored for expiry</li> <li>[ ] Backup and recovery procedures tested</li> </ul>"},{"location":"operations/security/#summary","title":"Summary","text":"<p>This document outlines security best practices and potential implementations for production deployments.</p> <p>Current Security Measures \u2705: - Pydantic input validation on all endpoints - Riot API rate limiting (prevents excessive API usage) - Environment-based API key management - Basic logging with Loguru</p> <p>Recommended Infrastructure Security (handled at deployment level): - Firewall configuration (ufw/iptables) - SSL/TLS termination (Nginx) - System-level hardening</p> <p>Future Security Enhancements \u274c (Not Implemented): - IP-based rate limiting and blocking - CORS middleware - Security event logging - Prometheus security metrics - API key rotation automation - Admin endpoint authentication</p> <p>For the actual implementation status, see Implementation Status.</p>"},{"location":"operations/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This comprehensive troubleshooting guide helps diagnose and resolve common issues with the LOLStonks API Gateway.</p>"},{"location":"operations/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Service Issues</li> <li>Performance Problems</li> <li>Cache and Redis Issues</li> <li>API and Rate Limiting Issues</li> <li>Network and Connectivity Issues</li> <li>Configuration Issues</li> <li>Monitoring and Debugging</li> </ul>"},{"location":"operations/troubleshooting/#service-issues","title":"Service Issues","text":""},{"location":"operations/troubleshooting/#service-wont-start","title":"Service Won't Start","text":""},{"location":"operations/troubleshooting/#symptoms","title":"Symptoms","text":"<ul> <li>Service fails to start or crashes immediately</li> <li><code>systemctl status lolstonks-api.service</code> shows failed state</li> <li>No response from health endpoint</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis-steps","title":"Diagnosis Steps","text":"<ol> <li> <p>Check Service Status <pre><code>sudo systemctl status lolstonks-api.service\n</code></pre></p> </li> <li> <p>View Service Logs <pre><code># View recent logs\nsudo journalctl -u lolstonks-api.service -n 50\n\n# Follow logs in real-time\nsudo journalctl -u lolstonks-api.service -f\n</code></pre></p> </li> <li> <p>Check Configuration <pre><code># Verify environment file exists and is readable\nsudo -u lolstonks cat /home/lolstonks/lolstonks-api-gateway/.env\n\n# Test configuration manually\nsudo -u lolstonks cd /home/lolstonks/lolstonks-api-gateway\nsudo -u lolstonks uv run python -c \"from app.config import settings; print(settings.dict())\"\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#common-causes-and-solutions","title":"Common Causes and Solutions","text":"<p>Missing Dependencies <pre><code># Reinstall dependencies\nsudo -u lolstonks cd /home/lolstonks/lolstonks-api-gateway\nsudo -u lolstonks uv pip install -e \".[docs]\"\n</code></pre></p> <p>Permission Issues <pre><code># Fix ownership\nsudo chown -R lolstonks:lolstonks /home/lolstonks/lolstonks-api-gateway\n\n# Fix permissions\nsudo chmod +x /home/lolstonks/lolstonks-api-gateway/scripts/*.py\n</code></pre></p> <p>Port Already in Use <pre><code># Check what's using the port\nsudo netstat -tulpn | grep :8080\n\n# Kill the process using the port\nsudo kill -9 &lt;PID&gt;\n</code></pre></p> <p>Invalid Configuration <pre><code># Validate environment variables\nsudo -u lolstonks bash -c 'source .env &amp;&amp; echo \"Configuration valid\"'\n</code></pre></p>"},{"location":"operations/troubleshooting/#service-crashes-or-restarts","title":"Service Crashes or Restarts","text":""},{"location":"operations/troubleshooting/#symptoms_1","title":"Symptoms","text":"<ul> <li>Service runs for a while then crashes</li> <li>Frequent automatic restarts</li> <li>Out of memory errors</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis","title":"Diagnosis","text":"<ol> <li> <p>Check Memory Usage <pre><code># Monitor memory usage\nhtop\n\n# Check OOM killer logs\nsudo dmesg | grep -i \"killed process\"\n</code></pre></p> </li> <li> <p>Check for Memory Leaks <pre><code># Monitor over time\nwhile true; do\n    echo \"$(date): $(ps -o pid,ppid,cmd,%mem,%cpu -p $(pgrep -f uvicorn))\"\n    sleep 30\ndone\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions","title":"Solutions","text":"<p>Increase Memory Limits <pre><code># Edit service file to increase memory limits\nsudo nano /etc/systemd/system/lolstonks-api.service\n# Add:\n# MemoryLimit=2G\n# MemorySwap=2G\n</code></pre></p> <p>Optimize Configuration <pre><code># In .env file\nUVICORN_WORKERS=2  # Reduce worker count\nCACHE_SIZE_LIMIT=1000000  # Reduce cache size\n</code></pre></p>"},{"location":"operations/troubleshooting/#performance-problems","title":"Performance Problems","text":""},{"location":"operations/troubleshooting/#slow-response-times","title":"Slow Response Times","text":""},{"location":"operations/troubleshooting/#symptoms_2","title":"Symptoms","text":"<ul> <li>API responses taking &gt;5 seconds</li> <li>Timeouts from client applications</li> <li>High latency on specific endpoints</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_1","title":"Diagnosis","text":"<ol> <li> <p>Benchmark Response Times <pre><code># Test response time\ncurl -w \"@curl-format.txt\" -o /dev/null -s http://localhost:8080/health\n\n# Create curl-format.txt:\n#      time_namelookup:  %{time_namelookup}\\n\n#         time_connect:  %{time_connect}\\n\n#      time_appconnect:  %{time_appconnect}\\n\n#     time_pretransfer:  %{time_pretransfer}\\n\n#        time_redirect:  %{time_redirect}\\n\n#   time_starttransfer:  %{time_starttransfer}\\n\n#                      ----------\\n\n#           time_total:  %{time_total}\\n\n</code></pre></p> </li> <li> <p>Profile the Application <pre><code># Install profiling tools\nuv pip install py-spy\n\n# Profile CPU usage\nsudo py-spy top --pid $(pgrep -f uvicorn)\n\n# Generate flame graph\nsudo py-spy record --pid $(pgrep -f uvicorn) -o profile.svg --duration 60\n</code></pre></p> </li> <li> <p>Check Resource Utilization <pre><code># CPU and memory\ntop\nhtop\n\n# Disk I/O\niostat -x 1\n\n# Network I/O\niftop\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#common-causes-and-solutions_1","title":"Common Causes and Solutions","text":"<p>High CPU Usage - Cause: Too many concurrent requests, inefficient code - Solution:   - Reduce worker count: <code>UVICORN_WORKERS=2</code>   - Implement caching: Increase cache TTL   - Optimize database queries</p> <p>High Memory Usage - Cause: Memory leaks, large cache sizes - Solution:   - Reduce cache size: <code>CACHE_SIZE_LIMIT=500000</code>   - Restart service periodically   - Profile memory usage</p> <p>Network Latency - Cause: Slow network to Riot API, DNS resolution issues - Solution:   - Use faster DNS servers: 8.8.8.8, 1.1.1.1   - Consider CDN or regional deployment   - Implement connection pooling</p>"},{"location":"operations/troubleshooting/#high-error-rates","title":"High Error Rates","text":""},{"location":"operations/troubleshooting/#symptoms_3","title":"Symptoms","text":"<ul> <li>5xx errors increasing</li> <li>429 rate limit errors</li> <li>Timeouts from Riot API</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_2","title":"Diagnosis","text":"<ol> <li> <p>Check Error Logs <pre><code># Filter for errors\nsudo journalctl -u lolstonks-api.service | grep -i error\n\n# Check specific error types\nsudo journalctl -u lolstonks-api.service | grep \"429\\|500\\|502\\|503\"\n</code></pre></p> </li> <li> <p>Monitor Riot API Status <pre><code># Test Riot API directly\ncurl -H \"X-Riot-Token: YOUR_API_KEY\" \\\n     https://euw1.api.riotgames.com/lol/status/v4/platform-data\n\n# Check status page\ncurl https://status.riotgames.com/\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions_1","title":"Solutions","text":"<p>Rate Limiting (429 Errors) <pre><code># Reduce rate limits in .env\nRIOT_RATE_LIMIT_PER_SECOND=15  # Reduce from 20\nRIOT_RATE_LIMIT_PER_2MIN=80    # Reduce from 100\n</code></pre></p> <p>Riot API Outages - Solution: Monitor Riot API status, implement circuit breakers - Monitoring: Set up alerts for API status changes</p> <p>Timeout Errors <pre><code># Increase timeouts in .env\nRIOT_REQUEST_TIMEOUT=30\nRIOT_MAX_RETRIES=5\n</code></pre></p>"},{"location":"operations/troubleshooting/#cache-and-redis-issues","title":"Cache and Redis Issues","text":""},{"location":"operations/troubleshooting/#cache-misses-or-invalidation","title":"Cache Misses or Invalidation","text":""},{"location":"operations/troubleshooting/#symptoms_4","title":"Symptoms","text":"<ul> <li>High rate of API calls to Riot servers</li> <li>Inconsistent data responses</li> <li>Poor performance</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_3","title":"Diagnosis","text":"<ol> <li> <p>Check Redis Status <pre><code># Test Redis connection\nredis-cli -a YOUR_PASSWORD ping\n\n# Check memory usage\nredis-cli -a YOUR_PASSWORD info memory\n\n# Check hit rate\nredis-cli -a YOUR_PASSWORD info stats | grep keyspace\n</code></pre></p> </li> <li> <p>Monitor Cache Performance <pre><code># Check cache keys\nredis-cli -a YOUR_PASSWORD keys \"lolstonks:*\" | wc -l\n\n# Monitor cache operations\nredis-cli -a YOUR_PASSWORD monitor\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions_2","title":"Solutions","text":"<p>Redis Connection Issues <pre><code># Check Redis service\nsudo systemctl status redis-server\n\n# Restart Redis if needed\nsudo systemctl restart redis-server\n\n# Check Redis configuration\nsudo redis-cli -a YOUR_PASSWORD config get \"*\"\n</code></pre></p> <p>Cache Eviction <pre><code># Increase Redis memory limit\n# In redis.conf:\nmaxmemory 4gb\nmaxmemory-policy allkeys-lru\n</code></pre></p> <p>Invalid Cache Keys <pre><code># Clear corrupted cache\nredis-cli -a YOUR_PASSWORD flushdb\n\n# Restart application to rebuild cache\nsudo systemctl restart lolstonks-api.service\n</code></pre></p>"},{"location":"operations/troubleshooting/#redis-memory-issues","title":"Redis Memory Issues","text":""},{"location":"operations/troubleshooting/#symptoms_5","title":"Symptoms","text":"<ul> <li>Redis using excessive memory</li> <li>Out of memory errors</li> <li>Slow Redis operations</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_4","title":"Diagnosis","text":"<pre><code># Check Redis memory usage\nredis-cli -a YOUR_PASSWORD info memory | grep used_memory_human\n\n# Check largest keys\nredis-cli -a YOUR_PASSWORD --bigkeys\n\n# Monitor memory usage over time\nwatch -n 1 'redis-cli -a YOUR_PASSWORD info memory | grep used_memory_human'\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_3","title":"Solutions","text":"<p>Memory Optimization <pre><code># In redis.conf\nmaxmemory 2gb\nmaxmemory-policy allkeys-lru\n</code></pre></p> <p>Key Expiration <pre><code># Set TTL on existing keys\nredis-cli -a YOUR_PASSWORD --eval - &lt;&lt;EOF\nfor _, key in ipairs(redis.call('keys', 'lolstonks:*')) do\n  redis.call('expire', key, 3600)\nend\nEOF\n</code></pre></p>"},{"location":"operations/troubleshooting/#api-and-rate-limiting-issues","title":"API and Rate Limiting Issues","text":""},{"location":"operations/troubleshooting/#rate-limiting-problems","title":"Rate Limiting Problems","text":""},{"location":"operations/troubleshooting/#symptoms_6","title":"Symptoms","text":"<ul> <li>429 errors from Riot API</li> <li>Requests being throttled</li> <li>Poor user experience</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_5","title":"Diagnosis","text":"<ol> <li> <p>Check Current Rate Limits <pre><code># Monitor rate limiting in logs\nsudo journalctl -u lolstonks-api.service | grep -i \"rate.*limit\"\n\n# Check API usage dashboard on Riot Developer Portal\n</code></pre></p> </li> <li> <p>Test Rate Limiting <pre><code># Quick test script\nfor i in {1..25}; do\n  curl -s -o /dev/null -w \"%{http_code}\\n\" http://localhost:8080/health\n  sleep 0.1\ndone\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions_4","title":"Solutions","text":"<p>Adjust Rate Limits <pre><code># Conservative rate limits\nRIOT_RATE_LIMIT_PER_SECOND=10\nRIOT_RATE_LIMIT_PER_2MIN=80\n</code></pre></p> <p>Implement Request Batching <pre><code># Batch multiple requests into single API calls\n# This reduces overall API usage\n</code></pre></p> <p>Add Request Queuing <pre><code># Implement request queue for high-traffic periods\n</code></pre></p>"},{"location":"operations/troubleshooting/#invalid-api-responses","title":"Invalid API Responses","text":""},{"location":"operations/troubleshooting/#symptoms_7","title":"Symptoms","text":"<ul> <li>Corrupted or incomplete data</li> <li>Invalid JSON responses</li> <li>Missing fields in API responses</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_6","title":"Diagnosis","text":"<ol> <li> <p>Validate API Response <pre><code># Test specific endpoint\ncurl -s http://localhost:8080/summoner/by-name/test?region=euw1 | jq .\n\n# Check response headers\ncurl -I http://localhost:8080/summoner/by-name/test?region=euw1\n</code></pre></p> </li> <li> <p>Check Data Validation <pre><code># Test with invalid data\ncurl -s http://localhost:8080/summoner/by-name/invalid@name?region=euw1\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions_5","title":"Solutions","text":"<p>Update Pydantic Models - Cause: Riot API changed response format - Solution: Update models in <code>app/models/</code> to match new format</p> <p>Implement Data Sanitization <pre><code># Add data cleaning in API routers\ndef clean_summoner_data(data):\n    # Remove or fix invalid fields\n    return cleaned_data\n</code></pre></p>"},{"location":"operations/troubleshooting/#network-and-connectivity-issues","title":"Network and Connectivity Issues","text":""},{"location":"operations/troubleshooting/#dns-resolution-problems","title":"DNS Resolution Problems","text":""},{"location":"operations/troubleshooting/#symptoms_8","title":"Symptoms","text":"<ul> <li>Slow startup times</li> <li>Intermittent connection failures</li> <li>DNS timeout errors</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_7","title":"Diagnosis","text":"<pre><code># Test DNS resolution\nnslookup euw1.api.riotgames.com\ndig euw1.api.riotgames.com\n\n# Test with different DNS servers\nnslookup euw1.api.riotgames.com 8.8.8.8\nnslookup euw1.api.riotgames.com 1.1.1.1\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_6","title":"Solutions","text":"<p>Use Reliable DNS Servers <pre><code># Edit /etc/resolv.conf\nnameserver 8.8.8.8\nnameserver 1.1.1.1\nnameserver 208.67.222.222\n</code></pre></p> <p>Implement DNS Caching <pre><code># Install dnsmasq for local DNS caching\nsudo apt install dnsmasq\nsudo systemctl enable dnsmasq\nsudo systemctl start dnsmasq\n</code></pre></p>"},{"location":"operations/troubleshooting/#ssltls-issues","title":"SSL/TLS Issues","text":""},{"location":"operations/troubleshooting/#symptoms_9","title":"Symptoms","text":"<ul> <li>Certificate errors</li> <li>SSL handshake failures</li> <li>HTTPS connection issues</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_8","title":"Diagnosis","text":"<pre><code># Test SSL connection\nopenssl s_client -connect euw1.api.riotgames.com:443\n\n# Check certificate validity\ncurl -v https://euw1.api.riotgames.com/lol/status/v4/platform-data\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_7","title":"Solutions","text":"<p>Update CA Certificates <pre><code>sudo apt update &amp;&amp; sudo apt install ca-certificates\n</code></pre></p> <p>Configure SSL Properly <pre><code># Ensure system time is correct\nsudo timedatectl set-ntp true\n\n# Update SSL libraries\nsudo apt install openssl libssl-dev\n</code></pre></p>"},{"location":"operations/troubleshooting/#configuration-issues","title":"Configuration Issues","text":""},{"location":"operations/troubleshooting/#environment-variable-problems","title":"Environment Variable Problems","text":""},{"location":"operations/troubleshooting/#symptoms_10","title":"Symptoms","text":"<ul> <li>Service won't start</li> <li>Invalid configuration values</li> <li>Runtime errors</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_9","title":"Diagnosis","text":"<pre><code># Check environment file syntax\ncat .env | bash -n\n\n# Test configuration loading\nsudo -u lolstonks bash -c 'source .env &amp;&amp; env | grep RIOT'\n\n# Validate required variables\ngrep -E \"^(RIOT_API_KEY|REDIS_HOST)\" .env\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_8","title":"Solutions","text":"<p>Fix Environment File <pre><code># Backup and recreate\ncp .env .env.backup\nnano .env\n\n# Ensure proper format:\n# KEY=value\n# No quotes around values unless needed\n</code></pre></p> <p>Missing Required Variables <pre><code># Add missing variables to .env\necho \"RIOT_API_KEY=RGAPI-your-key-here\" &gt;&gt; .env\necho \"REDIS_HOST=localhost\" &gt;&gt; .env\n</code></pre></p>"},{"location":"operations/troubleshooting/#permissions-issues","title":"Permissions Issues","text":""},{"location":"operations/troubleshooting/#symptoms_11","title":"Symptoms","text":"<ul> <li>Permission denied errors</li> <li>File access issues</li> <li>Service startup failures</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_10","title":"Diagnosis","text":"<pre><code># Check file permissions\nls -la /home/lolstonks/lolstonks-api-gateway/\n\n# Check user permissions\nsudo -u lolstonks whoami\nsudo -u lolstonks ls -la\n\n# Check systemd service user\ngrep \"User\\|Group\" /etc/systemd/system/lolstonks-api.service\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_9","title":"Solutions","text":"<p>Fix Ownership <pre><code># Set correct ownership\nsudo chown -R lolstonks:lolstonks /home/lolstonks/lolstonks-api-gateway\n</code></pre></p> <p>Fix Permissions <pre><code># Set appropriate permissions\nsudo chmod 755 /home/lolstonks/lolstonks-api-gateway\nsudo chmod 644 /home/lolstonks/lolstonks-api-gateway/.env\nsudo chmod +x /home/lolstonks/lolstonks-api-gateway/scripts/*.py\n</code></pre></p>"},{"location":"operations/troubleshooting/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"operations/troubleshooting/#health-check-script","title":"Health Check Script","text":"<p>Create a comprehensive health monitoring script:</p> <pre><code>#!/bin/bash\n# health_check.sh\n\nAPI_URL=\"http://127.0.0.1:8080/health\"\nREDIS_CLI=\"redis-cli -a YOUR_PASSWORD\"\nLOG_FILE=\"/var/log/lolstonks/health_check.log\"\n\n# Function to log with timestamp\nlog() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - $1\" | tee -a \"$LOG_FILE\"\n}\n\n# Check API health\ncheck_api() {\n    local response=$(curl -s -o /dev/null -w \"%{http_code}\" \"$API_URL\")\n    if [ \"$response\" != \"200\" ]; then\n        log \"API health check failed with status: $response\"\n        return 1\n    fi\n    return 0\n}\n\n# Check Redis health\ncheck_redis() {\n    local pong=$($REDIS_CLI ping 2&gt;/dev/null)\n    if [ \"$pong\" != \"PONG\" ]; then\n        log \"Redis health check failed\"\n        return 1\n    fi\n    return 0\n}\n\n# Check system resources\ncheck_resources() {\n    local cpu_usage=$(top -bn1 | grep \"Cpu(s)\" | awk '{print $2}' | cut -d'%' -f1)\n    local mem_usage=$(free | grep Mem | awk '{printf \"%.1f\", $3/$2 * 100.0}')\n\n    if (( $(echo \"$cpu_usage &gt; 80\" | bc -l) )); then\n        log \"High CPU usage: ${cpu_usage}%\"\n    fi\n\n    if (( $(echo \"$mem_usage &gt; 80\" | bc -l) )); then\n        log \"High memory usage: ${mem_usage}%\"\n    fi\n}\n\n# Main health check\nmain() {\n    log \"Starting health check\"\n\n    if ! check_api; then\n        log \"Restarting API service\"\n        sudo systemctl restart lolstonks-api.service\n    fi\n\n    if ! check_redis; then\n        log \"Restarting Redis service\"\n        sudo systemctl restart redis-server\n    fi\n\n    check_resources\n\n    log \"Health check completed\"\n}\n\nmain\n</code></pre>"},{"location":"operations/troubleshooting/#log-analysis-script","title":"Log Analysis Script","text":"<p>Create a log analysis script for troubleshooting:</p> <pre><code>#!/bin/bash\n# analyze_logs.sh\n\nLOG_FILE=\"/var/log/lolstonks/api.log\"\nERROR_PATTERN=\"(ERROR|CRITICAL|Exception|Traceback)\"\nWARNING_PATTERN=\"(WARNING|WARN)\"\n\necho \"=== Error Analysis ===\"\ngrep -E \"$ERROR_PATTERN\" \"$LOG_FILE\" | tail -20\n\necho -e \"\\n=== Warning Analysis ===\"\ngrep -E \"$WARNING_PATTERN\" \"$LOG_FILE\" | tail -20\n\necho -e \"\\n=== Response Time Analysis ===\"\ngrep \"response_time\" \"$LOG_FILE\" | tail -20 | awk '{print $NF}' | sort -n\n\necho -e \"\\n=== Top Error Endpoints ===\"\ngrep \"ERROR\" \"$LOG_FILE\" | awk '{print $6}' | sort | uniq -c | sort -nr | head -10\n</code></pre>"},{"location":"operations/troubleshooting/#performance-monitoring","title":"Performance Monitoring","text":"<p>Set up basic performance monitoring:</p> <pre><code>#!/bin/bash\n# monitor.sh\n\nAPI_PID=$(pgrep -f uvicorn)\n\nif [ -z \"$API_PID\" ]; then\n    echo \"API service not running\"\n    exit 1\nfi\n\necho \"=== CPU and Memory Usage ===\"\nps -p \"$API_PID\" -o pid,ppid,cmd,%mem,%cpu\n\necho -e \"\\n=== File Descriptors ===\"\nlsof -p \"$API_PID\" | wc -l\n\necho -e \"\\n=== Network Connections ===\"\nnetstat -p | grep \"$API_PID\" | wc -l\n\necho -e \"\\n=== Redis Memory Usage ===\"\nredis-cli -a YOUR_PASSWORD info memory | grep used_memory_human\n</code></pre> <p>This comprehensive troubleshooting guide should help diagnose and resolve most common issues with the LOLStonks API Gateway. For issues not covered here, check the service logs and consider reaching out to the development team.</p>"}]}