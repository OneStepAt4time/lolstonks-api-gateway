{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LOLStonks API Gateway","text":"<p>Production-grade Riot Games API Gateway engineered for high-performance applications with intelligent caching, automatic rate limiting, and comprehensive observability.</p> <p></p>"},{"location":"#enterprise-features","title":"Enterprise Features","text":""},{"location":"#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Sub-100ms Response Times: Optimized for high-throughput applications</li> <li>Async Architecture: Built on FastAPI with full async/await support</li> <li>Horizontal Scaling: Stateless design enables multi-instance deployment</li> <li>Connection Pooling: Efficient resource management for high concurrency</li> </ul>"},{"location":"#reliability-resilience","title":"Reliability &amp; Resilience","text":"<ul> <li>Intelligent Rate Limiting: Token bucket algorithm ensures Riot API compliance</li> <li>Automatic Retries: Exponential backoff for 429 responses with configurable limits</li> <li>Circuit Breaker Pattern: Fault tolerance for external API dependencies</li> <li>Graceful Degradation: Continue operation during partial outages</li> </ul>"},{"location":"#intelligent-caching","title":"Intelligent Caching","text":"<ul> <li>Multi-Layer Caching: Redis-based with strategic TTL configuration</li> <li>High Cache Hit Rates: Optimized caching strategy for frequently accessed data</li> <li>Smart Invalidation: Automatic cache updates based on data freshness</li> <li>Memory Optimization: Efficient cache key management and eviction policies</li> </ul>"},{"location":"#observability-monitoring","title":"Observability &amp; Monitoring","text":"<ul> <li>Comprehensive Metrics: Prometheus-compatible metrics for full stack monitoring</li> <li>Structured Logging: JSON-formatted logs with request tracing</li> <li>Health Checks: Multi-level health monitoring for all dependencies</li> <li>Performance Analytics: Real-time performance insights and alerting</li> </ul>"},{"location":"#developer-experience","title":"Developer Experience","text":"<ul> <li>Type-Safe API: Full Pydantic model validation with comprehensive error handling</li> <li>Interactive Documentation: Auto-generated OpenAPI specs with Swagger UI and ReDoc</li> <li>Multi-Region Support: Complete coverage of all Riot API regions</li> <li>UV Integration: Modern Python package management with fast dependency resolution</li> </ul>"},{"location":"#production-ready","title":"Production Ready","text":"<ul> <li>Container-Native: Docker support with optimized images</li> <li>Security Hardened: Input validation, CORS protection, and secure defaults</li> <li>Configuration Management: Environment-based configuration with validation</li> <li>CI/CD Integration: Automated testing, documentation generation, and deployment</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.12+ with UV package manager</li> <li>Redis 6.0+ for caching and session management</li> <li>Riot Developer API key from developer.riotgames.com</li> </ul>"},{"location":"#installation-with-uv-recommended","title":"Installation with UV (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Install dependencies with UV\nuv pip install -e \".[docs]\"\n\n# Create environment configuration\ncp .env.example .env\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>Edit your <code>.env</code> file with your settings:</p> <pre><code># Required: Riot API Configuration\nRIOT_API_KEY=RGAPI-your-production-api-key\nRIOT_DEFAULT_REGION=euw1\n\n# Optional: Server Configuration\nHOST=0.0.0.0\nPORT=8080\nLOG_LEVEL=INFO\n\n# Optional: Redis Configuration\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=\n\n# Optional: Performance Tuning\nRIOT_RATE_LIMIT_PER_SECOND=20\nRIOT_RATE_LIMIT_PER_2MIN=100\n</code></pre>"},{"location":"#launch-the-gateway","title":"Launch the Gateway","text":"<pre><code># Start with uvicorn (development)\nuv run uvicorn app.main:app --reload\n\n# Or with the provided script\nuv run python -m app.main\n</code></pre>"},{"location":"#verify-installation","title":"Verify Installation","text":"<pre><code># Health check endpoint\ncurl http://127.0.0.1:8080/health\n\n# Expected response\n{\n  \"status\": \"ok\",\n  \"timestamp\": \"2024-01-01T12:00:00.000Z\",\n  \"version\": \"1.0.0\"\n}\n\n# Interactive documentation\n# Open http://localhost:8080/docs in your browser\n</code></pre>"},{"location":"#production-deployment","title":"Production Deployment","text":"<p>For production deployment, see our comprehensive Deployment Guide which covers: - Docker containerization - Process management with systemd - Nginx reverse proxy configuration - SSL/TLS setup with Let's Encrypt - Monitoring and alerting setup</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation Guide - Detailed setup instructions</li> <li>Quick Start - Basic usage examples</li> <li>Configuration - Environment variables and settings</li> <li>API Reference - Complete API documentation</li> <li>Architecture - System design and components</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Interactive API Docs: Swagger UI | ReDoc</li> <li>Riot Developer Portal: developer.riotgames.com</li> <li>GitHub Repository: github.com/OneStepAt4time/lolstonks-api-gateway</li> </ul>"},{"location":"#example-usage","title":"Example Usage","text":""},{"location":"#get-summoner-by-name","title":"Get Summoner by Name","text":"<pre><code>import httpx\n\nresponse = httpx.get(\"http://localhost:8080/summoner/by-name/Faker?region=kr\")\nsummoner = response.json()\nprint(f\"Summoner: {summoner['name']} (Level: {summoner['summonerLevel']})\")\n</code></pre>"},{"location":"#get-current-match","title":"Get Current Match","text":"<pre><code>summoner_id = \"summoner-id-here\"\nresponse = httpx.get(f\"http://localhost:8080/spectator/active-game/{summoner_id}?region=kr\")\ngame = response.json()\nprint(f\"Game mode: {game['gameMode']}, Game time: {game['gameLength']}s\")\n</code></pre>"},{"location":"#get-match-history","title":"Get Match History","text":"<pre><code>puuid = \"player-puuid-here\"\nresponse = httpx.get(f\"http://localhost:8080/match/ids/by-puuid/{puuid}?region=euw1&amp;count=5\")\nmatch_ids = response.json()\nprint(f\"Recent matches: {match_ids}\")\n</code></pre>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>The LOLStonks API Gateway consists of several key components:</p> <ul> <li>FastAPI Application: Modern async web framework with automatic documentation</li> <li>Riot Client: HTTP client with rate limiting and retry logic</li> <li>Redis Cache: High-performance caching layer for API responses</li> <li>Match Tracking: Service to prevent duplicate match processing</li> <li>Router Layer: Organized API endpoints mirroring Riot's API structure</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details on how to get started.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#development-status","title":"Development Status","text":"<ul> <li>Stable: Core API Gateway functionality</li> <li>Active Development: Documentation system, monitoring, and additional features</li> <li>Production Ready: Suitable for production deployments with proper monitoring</li> </ul> <p>Built for the League of Legends developer community</p>"},{"location":"API_COVERAGE_COMPLETE/","title":"Complete API Coverage Report","text":""},{"location":"API_COVERAGE_COMPLETE/#summary","title":"Summary","text":"<p>This document provides a comprehensive overview of all mapped API endpoints, models, and enums in the LOL API Gateway.</p> <p>Last Updated: After complete audit and enhancement Total Endpoints: 33 (32 Riot API + 1 health check) Total Pydantic Models: 50+ input validation models Total Enums: 7 comprehensive enums</p>"},{"location":"API_COVERAGE_COMPLETE/#enum-coverage","title":"\ud83c\udfaf Enum Coverage","text":""},{"location":"API_COVERAGE_COMPLETE/#complete-enums-appmodelscommonpy","title":"\u2705 Complete Enums (app/models/common.py)","text":""},{"location":"API_COVERAGE_COMPLETE/#1-platformregion","title":"1. PlatformRegion","text":"<p>Regional routing for platform endpoints (ACCOUNT-V1, MATCH-V5): - <code>AMERICAS</code> - <code>EUROPE</code> - <code>ASIA</code> - <code>SEA</code></p>"},{"location":"API_COVERAGE_COMPLETE/#2-gameregion","title":"2. GameRegion","text":"<p>All League of Legends game regions: - Europe: <code>EUW1</code>, <code>EUN1</code>, <code>TR1</code>, <code>RU</code> - Americas: <code>NA1</code>, <code>BR1</code>, <code>LA1</code>, <code>LA2</code> - Asia: <code>KR</code>, <code>JP1</code> - SEA/Oceania: <code>OC1</code>, <code>PH2</code>, <code>SG2</code>, <code>TH2</code>, <code>TW2</code>, <code>VN2</code></p>"},{"location":"API_COVERAGE_COMPLETE/#3-queuetype-enhanced","title":"3. QueueType (Enhanced)","text":"<p>Ranked queue types including TFT: - <code>RANKED_SOLO_5x5</code> - <code>RANKED_FLEX_SR</code> - <code>RANKED_FLEX_TT</code> - <code>RANKED_TFT</code> - <code>RANKED_TFT_TURBO</code> - <code>RANKED_TFT_DOUBLE_UP</code></p>"},{"location":"API_COVERAGE_COMPLETE/#4-tier-new","title":"4. Tier (NEW)","text":"<p>All ranked tiers from lowest to highest: - <code>IRON</code> - <code>BRONZE</code> - <code>SILVER</code> - <code>GOLD</code> - <code>PLATINUM</code> - <code>EMERALD</code> (Season 2023+) - <code>DIAMOND</code> - <code>MASTER</code> - <code>GRANDMASTER</code> - <code>CHALLENGER</code></p>"},{"location":"API_COVERAGE_COMPLETE/#5-division-new","title":"5. Division (NEW)","text":"<p>Divisions within tiers (Iron through Diamond): - <code>I</code> (highest) - <code>II</code> - <code>III</code> - <code>IV</code> (lowest)</p> <p>Note: Master, Grandmaster, and Challenger don't use divisions.</p>"},{"location":"API_COVERAGE_COMPLETE/#6-challengelevel-enhanced","title":"6. ChallengeLevel (Enhanced)","text":"<p>Challenge progression tiers (different from ranked tiers): - <code>NONE</code> - <code>IRON</code> - <code>BRONZE</code> - <code>SILVER</code> - <code>GOLD</code> - <code>PLATINUM</code> - <code>EMERALD</code> - <code>DIAMOND</code> - <code>MASTER</code> - <code>GRANDMASTER</code> - <code>CHALLENGER</code></p>"},{"location":"API_COVERAGE_COMPLETE/#api-coverage-by-service","title":"\ud83d\udcca API Coverage by Service","text":""},{"location":"API_COVERAGE_COMPLETE/#1-account-v1-3-endpoints","title":"1. ACCOUNT-V1 (3 endpoints) \u2705","text":"<p>Router: <code>app/routers/account.py</code> (Pydantic migrated) Models: <code>app/models/account.py</code></p> Endpoint Method Pydantic Models Status <code>/accounts/by-puuid/{puuid}</code> GET <code>AccountByPuuidParams</code>, <code>AccountByPuuidQuery</code> \u2705 <code>/accounts/by-riot-id/{gameName}/{tagLine}</code> GET <code>AccountByRiotIdParams</code>, <code>AccountByRiotIdQuery</code> \u2705 <code>/active-shards/by-game/{game}/by-puuid/{puuid}</code> GET <code>ActiveShardParams</code>, <code>ActiveShardQuery</code> \u2705 <p>Regional Routing: Uses <code>PlatformRegion</code> enum (americas, europe, asia, sea)</p>"},{"location":"API_COVERAGE_COMPLETE/#2-summoner-v4-3-endpoints","title":"2. SUMMONER-V4 (3 endpoints) \u23f3","text":"<p>Router: <code>app/routers/summoner.py</code> (NOT YET migrated to Pydantic) Models: <code>app/models/summoner.py</code> (ready)</p> Endpoint Method Pydantic Models Status <code>/summoners/by-name/{summonerName}</code> GET <code>SummonerByNameParams</code>, <code>SummonerByNameQuery</code> \u23f3 <code>/summoners/by-puuid/{encryptedPUUID}</code> GET <code>SummonerByPuuidParams</code>, <code>SummonerByPuuidQuery</code> \u23f3 <code>/summoners/{encryptedSummonerId}</code> GET <code>SummonerByIdParams</code>, <code>SummonerByIdQuery</code> \u23f3"},{"location":"API_COVERAGE_COMPLETE/#3-match-v5-3-endpoints","title":"3. MATCH-V5 (3 endpoints) \u2705","text":"<p>Router: <code>app/routers/match.py</code> (Pydantic migrated + NEW PARAMETERS) Models: <code>app/models/match.py</code></p> Endpoint Method Pydantic Models Status <code>/matches/by-puuid/{puuid}/ids</code> GET <code>MatchIdsByPuuidParams</code>, <code>MatchIdsByPuuidQuery</code> \u2705 NEW PARAMS <code>/matches/{matchId}</code> GET <code>MatchParams</code>, <code>MatchQuery</code> \u2705 <code>/matches/{matchId}/timeline</code> GET <code>MatchTimelineParams</code>, <code>MatchTimelineQuery</code> \u2705 <p>\ud83c\udd95 NEW Parameters in <code>/matches/by-puuid/{puuid}/ids</code>: - \u2705 <code>startTime</code> (Optional[int]) - Filter matches after timestamp - \u2705 <code>endTime</code> (Optional[int]) - Filter matches before timestamp - \u2705 <code>queue</code> (Optional[int]) - Filter by queue ID - \u2705 <code>type</code> (Optional[str]) - Filter by type (ranked, normal, tourney, tutorial)</p> <p>Regional Routing: Uses <code>PlatformRegion</code> enum</p>"},{"location":"API_COVERAGE_COMPLETE/#4-league-v4-5-endpoints","title":"4. LEAGUE-V4 (5 endpoints) \u23f3","text":"<p>Router: <code>app/routers/league.py</code> (1 NEW endpoint added, NOT yet migrated to Pydantic) Models: <code>app/models/league.py</code> (ready + enhanced)</p> Endpoint Method Pydantic Models Status <code>/challengerleagues/by-queue/{queue}</code> GET <code>LeagueByQueueParams</code>, <code>LeagueByQueueQuery</code> \u23f3 <code>/grandmasterleagues/by-queue/{queue}</code> GET <code>LeagueByQueueParams</code>, <code>LeagueByQueueQuery</code> \u23f3 <code>/masterleagues/by-queue/{queue}</code> GET <code>LeagueByQueueParams</code>, <code>LeagueByQueueQuery</code> \u23f3 <code>/entries/by-summoner/{encryptedSummonerId}</code> GET <code>LeagueEntriesBySummonerParams</code>, <code>LeagueEntriesBySummonerQuery</code> \u23f3 <code>/entries/{queue}/{tier}/{division}</code> GET <code>LeagueEntriesParams</code>, <code>LeagueEntriesQuery</code> \ud83c\udd95 ADDED <p>\ud83c\udd95 Models Enhanced: - Uses <code>Tier</code> enum for tier validation - Uses <code>Division</code> enum for division validation - Pagination support with <code>page</code> parameter</p>"},{"location":"API_COVERAGE_COMPLETE/#5-league-exp-v4-1-endpoint","title":"5. LEAGUE-EXP-V4 (1 endpoint) \ud83c\udd95","text":"<p>Router: <code>app/routers/league_exp.py</code> (NEW, with Pydantic) Models: <code>app/models/league_exp.py</code> (NEW)</p> Endpoint Method Pydantic Models Status <code>/entries/{queue}/{tier}/{division}</code> GET <code>LeagueExpEntriesParams</code>, <code>LeagueExpEntriesQuery</code> \ud83c\udd95 \u2705 <p>Note: This is an experimental API similar to LEAGUE-V4 but with different pagination handling.</p>"},{"location":"API_COVERAGE_COMPLETE/#6-champion-mastery-v4-4-endpoints","title":"6. CHAMPION-MASTERY-V4 (4 endpoints) \u23f3","text":"<p>Router: <code>app/routers/champion_mastery.py</code> (NOT yet migrated) Models: <code>app/models/champion_mastery.py</code> (ready)</p> Endpoint Method Pydantic Models Status <code>/champion-masteries/by-puuid/{puuid}</code> GET <code>ChampionMasteryByPuuidParams</code>, <code>ChampionMasteryByPuuidQuery</code> \u23f3 <code>/champion-masteries/by-puuid/{puuid}/by-champion/{championId}</code> GET <code>ChampionMasteryByPuuidByChampionParams</code>, <code>ChampionMasteryByPuuidByChampionQuery</code> \u23f3 <code>/champion-masteries/by-puuid/{puuid}/top</code> GET <code>TopChampionMasteriesParams</code>, <code>TopChampionMasteriesQuery</code> \u23f3 <code>/scores/by-puuid/{puuid}</code> GET <code>MasteryScoreParams</code>, <code>MasteryScoreQuery</code> \u23f3"},{"location":"API_COVERAGE_COMPLETE/#7-challenges-v1-5-endpoints","title":"7. CHALLENGES-V1 (5 endpoints) \u23f3","text":"<p>Router: <code>app/routers/challenges.py</code> (NOT yet migrated) Models: <code>app/models/challenges.py</code> (ready + enhanced)</p> Endpoint Method Pydantic Models Status <code>/challenges/config</code> GET <code>AllChallengesConfigQuery</code> \u23f3 <code>/challenges/{challengeId}/config</code> GET <code>ChallengeConfigParams</code>, <code>ChallengeConfigQuery</code> \u23f3 <code>/challenges/{challengeId}/leaderboards/by-level/{level}</code> GET <code>ChallengeLeaderboardParams</code>, <code>ChallengeLeaderboardQuery</code> \u23f3 <code>/challenges/{challengeId}/percentiles</code> GET <code>ChallengePercentilesParams</code>, <code>ChallengePercentilesQuery</code> \u23f3 <code>/player-data/{puuid}</code> GET <code>PlayerChallengesParams</code>, <code>PlayerChallengesQuery</code> \u23f3 <p>Enhanced: Uses complete <code>ChallengeLevel</code> enum (NONE through CHALLENGER)</p>"},{"location":"API_COVERAGE_COMPLETE/#8-clash-v1-5-endpoints","title":"8. CLASH-V1 (5 endpoints) \u23f3","text":"<p>Router: <code>app/routers/clash.py</code> (NOT yet migrated) Models: <code>app/models/clash.py</code> (ready)</p> Endpoint Method Pydantic Models Status <code>/players/by-puuid/{puuid}</code> GET <code>ClashPlayerParams</code>, <code>ClashPlayerQuery</code> \u23f3 <code>/teams/{teamId}</code> GET <code>ClashTeamParams</code>, <code>ClashTeamQuery</code> \u23f3 <code>/tournaments</code> GET <code>ClashTournamentsQuery</code> \u23f3 <code>/tournaments/{tournamentId}</code> GET <code>ClashTournamentParams</code>, <code>ClashTournamentQuery</code> \u23f3 <code>/tournaments/by-team/{teamId}</code> GET <code>ClashTournamentByTeamParams</code>, <code>ClashTournamentByTeamQuery</code> \u23f3"},{"location":"API_COVERAGE_COMPLETE/#9-spectator-v5-2-endpoints","title":"9. SPECTATOR-V5 (2 endpoints) \u23f3","text":"<p>Router: <code>app/routers/spectator.py</code> (NOT yet migrated) Models: <code>app/models/spectator.py</code> (ready)</p> Endpoint Method Pydantic Models Status <code>/active-games/by-summoner/{puuid}</code> GET <code>ActiveGameParams</code>, <code>ActiveGameQuery</code> \u23f3 <code>/featured-games</code> GET <code>FeaturedGamesQuery</code> \u23f3"},{"location":"API_COVERAGE_COMPLETE/#10-lol-status-v4-platform-1-endpoint","title":"10. LOL-STATUS-V4 / PLATFORM (1 endpoint) \u23f3","text":"<p>Router: <code>app/routers/platform.py</code> (NOT yet migrated) Models: <code>app/models/platform.py</code> (ready)</p> Endpoint Method Pydantic Models Status <code>/platform-data</code> GET <code>PlatformStatusQuery</code> \u23f3"},{"location":"API_COVERAGE_COMPLETE/#11-champion-v3-1-endpoint","title":"11. CHAMPION-V3 (1 endpoint) \u23f3","text":"<p>Router: <code>app/routers/champion.py</code> (NOT yet migrated) Models: <code>app/models/champion.py</code> (ready)</p> Endpoint Method Pydantic Models Status <code>/champion-rotations</code> GET <code>ChampionRotationsQuery</code> \u23f3"},{"location":"API_COVERAGE_COMPLETE/#12-health-1-endpoint","title":"12. HEALTH (1 endpoint) \u2705","text":"<p>Router: <code>app/routers/health.py</code> No models needed - Simple health check endpoint</p> Endpoint Method Status <code>/health</code> GET \u2705"},{"location":"API_COVERAGE_COMPLETE/#model-files-structure","title":"\ud83d\udce6 Model Files Structure","text":"<pre><code>app/models/\n\u251c\u2500\u2500 __init__.py              \u2705 Updated with all exports\n\u251c\u2500\u2500 common.py                \u2705 Enhanced (7 enums, 3 base models)\n\u251c\u2500\u2500 account.py               \u2705 Complete (6 models)\n\u251c\u2500\u2500 summoner.py              \u2705 Complete (6 models)\n\u251c\u2500\u2500 match.py                 \u2705 Enhanced (6 models + new params)\n\u251c\u2500\u2500 league.py                \u2705 Enhanced (6 models + Tier/Division)\n\u251c\u2500\u2500 league_exp.py            \ud83c\udd95 NEW (2 models)\n\u251c\u2500\u2500 champion_mastery.py      \u2705 Complete (8 models)\n\u251c\u2500\u2500 challenges.py            \u2705 Enhanced (10 models)\n\u251c\u2500\u2500 clash.py                 \u2705 Complete (10 models)\n\u251c\u2500\u2500 spectator.py             \u2705 Complete (4 models)\n\u251c\u2500\u2500 platform.py              \u2705 Complete (1 model)\n\u2514\u2500\u2500 champion.py              \u2705 Complete (1 model)\n</code></pre> <p>Total: 13 model files, 70+ models</p>"},{"location":"API_COVERAGE_COMPLETE/#migration-status","title":"\ud83c\udfaf Migration Status","text":""},{"location":"API_COVERAGE_COMPLETE/#completed-211-apis","title":"\u2705 Completed (2/11 APIs)","text":"<ol> <li>ACCOUNT-V1 - All 3 endpoints migrated to Pydantic</li> <li>MATCH-V5 - All 3 endpoints migrated + NEW optional parameters added</li> </ol>"},{"location":"API_COVERAGE_COMPLETE/#new-1-api","title":"\ud83c\udd95 NEW (1 API)","text":"<ol> <li>LEAGUE-EXP-V4 - Created router + models, registered in main.py</li> </ol>"},{"location":"API_COVERAGE_COMPLETE/#pending-migration-811-apis","title":"\u23f3 Pending Migration (8/11 APIs)","text":"<ol> <li>SUMMONER-V4 (3 endpoints)</li> <li>LEAGUE-V4 (5 endpoints - 1 endpoint ADDED)</li> <li>CHAMPION-MASTERY-V4 (4 endpoints)</li> <li>CHALLENGES-V1 (5 endpoints)</li> <li>CLASH-V1 (5 endpoints)</li> <li>SPECTATOR-V5 (2 endpoints)</li> <li>PLATFORM (1 endpoint)</li> <li>CHAMPION-V3 (1 endpoint)</li> </ol> <p>Total to migrate: 26 endpoints</p>"},{"location":"API_COVERAGE_COMPLETE/#what-was-addedfixed","title":"\ud83c\udd95 What Was Added/Fixed","text":""},{"location":"API_COVERAGE_COMPLETE/#1-missing-enums","title":"1. Missing Enums","text":"<p>\u2705 <code>Tier</code> - All ranked tiers (IRON through CHALLENGER) \u2705 <code>Division</code> - Divisions I through IV \u2705 <code>ChallengeLevel</code> - Enhanced with NONE and EMERALD \u2705 <code>QueueType</code> - Added TFT queue types</p>"},{"location":"API_COVERAGE_COMPLETE/#2-missing-endpoints","title":"2. Missing Endpoints","text":"<p>\u2705 <code>LEAGUE-V4: /entries/{queue}/{tier}/{division}</code> - Added to league.py router \u2705 <code>LEAGUE-EXP-V4: /entries/{queue}/{tier}/{division}</code> - NEW router created</p>"},{"location":"API_COVERAGE_COMPLETE/#3-missing-parameters","title":"3. Missing Parameters","text":"<p>\u2705 <code>MATCH-V5: /matches/by-puuid/{puuid}/ids</code> - Added startTime, endTime, queue, type</p>"},{"location":"API_COVERAGE_COMPLETE/#4-enhanced-models","title":"4. Enhanced Models","text":"<p>\u2705 <code>league.py</code> models - Now use Tier and Division enums \u2705 <code>league_exp.py</code> models - NEW models for experimental API \u2705 <code>match.py</code> models - Enhanced with all optional filters</p>"},{"location":"API_COVERAGE_COMPLETE/#next-steps","title":"\ud83d\udcdd Next Steps","text":""},{"location":"API_COVERAGE_COMPLETE/#priority-1-complete-pydantic-migration","title":"Priority 1: Complete Pydantic Migration","text":"<p>Migrate remaining 8 routers to use Pydantic models (26 endpoints total).</p>"},{"location":"API_COVERAGE_COMPLETE/#priority-2-response-models","title":"Priority 2: Response Models","text":"<p>Create Pydantic models for API responses (currently only input validation exists).</p>"},{"location":"API_COVERAGE_COMPLETE/#priority-3-openapi-enhancement","title":"Priority 3: OpenAPI Enhancement","text":"<p>With complete input models, the OpenAPI documentation will be fully typed and validated.</p>"},{"location":"API_COVERAGE_COMPLETE/#verification-checklist","title":"\ud83d\udd0d Verification Checklist","text":"<ul> <li>[x] All Riot API enums mapped (Tier, Division, QueueType, ChallengeLevel)</li> <li>[x] LEAGUE-EXP-V4 API added</li> <li>[x] Missing LEAGUE-V4 endpoint added</li> <li>[x] Missing MATCH-V5 parameters added</li> <li>[x] All model files created and exported</li> <li>[x] LEAGUE-EXP-V4 router registered in main.py</li> <li>[ ] Remaining routers migrated to Pydantic</li> <li>[ ] Response models created</li> <li>[ ] Full integration testing</li> </ul> <p>Status: \ud83d\udfe2 Models Complete | \ud83d\udfe1 Partial Router Migration | \ud83d\udd34 Testing Needed</p>"},{"location":"api/cache/","title":"Caching System","text":"<p>This section documents the caching infrastructure used throughout the API Gateway for performance optimization and rate limit compliance.</p>"},{"location":"api/cache/#redis-cache-configuration","title":"Redis Cache Configuration","text":""},{"location":"api/cache/#app.cache.redis_cache","title":"<code>app.cache.redis_cache</code>","text":"<p>Redis cache configuration using aiocache.</p> <p>Provides temporary TTL-based caching for API responses. Cache keys follow pattern: {resource}:{region}:{identifier}</p>"},{"location":"api/cache/#match-tracking-service","title":"Match Tracking Service","text":""},{"location":"api/cache/#app.cache.tracking","title":"<code>app.cache.tracking</code>","text":"<p>Match tracking service using Redis SETs.</p> <p>Provides permanent tracking of processed matches to avoid reprocessing. Uses Redis SETs with NO TTL - data persists across restarts via appendonly file.</p>"},{"location":"api/cache/#app.cache.tracking.MatchTracker","title":"<code>MatchTracker()</code>","text":"<p>Track processed matches in Redis using SET data structure.</p> <p>Key pattern: processed_matches:{region} No TTL - permanent storage backed by Redis appendonly file.</p> <p>Initialize tracker (connection established on startup).</p> Source code in <code>app/cache/tracking.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize tracker (connection established on startup).\"\"\"\n    self.redis: redis.Redis | None = None\n    logger.info(\"Match tracker initialized (connection pending)\")\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Establish Redis connection.</p> <p>Should be called during FastAPI startup event.</p> Source code in <code>app/cache/tracking.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Establish Redis connection.\n\n    Should be called during FastAPI startup event.\n    \"\"\"\n    redis_url = f\"redis://{settings.redis_host}:{settings.redis_port}/{settings.redis_db}\"\n    if settings.redis_password:\n        redis_url = f\"redis://:{settings.redis_password}@{settings.redis_host}:{settings.redis_port}/{settings.redis_db}\"\n\n    self.redis = await redis.from_url(redis_url, decode_responses=True)\n    logger.success(\"Match tracker connected to Redis\")\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close Redis connection.</p> Source code in <code>app/cache/tracking.py</code> <pre><code>async def close(self):\n    \"\"\"Close Redis connection.\"\"\"\n    if self.redis:\n        await self.redis.aclose()  # type: ignore[attr-defined]\n        logger.info(\"Match tracker connection closed\")\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.is_processed","title":"<code>is_processed(region: str, match_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Check if a match has already been processed.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1')</p> required <code>match_id</code> <code>str</code> <p>Match ID (e.g., 'EUW1_123456789')</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if match is in tracking set, False otherwise</p> Source code in <code>app/cache/tracking.py</code> <pre><code>async def is_processed(self, region: str, match_id: str) -&gt; bool:\n    \"\"\"\n    Check if a match has already been processed.\n\n    Args:\n        region: Region code (e.g., 'euw1')\n        match_id: Match ID (e.g., 'EUW1_123456789')\n\n    Returns:\n        True if match is in tracking set, False otherwise\n    \"\"\"\n    if not self.redis:\n        logger.warning(\"Redis not connected, assuming match not processed\")\n        return False\n\n    key = f\"processed_matches:{region}\"\n    is_member = await self.redis.sismember(key, match_id)\n    return bool(is_member)\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.mark_processed","title":"<code>mark_processed(region: str, match_id: str)</code>  <code>async</code>","text":"<p>Mark a match as processed.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1')</p> required <code>match_id</code> <code>str</code> <p>Match ID (e.g., 'EUW1_123456789')</p> required Source code in <code>app/cache/tracking.py</code> <pre><code>async def mark_processed(self, region: str, match_id: str):\n    \"\"\"\n    Mark a match as processed.\n\n    Args:\n        region: Region code (e.g., 'euw1')\n        match_id: Match ID (e.g., 'EUW1_123456789')\n    \"\"\"\n    if not self.redis:\n        logger.warning(\"Redis not connected, cannot mark match as processed\")\n        return\n\n    key = f\"processed_matches:{region}\"\n    await self.redis.sadd(key, match_id)\n    logger.debug(\"Marked match as processed: {}/{}\", region, match_id)\n</code></pre>"},{"location":"api/cache/#app.cache.tracking.MatchTracker.get_processed_count","title":"<code>get_processed_count(region: str) -&gt; int</code>  <code>async</code>","text":"<p>Get count of processed matches for a region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1')</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of tracked matches for the region</p> Source code in <code>app/cache/tracking.py</code> <pre><code>async def get_processed_count(self, region: str) -&gt; int:\n    \"\"\"\n    Get count of processed matches for a region.\n\n    Args:\n        region: Region code (e.g., 'euw1')\n\n    Returns:\n        Number of tracked matches for the region\n    \"\"\"\n    if not self.redis:\n        return 0\n\n    key = f\"processed_matches:{region}\"\n    return await self.redis.scard(key)\n</code></pre>"},{"location":"api/models/","title":"Pydantic Models","text":"<p>This section contains all the Pydantic models used throughout the API Gateway for request/response validation and data serialization.</p>"},{"location":"api/models/#common-models","title":"Common Models","text":""},{"location":"api/models/#app.models.common","title":"<code>app.models.common</code>","text":"<p>Common reusable models for API inputs.</p> <p>These models contain shared parameters used across multiple endpoints.</p>"},{"location":"api/models/#app.models.common.PlatformRegion","title":"<code>PlatformRegion</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Platform regions for regional routing (ACCOUNT, MATCH APIs).</p>"},{"location":"api/models/#app.models.common.GameRegion","title":"<code>GameRegion</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Game regions for platform-specific endpoints.</p>"},{"location":"api/models/#app.models.common.QueueType","title":"<code>QueueType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Queue types for League of Legends.</p> <p>Includes ranked, normal, and special game modes.</p>"},{"location":"api/models/#app.models.common.Tier","title":"<code>Tier</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>League tier/rank levels.</p> <p>Used for: - Ranked league entries and progression (IRON \u2192 CHALLENGER) - Challenge progression (all tiers) - Challenge leaderboards (MASTER, GRANDMASTER, CHALLENGER only)</p>"},{"location":"api/models/#app.models.common.Division","title":"<code>Division</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Division within a tier.</p> <p>Used for Iron through Diamond (and Emerald) tiers. Master, Grandmaster, and Challenger don't use divisions.</p>"},{"location":"api/models/#app.models.common.EnumBaseModel","title":"<code>EnumBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model that serializes enums as values.</p>"},{"location":"api/models/#app.models.common.RegionQuery","title":"<code>RegionQuery</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Standard region query parameter for game-specific endpoints.</p>"},{"location":"api/models/#app.models.common.PlatformRegionQuery","title":"<code>PlatformRegionQuery</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Regional routing parameter for platform endpoints (ACCOUNT, MATCH).</p>"},{"location":"api/models/#app.models.common.PaginationQuery","title":"<code>PaginationQuery</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pagination parameters for list endpoints.</p>"},{"location":"api/models/#app.models.common.HasPuuid","title":"<code>HasPuuid</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a PUUID path parameter.</p>"},{"location":"api/models/#app.models.common.HasEncryptedSummonerId","title":"<code>HasEncryptedSummonerId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include an encrypted summoner ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasEncryptedPuuid","title":"<code>HasEncryptedPuuid</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include an encrypted PUUID path parameter.</p>"},{"location":"api/models/#app.models.common.HasMatchId","title":"<code>HasMatchId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a match ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasChampionId","title":"<code>HasChampionId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a champion ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasChallengeId","title":"<code>HasChallengeId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a challenge ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasTeamId","title":"<code>HasTeamId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a team ID path parameter.</p>"},{"location":"api/models/#app.models.common.HasTournamentId","title":"<code>HasTournamentId</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a tournament ID path parameter.</p>"},{"location":"api/models/#model-classes","title":"Model Classes","text":"<p>The following model classes provide request/response schemas for various Riot API endpoints:</p>"},{"location":"api/models/#account-models","title":"Account Models","text":""},{"location":"api/models/#app.models.account","title":"<code>app.models.account</code>","text":"<p>ACCOUNT-V1 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#account-v1</p>"},{"location":"api/models/#app.models.account.AccountByPuuidParams","title":"<code>AccountByPuuidParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /riot/account/v1/accounts/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.account.AccountByPuuidQuery","title":"<code>AccountByPuuidQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /riot/account/v1/accounts/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.account.AccountByRiotIdParams","title":"<code>AccountByRiotIdParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Path parameters for GET /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}.</p>"},{"location":"api/models/#app.models.account.AccountByRiotIdQuery","title":"<code>AccountByRiotIdQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}.</p>"},{"location":"api/models/#app.models.account.ActiveShardParams","title":"<code>ActiveShardParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.account.ActiveShardQuery","title":"<code>ActiveShardQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}.</p>"},{"location":"api/models/#summoner-models","title":"Summoner Models","text":""},{"location":"api/models/#app.models.summoner","title":"<code>app.models.summoner</code>","text":"<p>SUMMONER-V4 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#summoner-v4</p>"},{"location":"api/models/#app.models.summoner.SummonerByNameParams","title":"<code>SummonerByNameParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Path parameters for GET /lol/summoner/v4/summoners/by-name/{summonerName}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByNameQuery","title":"<code>SummonerByNameQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/summoner/v4/summoners/by-name/{summonerName}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByPuuidParams","title":"<code>SummonerByPuuidParams</code>","text":"<p>               Bases: <code>HasEncryptedPuuid</code></p> <p>Path parameters for GET /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByPuuidQuery","title":"<code>SummonerByPuuidQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByIdParams","title":"<code>SummonerByIdParams</code>","text":"<p>               Bases: <code>HasEncryptedSummonerId</code></p> <p>Path parameters for GET /lol/summoner/v4/summoners/{encryptedSummonerId}.</p>"},{"location":"api/models/#app.models.summoner.SummonerByIdQuery","title":"<code>SummonerByIdQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/summoner/v4/summoners/{encryptedSummonerId}.</p>"},{"location":"api/models/#match-models","title":"Match Models","text":""},{"location":"api/models/#app.models.match","title":"<code>app.models.match</code>","text":"<p>MATCH-V5 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#match-v5</p>"},{"location":"api/models/#app.models.match.MatchIdsByPuuidParams","title":"<code>MatchIdsByPuuidParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/match/v5/matches/by-puuid/{puuid}/ids.</p>"},{"location":"api/models/#app.models.match.MatchIdsByPuuidQuery","title":"<code>MatchIdsByPuuidQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code>, <code>PaginationQuery</code></p> <p>Query parameters for GET /lol/match/v5/matches/by-puuid/{puuid}/ids.</p> <p>Includes optional filtering parameters for match discovery.</p>"},{"location":"api/models/#app.models.match.MatchParams","title":"<code>MatchParams</code>","text":"<p>               Bases: <code>HasMatchId</code></p> <p>Path parameters for GET /lol/match/v5/matches/{matchId}.</p>"},{"location":"api/models/#app.models.match.MatchQuery","title":"<code>MatchQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /lol/match/v5/matches/{matchId}.</p>"},{"location":"api/models/#app.models.match.MatchTimelineParams","title":"<code>MatchTimelineParams</code>","text":"<p>               Bases: <code>HasMatchId</code></p> <p>Path parameters for GET /lol/match/v5/matches/{matchId}/timeline.</p>"},{"location":"api/models/#app.models.match.MatchTimelineQuery","title":"<code>MatchTimelineQuery</code>","text":"<p>               Bases: <code>PlatformRegionQuery</code></p> <p>Query parameters for GET /lol/match/v5/matches/{matchId}/timeline.</p>"},{"location":"api/models/#league-models","title":"League Models","text":""},{"location":"api/models/#app.models.league","title":"<code>app.models.league</code>","text":"<p>LEAGUE-V4 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#league-v4</p>"},{"location":"api/models/#app.models.league.LeagueByQueueParams","title":"<code>LeagueByQueueParams</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Path parameters for challenger/grandmaster/master league endpoints.</p>"},{"location":"api/models/#app.models.league.LeagueByQueueQuery","title":"<code>LeagueByQueueQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for challenger/grandmaster/master league endpoints.</p>"},{"location":"api/models/#app.models.league.LeagueEntriesBySummonerParams","title":"<code>LeagueEntriesBySummonerParams</code>","text":"<p>               Bases: <code>HasEncryptedSummonerId</code></p> <p>Path parameters for GET /lol/league/v4/entries/by-summoner/{encryptedSummonerId}.</p>"},{"location":"api/models/#app.models.league.LeagueEntriesBySummonerQuery","title":"<code>LeagueEntriesBySummonerQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/league/v4/entries/by-summoner/{encryptedSummonerId}.</p>"},{"location":"api/models/#app.models.league.LeagueEntriesParams","title":"<code>LeagueEntriesParams</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Path parameters for GET /lol/league/v4/entries/{queue}/{tier}/{division}.</p>"},{"location":"api/models/#app.models.league.LeagueEntriesQuery","title":"<code>LeagueEntriesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/league/v4/entries/{queue}/{tier}/{division}.</p>"},{"location":"api/models/#league-exp-models","title":"League EXP Models","text":""},{"location":"api/models/#app.models.league_exp","title":"<code>app.models.league_exp</code>","text":"<p>LEAGUE-EXP-V4 API input models (Experimental).</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#league-exp-v4</p> <p>Note: This is an experimental API that provides paginated league entries. It's similar to LEAGUE-V4 but with different pagination support.</p>"},{"location":"api/models/#app.models.league_exp.LeagueExpEntriesParams","title":"<code>LeagueExpEntriesParams</code>","text":"<p>               Bases: <code>EnumBaseModel</code></p> <p>Path parameters for GET /lol/league-exp/v4/entries/{queue}/{tier}/{division}.</p>"},{"location":"api/models/#app.models.league_exp.LeagueExpEntriesQuery","title":"<code>LeagueExpEntriesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/league-exp/v4/entries/{queue}/{tier}/{division}.</p>"},{"location":"api/models/#champion-mastery-models","title":"Champion Mastery Models","text":""},{"location":"api/models/#app.models.champion_mastery","title":"<code>app.models.champion_mastery</code>","text":"<p>CHAMPION-MASTERY-V4 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#champion-mastery-v4</p>"},{"location":"api/models/#app.models.champion_mastery.ChampionMasteryByPuuidParams","title":"<code>ChampionMasteryByPuuidParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.champion_mastery.ChampionMasteryByPuuidQuery","title":"<code>ChampionMasteryByPuuidQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.champion_mastery.ChampionMasteryByPuuidByChampionParams","title":"<code>ChampionMasteryByPuuidByChampionParams</code>","text":"<p>               Bases: <code>HasPuuid</code>, <code>HasChampionId</code></p> <p>Path parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}.</p>"},{"location":"api/models/#app.models.champion_mastery.ChampionMasteryByPuuidByChampionQuery","title":"<code>ChampionMasteryByPuuidByChampionQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}.</p>"},{"location":"api/models/#app.models.champion_mastery.TopChampionMasteriesParams","title":"<code>TopChampionMasteriesParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top.</p>"},{"location":"api/models/#app.models.champion_mastery.TopChampionMasteriesQuery","title":"<code>TopChampionMasteriesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top.</p>"},{"location":"api/models/#app.models.champion_mastery.MasteryScoreParams","title":"<code>MasteryScoreParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/champion-mastery/v4/scores/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.champion_mastery.MasteryScoreQuery","title":"<code>MasteryScoreQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/champion-mastery/v4/scores/by-puuid/{puuid}.</p>"},{"location":"api/models/#challenges-models","title":"Challenges Models","text":""},{"location":"api/models/#app.models.challenges","title":"<code>app.models.challenges</code>","text":"<p>CHALLENGES-V1 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#lol-challenges-v1</p>"},{"location":"api/models/#app.models.challenges.AllChallengesConfigQuery","title":"<code>AllChallengesConfigQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/challenges/config.</p>"},{"location":"api/models/#app.models.challenges.ChallengeConfigParams","title":"<code>ChallengeConfigParams</code>","text":"<p>               Bases: <code>HasChallengeId</code></p> <p>Path parameters for GET /lol/challenges/v1/challenges/{challengeId}/config.</p>"},{"location":"api/models/#app.models.challenges.ChallengeConfigQuery","title":"<code>ChallengeConfigQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/challenges/{challengeId}/config.</p>"},{"location":"api/models/#app.models.challenges.ChallengeLeaderboardParams","title":"<code>ChallengeLeaderboardParams</code>","text":"<p>               Bases: <code>EnumBaseModel</code>, <code>HasChallengeId</code></p> <p>Path parameters for GET /lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}.</p> <p>Note: Leaderboards are only available for top tiers (MASTER, GRANDMASTER, CHALLENGER).</p>"},{"location":"api/models/#app.models.challenges.ChallengeLeaderboardQuery","title":"<code>ChallengeLeaderboardQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}.</p>"},{"location":"api/models/#app.models.challenges.ChallengePercentilesParams","title":"<code>ChallengePercentilesParams</code>","text":"<p>               Bases: <code>HasChallengeId</code></p> <p>Path parameters for GET /lol/challenges/v1/challenges/{challengeId}/percentiles.</p>"},{"location":"api/models/#app.models.challenges.ChallengePercentilesQuery","title":"<code>ChallengePercentilesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/challenges/{challengeId}/percentiles.</p>"},{"location":"api/models/#app.models.challenges.PlayerChallengesParams","title":"<code>PlayerChallengesParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/challenges/v1/player-data/{puuid}.</p>"},{"location":"api/models/#app.models.challenges.PlayerChallengesQuery","title":"<code>PlayerChallengesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/challenges/v1/player-data/{puuid}.</p>"},{"location":"api/models/#clash-models","title":"Clash Models","text":""},{"location":"api/models/#app.models.clash","title":"<code>app.models.clash</code>","text":"<p>CLASH-V1 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#clash-v1</p>"},{"location":"api/models/#app.models.clash.ClashPlayerParams","title":"<code>ClashPlayerParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/clash/v1/players/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.clash.ClashPlayerQuery","title":"<code>ClashPlayerQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/players/by-puuid/{puuid}.</p>"},{"location":"api/models/#app.models.clash.ClashTeamParams","title":"<code>ClashTeamParams</code>","text":"<p>               Bases: <code>HasTeamId</code></p> <p>Path parameters for GET /lol/clash/v1/teams/{teamId}.</p>"},{"location":"api/models/#app.models.clash.ClashTeamQuery","title":"<code>ClashTeamQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/teams/{teamId}.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentsQuery","title":"<code>ClashTournamentsQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/tournaments.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentParams","title":"<code>ClashTournamentParams</code>","text":"<p>               Bases: <code>HasTournamentId</code></p> <p>Path parameters for GET /lol/clash/v1/tournaments/{tournamentId}.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentQuery","title":"<code>ClashTournamentQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/tournaments/{tournamentId}.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentByTeamParams","title":"<code>ClashTournamentByTeamParams</code>","text":"<p>               Bases: <code>HasTeamId</code></p> <p>Path parameters for GET /lol/clash/v1/tournaments/by-team/{teamId}.</p>"},{"location":"api/models/#app.models.clash.ClashTournamentByTeamQuery","title":"<code>ClashTournamentByTeamQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/clash/v1/tournaments/by-team/{teamId}.</p>"},{"location":"api/models/#spectator-models","title":"Spectator Models","text":""},{"location":"api/models/#app.models.spectator","title":"<code>app.models.spectator</code>","text":"<p>SPECTATOR-V5 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#spectator-v5</p>"},{"location":"api/models/#app.models.spectator.ActiveGameParams","title":"<code>ActiveGameParams</code>","text":"<p>               Bases: <code>HasPuuid</code></p> <p>Path parameters for GET /lol/spectator/v5/active-games/by-summoner/{puuid}.</p>"},{"location":"api/models/#app.models.spectator.ActiveGameQuery","title":"<code>ActiveGameQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/spectator/v5/active-games/by-summoner/{puuid}.</p>"},{"location":"api/models/#app.models.spectator.FeaturedGamesQuery","title":"<code>FeaturedGamesQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/spectator/v5/featured-games.</p>"},{"location":"api/models/#platform-models","title":"Platform Models","text":""},{"location":"api/models/#app.models.platform","title":"<code>app.models.platform</code>","text":"<p>LOL-STATUS-V4 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#lol-status-v4</p>"},{"location":"api/models/#app.models.platform.PlatformStatusQuery","title":"<code>PlatformStatusQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/status/v4/platform-data.</p>"},{"location":"api/models/#champion-models","title":"Champion Models","text":""},{"location":"api/models/#app.models.champion","title":"<code>app.models.champion</code>","text":"<p>CHAMPION-V3 API input models.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#champion-v3</p>"},{"location":"api/models/#app.models.champion.ChampionRotationsQuery","title":"<code>ChampionRotationsQuery</code>","text":"<p>               Bases: <code>RegionQuery</code></p> <p>Query parameters for GET /lol/platform/v3/champion-rotations.</p>"},{"location":"api/openapi-spec/","title":"OpenAPI Specification","text":"<p>This page provides an interactive API documentation using Swagger UI.</p>"},{"location":"api/openapi-spec/#interactive-api-documentation","title":"Interactive API Documentation","text":""},{"location":"api/openapi-spec/#download-specification","title":"Download Specification","text":"<p>You can download the OpenAPI specification in JSON format:</p> <ul> <li>Download OpenAPI JSON</li> </ul>"},{"location":"api/openapi-spec/#api-overview","title":"API Overview","text":"<p>The LOLStonks API Gateway provides a comprehensive REST API for accessing Riot Games data with built-in caching, rate limiting, and enhanced functionality.</p>"},{"location":"api/openapi-spec/#base-url","title":"Base URL","text":"<pre><code>http://localhost:8000\n</code></pre>"},{"location":"api/openapi-spec/#authentication","title":"Authentication","text":"<p>The API requires a Riot Games API key passed via the <code>X-Riot-Token</code> header or configured in the server environment.</p>"},{"location":"api/openapi-spec/#rate-limiting","title":"Rate Limiting","text":"<p>The gateway implements intelligent rate limiting to comply with Riot Games API limits: - Automatic retry with exponential backoff - Request queuing - Rate limit status in response headers</p>"},{"location":"api/openapi-spec/#caching","title":"Caching","text":"<p>Responses are cached in Redis with configurable TTL based on endpoint type: - Static data: Long TTL (hours/days) - Dynamic data: Short TTL (minutes) - Real-time data: No cache or very short TTL</p>"},{"location":"api/openapi-spec/#error-handling","title":"Error Handling","text":"<p>Standard HTTP status codes are used: - <code>200</code> - Success - <code>400</code> - Bad Request - <code>404</code> - Not Found - <code>429</code> - Rate Limit Exceeded - <code>500</code> - Internal Server Error - <code>502</code> - Bad Gateway (Riot API error)</p>"},{"location":"api/overview/","title":"LOL API Gateway","text":"<p>Intelligent proxy for Riot Games API with caching, rate limiting, and match tracking</p> <p>Version: 1.0.0</p> <p>Generated: 2025-10-28 18:34:54 UTC</p>"},{"location":"api/overview/#api-statistics","title":"API Statistics","text":"<ul> <li>Total Endpoints: 34</li> <li>Total Schemas: 7</li> <li>API Base URL: <code>http://localhost:8080</code></li> </ul>"},{"location":"api/overview/#interactive-documentation","title":"Interactive Documentation","text":"<p>When the server is running, you can access:</p> <ul> <li>Swagger UI: http://localhost:8080/docs</li> <li>ReDoc: http://localhost:8080/redoc</li> <li>OpenAPI JSON: http://localhost:8080/openapi.json</li> </ul>"},{"location":"api/overview/#api-endpoints","title":"API Endpoints","text":""},{"location":"api/overview/#health","title":"health","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/health</code> Health Check None Unknown"},{"location":"api/overview/#challenges","title":"challenges","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/challenges/v1/challenges/config</code> Get All Challenges Config Query: region Unknown \ud83d\udfe2 GET <code>/lol/challenges/v1/challenges/{challengeId}/config</code> Get Challenge Config Path: challengeIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}</code> Get Challenge Leaderboard Path: challengeId, levelQuery: region, limit Unknown \ud83d\udfe2 GET <code>/lol/challenges/v1/challenges/{challengeId}/percentiles</code> Get Challenge Percentiles Path: challengeIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/challenges/v1/player-data/{puuid}</code> Get Player Challenges Path: puuidQuery: region Unknown"},{"location":"api/overview/#champion-mastery","title":"champion-mastery","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}</code> Get All Champion Masteries Path: puuidQuery: region Unknown \ud83d\udfe2 GET <code>/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}</code> Get Champion Mastery Path: puuid, championIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top</code> Get Top Champion Masteries Path: puuidQuery: region, count Unknown \ud83d\udfe2 GET <code>/lol/champion-mastery/v4/scores/by-puuid/{puuid}</code> Get Mastery Score Path: puuidQuery: region Unknown"},{"location":"api/overview/#clash","title":"clash","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/clash/v1/players/by-puuid/{puuid}</code> Get Clash Player Path: puuidQuery: region Unknown \ud83d\udfe2 GET <code>/lol/clash/v1/teams/{teamId}</code> Get Clash Team Path: teamIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/clash/v1/tournaments</code> Get Clash Tournaments Query: region Unknown \ud83d\udfe2 GET <code>/lol/clash/v1/tournaments/by-team/{teamId}</code> Get Clash Tournament By Team Path: teamIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/clash/v1/tournaments/{tournamentId}</code> Get Clash Tournament Path: tournamentIdQuery: region Unknown"},{"location":"api/overview/#league-exp","title":"league-exp","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/league-exp/v4/entries/{queue}/{tier}/{division}</code> Get League Exp Entries Path: queue, tier, divisionQuery: region, page Unknown"},{"location":"api/overview/#league","title":"league","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/league/v4/challengerleagues/by-queue/{queue}</code> Get Challenger League Path: queueQuery: region Unknown \ud83d\udfe2 GET <code>/lol/league/v4/entries/by-summoner/{encryptedSummonerId}</code> Get League Entries By Summoner Path: encryptedSummonerIdQuery: region Unknown \ud83d\udfe2 GET <code>/lol/league/v4/entries/{queue}/{tier}/{division}</code> Get League Entries Path: queue, tier, divisionQuery: region, page Unknown \ud83d\udfe2 GET <code>/lol/league/v4/grandmasterleagues/by-queue/{queue}</code> Get Grandmaster League Path: queueQuery: region Unknown \ud83d\udfe2 GET <code>/lol/league/v4/masterleagues/by-queue/{queue}</code> Get Master League Path: queueQuery: region Unknown"},{"location":"api/overview/#match","title":"match","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/match/v5/matches/by-puuid/{puuid}/ids</code> Get Match Ids By Puuid Path: puuidQuery: start, count, region, startTime, endTime, queue, type Unknown \ud83d\udfe2 GET <code>/lol/match/v5/matches/{matchId}</code> Get Match Path: matchIdQuery: region, force Unknown \ud83d\udfe2 GET <code>/lol/match/v5/matches/{matchId}/timeline</code> Get Match Timeline Path: matchIdQuery: region Unknown"},{"location":"api/overview/#champion","title":"champion","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/platform/v3/champion-rotations</code> Get Champion Rotations Query: region Unknown"},{"location":"api/overview/#spectator","title":"spectator","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/spectator/v5/active-games/by-summoner/{puuid}</code> Get Active Game Path: puuidQuery: region Unknown \ud83d\udfe2 GET <code>/lol/spectator/v5/featured-games</code> Get Featured Games Query: region Unknown"},{"location":"api/overview/#platform","title":"platform","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/status/v4/platform-data</code> Get Platform Status Query: region Unknown"},{"location":"api/overview/#summoner","title":"summoner","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/lol/summoner/v4/summoners/by-name/{summonerName}</code> Get Summoner By Name Path: summonerNameQuery: region Unknown \ud83d\udfe2 GET <code>/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}</code> Get Summoner By Puuid Path: encryptedPUUIDQuery: region Unknown \ud83d\udfe2 GET <code>/lol/summoner/v4/summoners/{encryptedSummonerId}</code> Get Summoner By Id Path: encryptedSummonerIdQuery: region Unknown"},{"location":"api/overview/#account","title":"account","text":"Method Path Summary Parameters Response \ud83d\udfe2 GET <code>/riot/account/v1/accounts/by-puuid/{puuid}</code> Get Account By Puuid Path: puuidQuery: region Unknown \ud83d\udfe2 GET <code>/riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}</code> Get Account By Riot Id Path: gameName, tagLineQuery: region Unknown \ud83d\udfe2 GET <code>/riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}</code> Get Active Shard Path: puuid, gameQuery: region Unknown"},{"location":"api/overview/#data-schemas","title":"Data Schemas","text":""},{"location":"api/overview/#other-models","title":"Other Models","text":""},{"location":"api/overview/#division","title":"Division","text":"<p>Division within a tier.</p> <p>Used for Iron through Diamond (and Emerald) tiers. Master, Grandmaster, and Challenger don't use divisions.</p>"},{"location":"api/overview/#gameregion","title":"GameRegion","text":"<p>Game regions for platform-specific endpoints.</p>"},{"location":"api/overview/#httpvalidationerror","title":"HTTPValidationError","text":"Property Type Description Required <code>detail</code> array \u274c"},{"location":"api/overview/#platformregion","title":"PlatformRegion","text":"<p>Platform regions for regional routing (ACCOUNT, MATCH APIs).</p>"},{"location":"api/overview/#queuetype","title":"QueueType","text":"<p>Queue types for League of Legends.</p> <p>Includes ranked, normal, and special game modes.</p>"},{"location":"api/overview/#tier","title":"Tier","text":"<p>League tier/rank levels.</p> <p>Used for: - Ranked league entries and progression (IRON \u2192 CHALLENGER) - Challenge progression (all tiers) - Challenge leaderboards (MASTER, GRANDMASTER, CHALLENGER only)</p>"},{"location":"api/overview/#validationerror","title":"ValidationError","text":"Property Type Description Required <code>loc</code> array \u2705 <code>msg</code> string \u2705 <code>type</code> string \u2705"},{"location":"api/overview/#error-handling","title":"Error Handling","text":"<p>The API uses standard HTTP status codes and returns error information in the following format:</p> <pre><code>{\n  \"detail\": \"Error description\",\n  \"status_code\": 400\n}\n</code></pre>"},{"location":"api/overview/#common-error-codes","title":"Common Error Codes","text":"Status Code Description Cause 400 Bad Request Invalid parameters or malformed request 404 Not Found Resource does not exist 429 Too Many Requests Rate limit exceeded (handled automatically) 500 Internal Server Error Server error or external API failure 503 Service Unavailable External API (Riot) is down"},{"location":"api/overview/#rate-limiting","title":"Rate Limiting","text":"<p>The gateway includes automatic rate limiting with the following features:</p> <ul> <li>Automatic Retry: 429 responses are automatically retried with exponential backoff</li> <li>Rate Limit Headers: All responses include rate limit information</li> <li>Graceful Degradation: The service continues to operate during rate limit events</li> </ul>"},{"location":"api/overview/#usage-examples","title":"Usage Examples","text":""},{"location":"api/overview/#get-summoner-by-name","title":"Get Summoner by Name","text":"<p>Retrieve summoner information using their summoner name.</p> <p>Endpoint: <code>GET /summoner/by-name/{summonerName}</code></p> <pre><code>curl \"http://localhost:8080/summoner/by-name/Faker?region=kr\"\n</code></pre>"},{"location":"api/overview/#get-match-history","title":"Get Match History","text":"<p>Retrieve recent match IDs for a player using their PUUID.</p> <p>Endpoint: <code>GET /match/ids/by-puuid/{puuid}</code></p> <pre><code>curl \"http://localhost:8080/match/ids/by-puuid/puuid-here?region=kr&amp;count=5\"\n</code></pre>"},{"location":"api/overview/#get-challenger-league","title":"Get Challenger League","text":"<p>Retrieve the challenger league for a specific queue.</p> <p>Endpoint: <code>GET /league/challenger/{queue}</code></p> <pre><code>curl \"http://localhost:8080/league/challenger/RANKED_SOLO_5x5?region=kr\"\n</code></pre>"},{"location":"api/overview/#python-client-example","title":"Python Client Example","text":"<pre><code>import httpx\nimport asyncio\n\nasync def get_summoner_data():\n    \"\"\"Get summoner information example.\"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            \"http://localhost:8080/summoner/by-name/Faker\",\n            params={\"region\": \"kr\"}\n        )\n        if response.status_code == 200:\n            return response.json()\n        return None\n\n# Usage\nsummoner = asyncio.run(get_summoner_data())\nif summoner:\n    print(f\"Summoner: {summoner[\\'name\\']} (Level {summoner[\\'summonerLevel\\']})\")\n</code></pre> <p>Documentation generated on 2024-10-28 18:34:54 UTC</p> <p>For the most up-to-date interactive documentation, visit Swagger UI when the server is running.</p>"},{"location":"api/riot-client/","title":"Riot Client","text":"<p>This section documents the Riot API client implementation that handles HTTP requests, rate limiting, and retry logic.</p>"},{"location":"api/riot-client/#riotclient","title":"RiotClient","text":""},{"location":"api/riot-client/#app.riot.client.RiotClient","title":"<code>app.riot.client.RiotClient()</code>","text":"<p>HTTP client for Riot API with rate limiting and retry logic.</p> <p>Automatically applies rate limiting before each request and retries on 429 responses according to Retry-After header.</p> <p>Initialize HTTP client with authentication headers.</p> Source code in <code>app/riot/client.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize HTTP client with authentication headers.\"\"\"\n    self.client = httpx.AsyncClient(\n        timeout=settings.riot_request_timeout,\n        headers={\"X-Riot-Token\": settings.riot_api_key},\n    )\n    logger.info(\"Riot API client initialized\")\n</code></pre>"},{"location":"api/riot-client/#app.riot.client.RiotClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close HTTP client connection.</p> Source code in <code>app/riot/client.py</code> <pre><code>async def close(self):\n    \"\"\"Close HTTP client connection.\"\"\"\n    await self.client.aclose()\n    logger.info(\"Riot API client closed\")\n</code></pre>"},{"location":"api/riot-client/#app.riot.client.RiotClient.get","title":"<code>get(path: str, region: str, is_platform_endpoint: bool = False, params: dict | None = None) -&gt; dict</code>  <code>async</code>","text":"<p>Make GET request to Riot API with rate limiting and retry.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>API path (e.g., '/lol/summoner/v4/summoners/by-name/Faker')</p> required <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1', 'kr')</p> required <code>is_platform_endpoint</code> <code>bool</code> <p>True for Match API, False for Summoner/League/Mastery</p> <code>False</code> <code>params</code> <code>dict | None</code> <p>Optional query parameters</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>JSON response as dictionary</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>On non-retryable HTTP errors</p> <code>ValueError</code> <p>On invalid region</p> Example <p>await riot_client.get( ...     \"/lol/summoner/v4/summoners/by-name/Faker\", ...     region=\"kr\", ...     is_platform_endpoint=False ... )</p> Source code in <code>app/riot/client.py</code> <pre><code>async def get(\n    self,\n    path: str,\n    region: str,\n    is_platform_endpoint: bool = False,\n    params: dict | None = None,\n) -&gt; dict:\n    \"\"\"\n    Make GET request to Riot API with rate limiting and retry.\n\n    Args:\n        path: API path (e.g., '/lol/summoner/v4/summoners/by-name/Faker')\n        region: Region code (e.g., 'euw1', 'kr')\n        is_platform_endpoint: True for Match API, False for Summoner/League/Mastery\n        params: Optional query parameters\n\n    Returns:\n        JSON response as dictionary\n\n    Raises:\n        httpx.HTTPStatusError: On non-retryable HTTP errors\n        ValueError: On invalid region\n\n    Example:\n        &gt;&gt;&gt; await riot_client.get(\n        ...     \"/lol/summoner/v4/summoners/by-name/Faker\",\n        ...     region=\"kr\",\n        ...     is_platform_endpoint=False\n        ... )\n    \"\"\"\n    # Acquire rate limit tokens (blocks until available)\n    await rate_limiter.acquire()\n\n    # Build full URL\n    base_url = get_base_url(region, is_platform_endpoint)\n    url = f\"{base_url}{path}\"\n\n    logger.debug(\"Requesting Riot API: {} [region={}]\", path, region)\n\n    # Make request\n    response = await self.client.get(url, params=params)\n\n    # Handle 429 (rate limited) - should be rare due to our rate limiter\n    if response.status_code == 429:\n        retry_after = int(response.headers.get(\"Retry-After\", 1))\n        logger.warning(\n            \"Rate limited by Riot API (429), retrying after {}s\",\n            retry_after,\n        )\n        await asyncio.sleep(retry_after)\n        # Retry the request (recursive call)\n        return await self.get(path, region, is_platform_endpoint, params)\n\n    # Raise on other HTTP errors\n    response.raise_for_status()\n\n    # Return JSON response\n    return response.json()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/riot-client/#riotratelimiter","title":"RiotRateLimiter","text":""},{"location":"api/riot-client/#app.riot.rate_limiter.RiotRateLimiter","title":"<code>app.riot.rate_limiter.RiotRateLimiter()</code>","text":"<p>Rate limiter for Riot API compliance.</p> <p>Enforces application-level rate limits using token bucket algorithm. Requests are blocked until tokens are available.</p> <p>Initialize rate limiters with configured limits.</p> Source code in <code>app/riot/rate_limiter.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize rate limiters with configured limits.\"\"\"\n    self.limiter_1s = AsyncLimiter(\n        max_rate=settings.riot_rate_limit_per_second,\n        time_period=1,\n    )\n    self.limiter_2min = AsyncLimiter(\n        max_rate=settings.riot_rate_limit_per_2min,\n        time_period=120,\n    )\n    logger.info(\n        \"Rate limiter initialized: {}/s, {}/2min\",\n        settings.riot_rate_limit_per_second,\n        settings.riot_rate_limit_per_2min,\n    )\n</code></pre>"},{"location":"api/riot-client/#app.riot.rate_limiter.RiotRateLimiter.acquire","title":"<code>acquire()</code>  <code>async</code>","text":"<p>Acquire rate limit tokens before making a request.</p> <p>Blocks until both rate limiters have available tokens. Uses nested context managers to ensure both limits are respected.</p> Source code in <code>app/riot/rate_limiter.py</code> <pre><code>async def acquire(self):\n    \"\"\"\n    Acquire rate limit tokens before making a request.\n\n    Blocks until both rate limiters have available tokens.\n    Uses nested context managers to ensure both limits are respected.\n    \"\"\"\n    async with self.limiter_1s:\n        async with self.limiter_2min:\n            pass\n</code></pre>"},{"location":"api/riot-client/#regions","title":"Regions","text":""},{"location":"api/riot-client/#app.riot.regions","title":"<code>app.riot.regions</code>","text":"<p>Region routing configuration for Riot API.</p> <p>Maps regions to their appropriate API base URLs. Different endpoints use different routing: - Regional endpoints (Summoner, League, Mastery): region-specific - Platform endpoints (Match): platform-specific (europe, americas, asia, sea)</p>"},{"location":"api/riot-client/#app.riot.regions.get_regional_url","title":"<code>get_regional_url(region: str) -&gt; str</code>","text":"<p>Get regional base URL for endpoints like Summoner, League, Mastery.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1', 'kr', 'na1')</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base URL for regional endpoints</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_regional_url(\"euw1\")\n'https://euw1.api.riotgames.com'\n&gt;&gt;&gt; get_regional_url(\"kr\")\n'https://kr.api.riotgames.com'\n</code></pre> Source code in <code>app/riot/regions.py</code> <pre><code>def get_regional_url(region: str) -&gt; str:\n    \"\"\"\n    Get regional base URL for endpoints like Summoner, League, Mastery.\n\n    Args:\n        region: Region code (e.g., 'euw1', 'kr', 'na1')\n\n    Returns:\n        Base URL for regional endpoints\n\n    Examples:\n        &gt;&gt;&gt; get_regional_url(\"euw1\")\n        'https://euw1.api.riotgames.com'\n        &gt;&gt;&gt; get_regional_url(\"kr\")\n        'https://kr.api.riotgames.com'\n    \"\"\"\n    if region not in SUPPORTED_REGIONS:\n        raise ValueError(f\"Unsupported region: {region}. Supported: {SUPPORTED_REGIONS}\")\n\n    return f\"https://{region}.api.riotgames.com\"\n</code></pre>"},{"location":"api/riot-client/#app.riot.regions.get_platform_url","title":"<code>get_platform_url(region: str) -&gt; str</code>","text":"<p>Get platform base URL for Match API and Account API endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1', 'kr', 'na1') OR platform region (e.g., 'americas', 'europe', 'asia', 'sea')</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base URL for platform endpoints</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_platform_url(\"euw1\")\n'https://europe.api.riotgames.com'\n&gt;&gt;&gt; get_platform_url(\"kr\")\n'https://asia.api.riotgames.com'\n&gt;&gt;&gt; get_platform_url(\"americas\")\n'https://americas.api.riotgames.com'\n</code></pre> Source code in <code>app/riot/regions.py</code> <pre><code>def get_platform_url(region: str) -&gt; str:\n    \"\"\"\n    Get platform base URL for Match API and Account API endpoints.\n\n    Args:\n        region: Region code (e.g., 'euw1', 'kr', 'na1') OR platform region (e.g., 'americas', 'europe', 'asia', 'sea')\n\n    Returns:\n        Base URL for platform endpoints\n\n    Examples:\n        &gt;&gt;&gt; get_platform_url(\"euw1\")\n        'https://europe.api.riotgames.com'\n        &gt;&gt;&gt; get_platform_url(\"kr\")\n        'https://asia.api.riotgames.com'\n        &gt;&gt;&gt; get_platform_url(\"americas\")\n        'https://americas.api.riotgames.com'\n    \"\"\"\n    # If it's already a platform region, use it directly\n    platform_regions_list = [\"americas\", \"europe\", \"asia\", \"sea\"]\n    if region in platform_regions_list:\n        return f\"https://{region}.api.riotgames.com\"\n\n    # Otherwise, it's a game region code, map it to platform\n    if region not in SUPPORTED_REGIONS:\n        raise ValueError(\n            f\"Unsupported region: {region}. Supported: {SUPPORTED_REGIONS + platform_regions_list}\"\n        )\n\n    platform = PLATFORM_REGIONS[region]\n    return f\"https://{platform}.api.riotgames.com\"\n</code></pre>"},{"location":"api/riot-client/#app.riot.regions.get_base_url","title":"<code>get_base_url(region: str, is_platform_endpoint: bool = False) -&gt; str</code>","text":"<p>Get the appropriate base URL based on endpoint type.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>Region code (e.g., 'euw1', 'kr', 'na1')</p> required <code>is_platform_endpoint</code> <code>bool</code> <p>True for Match API, False for Summoner/League/Mastery</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Appropriate base URL for the endpoint type</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_base_url(\"euw1\", is_platform_endpoint=False)\n'https://euw1.api.riotgames.com'\n&gt;&gt;&gt; get_base_url(\"euw1\", is_platform_endpoint=True)\n'https://europe.api.riotgames.com'\n</code></pre> Source code in <code>app/riot/regions.py</code> <pre><code>def get_base_url(region: str, is_platform_endpoint: bool = False) -&gt; str:\n    \"\"\"\n    Get the appropriate base URL based on endpoint type.\n\n    Args:\n        region: Region code (e.g., 'euw1', 'kr', 'na1')\n        is_platform_endpoint: True for Match API, False for Summoner/League/Mastery\n\n    Returns:\n        Appropriate base URL for the endpoint type\n\n    Examples:\n        &gt;&gt;&gt; get_base_url(\"euw1\", is_platform_endpoint=False)\n        'https://euw1.api.riotgames.com'\n        &gt;&gt;&gt; get_base_url(\"euw1\", is_platform_endpoint=True)\n        'https://europe.api.riotgames.com'\n    \"\"\"\n    if is_platform_endpoint:\n        return get_platform_url(region)\n    else:\n        return get_regional_url(region)\n</code></pre>"},{"location":"api/routers/","title":"API Routers","text":"<p>This section contains all the FastAPI routers that define the REST API endpoints for the LOLStonks API Gateway.</p>"},{"location":"api/routers/#core-routers","title":"Core Routers","text":""},{"location":"api/routers/#health-check","title":"Health Check","text":""},{"location":"api/routers/#app.routers.health","title":"<code>app.routers.health</code>","text":"<p>Health check endpoint for gateway monitoring.</p>"},{"location":"api/routers/#app.routers.health.health_check","title":"<code>health_check()</code>  <code>async</code>","text":"<p>Health check endpoint.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Simple status response</p> Source code in <code>app/routers/health.py</code> <pre><code>@router.get(\"/health\")\nasync def health_check():\n    \"\"\"\n    Health check endpoint.\n\n    Returns:\n        dict: Simple status response\n    \"\"\"\n    logger.debug(\"Health check requested\")\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"api/routers/#summoner-router","title":"Summoner Router","text":""},{"location":"api/routers/#app.routers.summoner","title":"<code>app.routers.summoner</code>","text":"<p>Summoner API endpoints - Priority 1.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#summoner-v4</p>"},{"location":"api/routers/#app.routers.summoner.get_summoner_by_name","title":"<code>get_summoner_by_name(params: Annotated[SummonerByNameParams, Depends()], query: Annotated[SummonerByNameQuery, Depends()])</code>  <code>async</code>","text":"<p>Get summoner by summoner name.</p> <p>This is the primary entry point for user lookups.</p> <p>API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerName</p> <p>Parameters:</p> Name Type Description Default <code>summonerName</code> <p>Summoner name (URL encoded)</p> required <code>region</code> <p>Region code (default: euw1)</p> required <p>Returns:</p> Type Description <p>Summoner object from Riot API</p> Source code in <code>app/routers/summoner.py</code> <pre><code>@router.get(\"/summoners/by-name/{summonerName}\")\nasync def get_summoner_by_name(\n    params: Annotated[SummonerByNameParams, Depends()],\n    query: Annotated[SummonerByNameQuery, Depends()],\n):\n    \"\"\"\n    Get summoner by summoner name.\n\n    This is the primary entry point for user lookups.\n\n    API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerName\n\n    Args:\n        summonerName: Summoner name (URL encoded)\n        region: Region code (default: euw1)\n\n    Returns:\n        Summoner object from Riot API\n    \"\"\"\n    logger.info(\"Fetching summoner by name\", summoner=params.summonerName, region=query.region)\n\n    # Check cache first\n    cache_key = f\"summoner:name:{query.region}:{params.summonerName}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for summoner\", summoner=params.summonerName)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/summoner/v4/summoners/by-name/{params.summonerName}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_summoner)\n\n    logger.success(\n        \"Summoner fetched successfully\",\n        summoner=params.summonerName,\n        puuid=data.get(\"puuid\", \"unknown\"),\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.summoner.get_summoner_by_puuid","title":"<code>get_summoner_by_puuid(params: Annotated[SummonerByPuuidParams, Depends()], query: Annotated[SummonerByPuuidQuery, Depends()])</code>  <code>async</code>","text":"<p>Get summoner by PUUID.</p> <p>API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getByPUUID</p> <p>Parameters:</p> Name Type Description Default <code>encryptedPUUID</code> <p>Encrypted PUUID</p> required <code>region</code> <p>Region code</p> required <p>Returns:</p> Type Description <p>Summoner object from Riot API</p> Source code in <code>app/routers/summoner.py</code> <pre><code>@router.get(\"/summoners/by-puuid/{encryptedPUUID}\")\nasync def get_summoner_by_puuid(\n    params: Annotated[SummonerByPuuidParams, Depends()],\n    query: Annotated[SummonerByPuuidQuery, Depends()],\n):\n    \"\"\"\n    Get summoner by PUUID.\n\n    API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getByPUUID\n\n    Args:\n        encryptedPUUID: Encrypted PUUID\n        region: Region code\n\n    Returns:\n        Summoner object from Riot API\n    \"\"\"\n    logger.info(\"Fetching summoner by PUUID\", puuid=params.encryptedPUUID, region=query.region)\n\n    # Check cache first\n    cache_key = f\"summoner:puuid:{query.region}:{params.encryptedPUUID}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for summoner by PUUID\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/summoner/v4/summoners/by-puuid/{params.encryptedPUUID}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_summoner)\n\n    logger.success(\"Summoner fetched by PUUID\", name=data.get(\"name\", \"unknown\"))\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.summoner.get_summoner_by_id","title":"<code>get_summoner_by_id(params: Annotated[SummonerByIdParams, Depends()], query: Annotated[SummonerByIdQuery, Depends()])</code>  <code>async</code>","text":"<p>Get summoner by summoner ID.</p> <p>API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerId</p> <p>Parameters:</p> Name Type Description Default <code>encryptedSummonerId</code> <p>Encrypted summoner ID</p> required <code>region</code> <p>Region code</p> required <p>Returns:</p> Type Description <p>Summoner object from Riot API</p> Source code in <code>app/routers/summoner.py</code> <pre><code>@router.get(\"/summoners/{encryptedSummonerId}\")\nasync def get_summoner_by_id(\n    params: Annotated[SummonerByIdParams, Depends()],\n    query: Annotated[SummonerByIdQuery, Depends()],\n):\n    \"\"\"\n    Get summoner by summoner ID.\n\n    API Reference: https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerId\n\n    Args:\n        encryptedSummonerId: Encrypted summoner ID\n        region: Region code\n\n    Returns:\n        Summoner object from Riot API\n    \"\"\"\n    logger.info(\n        \"Fetching summoner by ID\", summoner_id=params.encryptedSummonerId, region=query.region\n    )\n\n    # Check cache first\n    cache_key = f\"summoner:id:{query.region}:{params.encryptedSummonerId}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for summoner by ID\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/summoner/v4/summoners/{params.encryptedSummonerId}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_summoner)\n\n    logger.success(\"Summoner fetched by ID\", name=data.get(\"name\", \"unknown\"))\n    return data\n</code></pre>"},{"location":"api/routers/#match-router","title":"Match Router","text":""},{"location":"api/routers/#app.routers.match","title":"<code>app.routers.match</code>","text":"<p>Match API endpoints - Priority 2 &amp; 3.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#match-v5</p>"},{"location":"api/routers/#app.routers.match.get_match_ids_by_puuid","title":"<code>get_match_ids_by_puuid(params: Annotated[MatchIdsByPuuidParams, Depends()], query: Annotated[MatchIdsByPuuidQuery, Depends()])</code>  <code>async</code>","text":"<p>Get match IDs for a summoner by PUUID.</p> <p>This endpoint is used for match discovery with optional filtering.</p> <p>API Reference: https://developer.riotgames.com/apis#match-v5/GET_getMatchIdsByPUUID</p> <p>Parameters:</p> Name Type Description Default <code>puuid</code> <p>Player UUID</p> required <code>region</code> <p>Region code</p> required <code>start</code> <p>Start index (pagination)</p> required <code>count</code> <p>Number of matches to return (1-100)</p> required <code>startTime</code> <p>Optional epoch timestamp - only matches after this time</p> required <code>endTime</code> <p>Optional epoch timestamp - only matches before this time</p> required <code>queue</code> <p>Optional queue ID filter</p> required <code>type</code> <p>Optional match type filter (ranked, normal, tourney, tutorial)</p> required <p>Returns:</p> Type Description <p>List of match IDs</p> Source code in <code>app/routers/match.py</code> <pre><code>@router.get(\"/matches/by-puuid/{puuid}/ids\")\nasync def get_match_ids_by_puuid(\n    params: Annotated[MatchIdsByPuuidParams, Depends()],\n    query: Annotated[MatchIdsByPuuidQuery, Depends()],\n):\n    \"\"\"\n    Get match IDs for a summoner by PUUID.\n\n    This endpoint is used for match discovery with optional filtering.\n\n    API Reference: https://developer.riotgames.com/apis#match-v5/GET_getMatchIdsByPUUID\n\n    Args:\n        puuid: Player UUID\n        region: Region code\n        start: Start index (pagination)\n        count: Number of matches to return (1-100)\n        startTime: Optional epoch timestamp - only matches after this time\n        endTime: Optional epoch timestamp - only matches before this time\n        queue: Optional queue ID filter\n        type: Optional match type filter (ranked, normal, tourney, tutorial)\n\n    Returns:\n        List of match IDs\n    \"\"\"\n    logger.info(\n        \"Fetching match IDs\",\n        puuid=params.puuid[:8],\n        region=query.region,\n        start=query.start,\n        count=query.count,\n        filters={\n            \"startTime\": query.startTime,\n            \"endTime\": query.endTime,\n            \"queue\": query.queue,\n            \"type\": query.type,\n        },\n    )\n\n    # Build query parameters\n    query_params = [f\"start={query.start}\", f\"count={query.count}\"]\n    if query.startTime is not None:\n        query_params.append(f\"startTime={query.startTime}\")\n    if query.endTime is not None:\n        query_params.append(f\"endTime={query.endTime}\")\n    if query.queue is not None:\n        query_params.append(f\"queue={query.queue}\")\n    if query.type is not None:\n        query_params.append(f\"type={query.type}\")\n\n    # Build path with query parameters\n    path = f\"/lol/match/v5/matches/by-puuid/{params.puuid}/ids?{'&amp;'.join(query_params)}\"\n    match_ids = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    logger.success(\"Match IDs fetched\", count=len(match_ids), region=query.region)\n    return match_ids\n</code></pre>"},{"location":"api/routers/#app.routers.match.get_match","title":"<code>get_match(params: Annotated[MatchParams, Depends()], query: Annotated[MatchQuery, Depends()])</code>  <code>async</code>","text":"<p>Get match details by match ID.</p> <p>This is the core match data endpoint with dual-layer caching: - Layer 1: Response cache (24h TTL) - Layer 2: Permanent tracking to prevent duplicate processing</p> <p>API Reference: https://developer.riotgames.com/apis#match-v5/GET_getMatch</p> <p>Parameters:</p> Name Type Description Default <code>matchId</code> <p>Match ID (e.g., EUW1_123456789)</p> required <code>region</code> <p>Region code</p> required <code>force</code> <p>If True, bypass cache and fetch fresh data</p> required <p>Returns:</p> Type Description <p>Match object from Riot API</p> Source code in <code>app/routers/match.py</code> <pre><code>@router.get(\"/matches/{matchId}\")\nasync def get_match(\n    params: Annotated[MatchParams, Depends()],\n    query: Annotated[MatchQuery, Depends()],\n):\n    \"\"\"\n    Get match details by match ID.\n\n    This is the core match data endpoint with dual-layer caching:\n    - Layer 1: Response cache (24h TTL)\n    - Layer 2: Permanent tracking to prevent duplicate processing\n\n    API Reference: https://developer.riotgames.com/apis#match-v5/GET_getMatch\n\n    Args:\n        matchId: Match ID (e.g., EUW1_123456789)\n        region: Region code\n        force: If True, bypass cache and fetch fresh data\n\n    Returns:\n        Match object from Riot API\n    \"\"\"\n    logger.info(\n        \"Match request received\", match_id=params.matchId, region=query.region, force=query.force\n    )\n\n    cache_key = f\"match:{query.region}:{params.matchId}\"\n\n    # Check force refresh\n    if not query.force:\n        # Check if already processed (permanent tracking)\n        is_processed = await tracker.is_processed(query.region, params.matchId)\n\n        if is_processed:\n            logger.debug(\"Match already processed, checking cache\", match_id=params.matchId)\n\n            # Try to get from cache\n            cached_data = await cache.get(cache_key)\n            if cached_data:\n                logger.debug(\"Cache hit for processed match\", match_id=params.matchId)\n                return cached_data\n            else:\n                logger.debug(\n                    \"Cache miss for processed match (TTL expired)\", match_id=params.matchId\n                )\n        else:\n            logger.debug(\"Match not yet processed\", match_id=params.matchId)\n    else:\n        logger.info(\"Force refresh requested, bypassing cache\", match_id=params.matchId)\n\n    # Fetch from Riot API (rate-limited)\n    logger.info(\"Fetching match from Riot API\", match_id=params.matchId, region=query.region)\n    path = f\"/lol/match/v5/matches/{params.matchId}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Store in cache with TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_match)\n    logger.debug(\"Match stored in cache\", match_id=params.matchId, ttl=settings.cache_ttl_match)\n\n    # Mark as processed (permanent, no TTL)\n    await tracker.mark_processed(query.region, params.matchId)\n    logger.debug(\"Match marked as processed\", match_id=params.matchId, region=query.region)\n\n    logger.success(\"Match fetched and cached successfully\", match_id=params.matchId)\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.match.get_match_timeline","title":"<code>get_match_timeline(params: Annotated[MatchTimelineParams, Depends()], query: Annotated[MatchTimelineQuery, Depends()])</code>  <code>async</code>","text":"<p>Get match timeline (detailed events).</p> <p>Priority 4 endpoint - detailed timeline data.</p> <p>API Reference: https://developer.riotgames.com/apis#match-v5/GET_getTimeline</p> <p>Parameters:</p> Name Type Description Default <code>matchId</code> <p>Match ID</p> required <code>region</code> <p>Region code</p> required <p>Returns:</p> Type Description <p>Match timeline object from Riot API</p> Source code in <code>app/routers/match.py</code> <pre><code>@router.get(\"/matches/{matchId}/timeline\")\nasync def get_match_timeline(\n    params: Annotated[MatchTimelineParams, Depends()],\n    query: Annotated[MatchTimelineQuery, Depends()],\n):\n    \"\"\"\n    Get match timeline (detailed events).\n\n    Priority 4 endpoint - detailed timeline data.\n\n    API Reference: https://developer.riotgames.com/apis#match-v5/GET_getTimeline\n\n    Args:\n        matchId: Match ID\n        region: Region code\n\n    Returns:\n        Match timeline object from Riot API\n    \"\"\"\n    logger.info(\"Fetching match timeline\", match_id=params.matchId, region=query.region)\n\n    # Check cache first\n    cache_key = f\"match:timeline:{query.region}:{params.matchId}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for match timeline\", match_id=params.matchId)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/match/v5/matches/{params.matchId}/timeline\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_timeline)\n\n    logger.success(\"Match timeline fetched\", match_id=params.matchId)\n    return data\n</code></pre>"},{"location":"api/routers/#league-router","title":"League Router","text":""},{"location":"api/routers/#app.routers.league","title":"<code>app.routers.league</code>","text":"<p>League API endpoints - Priority 5.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#league-v4</p>"},{"location":"api/routers/#app.routers.league.get_challenger_league","title":"<code>get_challenger_league(params: Annotated[LeagueByQueueParams, Depends()], query: Annotated[LeagueByQueueQuery, Depends()])</code>  <code>async</code>","text":"<p>Get challenger league entries for a queue.</p> <p>This endpoint returns the top players in a region, including their summonerIds. Use this to get a list of high-level players to track.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getChallengerLeague</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <p>Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, RANKED_FLEX_TT)</p> required <code>region</code> <p>Region code (default: euw1)</p> required <p>Returns:</p> Type Description <p>League object with entries array containing summoner information</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/challengerleagues/by-queue/{queue}\")\nasync def get_challenger_league(\n    params: Annotated[LeagueByQueueParams, Depends()],\n    query: Annotated[LeagueByQueueQuery, Depends()],\n):\n    \"\"\"\n    Get challenger league entries for a queue.\n\n    This endpoint returns the top players in a region, including their summonerIds.\n    Use this to get a list of high-level players to track.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getChallengerLeague\n\n    Args:\n        queue: Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, RANKED_FLEX_TT)\n        region: Region code (default: euw1)\n\n    Returns:\n        League object with entries array containing summoner information\n    \"\"\"\n    logger.info(\"Fetching challenger league\", queue=params.queue, region=query.region)\n\n    # Check cache first\n    cache_key = f\"league:challenger:{query.region}:{params.queue}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenger league\", queue=params.queue)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/challengerleagues/by-queue/{params.queue}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache (1 hour - challenger changes frequently)\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"Challenger league fetched\", queue=params.queue, entries=len(data.get(\"entries\", []))\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.league.get_grandmaster_league","title":"<code>get_grandmaster_league(params: Annotated[LeagueByQueueParams, Depends()], query: Annotated[LeagueByQueueQuery, Depends()])</code>  <code>async</code>","text":"<p>Get grandmaster league entries for a queue.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getGrandmasterLeague</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <p>Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, RANKED_FLEX_TT)</p> required <code>region</code> <p>Region code</p> required <p>Returns:</p> Type Description <p>League object with entries</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/grandmasterleagues/by-queue/{queue}\")\nasync def get_grandmaster_league(\n    params: Annotated[LeagueByQueueParams, Depends()],\n    query: Annotated[LeagueByQueueQuery, Depends()],\n):\n    \"\"\"\n    Get grandmaster league entries for a queue.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getGrandmasterLeague\n\n    Args:\n        queue: Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, RANKED_FLEX_TT)\n        region: Region code\n\n    Returns:\n        League object with entries\n    \"\"\"\n    logger.info(\"Fetching grandmaster league\", queue=params.queue, region=query.region)\n\n    # Check cache first\n    cache_key = f\"league:grandmaster:{query.region}:{params.queue}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for grandmaster league\", queue=params.queue)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/grandmasterleagues/by-queue/{params.queue}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"Grandmaster league fetched\", queue=params.queue, entries=len(data.get(\"entries\", []))\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.league.get_master_league","title":"<code>get_master_league(params: Annotated[LeagueByQueueParams, Depends()], query: Annotated[LeagueByQueueQuery, Depends()])</code>  <code>async</code>","text":"<p>Get master league entries for a queue.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getMasterLeague</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <p>Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, RANKED_FLEX_TT)</p> required <code>region</code> <p>Region code</p> required <p>Returns:</p> Type Description <p>League object with entries</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/masterleagues/by-queue/{queue}\")\nasync def get_master_league(\n    params: Annotated[LeagueByQueueParams, Depends()],\n    query: Annotated[LeagueByQueueQuery, Depends()],\n):\n    \"\"\"\n    Get master league entries for a queue.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getMasterLeague\n\n    Args:\n        queue: Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, RANKED_FLEX_TT)\n        region: Region code\n\n    Returns:\n        League object with entries\n    \"\"\"\n    logger.info(\"Fetching master league\", queue=params.queue, region=query.region)\n\n    # Check cache first\n    cache_key = f\"league:master:{query.region}:{params.queue}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for master league\", queue=params.queue)\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/masterleagues/by-queue/{params.queue}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"Master league fetched\", queue=params.queue, entries=len(data.get(\"entries\", []))\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.league.get_league_entries_by_summoner","title":"<code>get_league_entries_by_summoner(params: Annotated[LeagueEntriesBySummonerParams, Depends()], query: Annotated[LeagueEntriesBySummonerQuery, Depends()])</code>  <code>async</code>","text":"<p>Get league entries for a summoner (all queues).</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getLeagueEntriesForSummoner</p> <p>Parameters:</p> Name Type Description Default <code>encryptedSummonerId</code> <p>Encrypted summoner ID</p> required <code>region</code> <p>Region code</p> required <p>Returns:</p> Type Description <p>Array of league entries</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/entries/by-summoner/{encryptedSummonerId}\")\nasync def get_league_entries_by_summoner(\n    params: Annotated[LeagueEntriesBySummonerParams, Depends()],\n    query: Annotated[LeagueEntriesBySummonerQuery, Depends()],\n):\n    \"\"\"\n    Get league entries for a summoner (all queues).\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getLeagueEntriesForSummoner\n\n    Args:\n        encryptedSummonerId: Encrypted summoner ID\n        region: Region code\n\n    Returns:\n        Array of league entries\n    \"\"\"\n    logger.info(\n        \"Fetching league entries by summoner\",\n        summoner_id=params.encryptedSummonerId,\n        region=query.region,\n    )\n\n    # Check cache first\n    cache_key = f\"league:entries:summoner:{query.region}:{params.encryptedSummonerId}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for league entries\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/entries/by-summoner/{params.encryptedSummonerId}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\"League entries fetched\", entries=len(data))\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.league.get_league_entries","title":"<code>get_league_entries(params: Annotated[LeagueEntriesParams, Depends()], query: Annotated[LeagueEntriesQuery, Depends()])</code>  <code>async</code>","text":"<p>Get league entries by queue, tier, and division.</p> <p>This endpoint provides paginated access to league entries at specific ranks. Use this for fetching large sets of ranked players.</p> <p>API Reference: https://developer.riotgames.com/apis#league-v4/GET_getLeagueEntries</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <p>Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, RANKED_FLEX_TT)</p> required <code>tier</code> <p>Tier (IRON, BRONZE, SILVER, GOLD, PLATINUM, EMERALD, DIAMOND)</p> required <code>division</code> <p>Division (I, II, III, IV)</p> required <code>region</code> <p>Region code</p> required <code>page</code> <p>Page number (starts at 1)</p> required <p>Returns:</p> Type Description <p>Array of league entries with summoner info, LP, win/loss stats</p> Source code in <code>app/routers/league.py</code> <pre><code>@router.get(\"/entries/{queue}/{tier}/{division}\")\nasync def get_league_entries(\n    params: Annotated[LeagueEntriesParams, Depends()],\n    query: Annotated[LeagueEntriesQuery, Depends()],\n):\n    \"\"\"\n    Get league entries by queue, tier, and division.\n\n    This endpoint provides paginated access to league entries at specific ranks.\n    Use this for fetching large sets of ranked players.\n\n    API Reference: https://developer.riotgames.com/apis#league-v4/GET_getLeagueEntries\n\n    Args:\n        queue: Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, RANKED_FLEX_TT)\n        tier: Tier (IRON, BRONZE, SILVER, GOLD, PLATINUM, EMERALD, DIAMOND)\n        division: Division (I, II, III, IV)\n        region: Region code\n        page: Page number (starts at 1)\n\n    Returns:\n        Array of league entries with summoner info, LP, win/loss stats\n    \"\"\"\n    logger.info(\n        \"Fetching league entries\",\n        queue=params.queue,\n        tier=params.tier,\n        division=params.division,\n        region=query.region,\n        page=query.page,\n    )\n\n    # Check cache first\n    cache_key = (\n        f\"league:entries:{query.region}:{params.queue}:{params.tier}:{params.division}:{query.page}\"\n    )\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for league entries\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league/v4/entries/{params.queue}/{params.tier}/{params.division}\"\n    # Add page parameter if not default\n    if query.page != 1:\n        path += f\"?page={query.page}\"\n\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache (1 hour - league entries change frequently)\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"League entries fetched\",\n        queue=params.queue,\n        tier=params.tier,\n        division=params.division,\n        entries=len(data),\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#league-exp-router","title":"League EXP Router","text":""},{"location":"api/routers/#app.routers.league_exp","title":"<code>app.routers.league_exp</code>","text":"<p>League-EXP-V4 API endpoints (Experimental) - Priority 5.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#league-exp-v4</p> <p>Note: This is an experimental API providing paginated league entries.</p>"},{"location":"api/routers/#app.routers.league_exp.get_league_exp_entries","title":"<code>get_league_exp_entries(params: Annotated[LeagueExpEntriesParams, Depends()], query: Annotated[LeagueExpEntriesQuery, Depends()])</code>  <code>async</code>","text":"<p>Get league entries by queue, tier, and division (experimental endpoint).</p> <p>This experimental endpoint provides paginated access to league entries. Use this for fetching large sets of ranked players at specific ranks.</p> <p>API Reference: https://developer.riotgames.com/apis#league-exp-v4/GET_getLeagueEntries</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <p>Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, etc.)</p> required <code>tier</code> <p>Tier (IRON through DIAMOND)</p> required <code>division</code> <p>Division (I, II, III, IV)</p> required <code>region</code> <p>Region code</p> required <code>page</code> <p>Page number (starts at 1)</p> required <p>Returns:</p> Type Description <p>Array of league entries with summoner info, LP, win/loss stats</p> Source code in <code>app/routers/league_exp.py</code> <pre><code>@router.get(\"/entries/{queue}/{tier}/{division}\")\nasync def get_league_exp_entries(\n    params: Annotated[LeagueExpEntriesParams, Depends()],\n    query: Annotated[LeagueExpEntriesQuery, Depends()],\n):\n    \"\"\"\n    Get league entries by queue, tier, and division (experimental endpoint).\n\n    This experimental endpoint provides paginated access to league entries.\n    Use this for fetching large sets of ranked players at specific ranks.\n\n    API Reference: https://developer.riotgames.com/apis#league-exp-v4/GET_getLeagueEntries\n\n    Args:\n        queue: Queue type (RANKED_SOLO_5x5, RANKED_FLEX_SR, etc.)\n        tier: Tier (IRON through DIAMOND)\n        division: Division (I, II, III, IV)\n        region: Region code\n        page: Page number (starts at 1)\n\n    Returns:\n        Array of league entries with summoner info, LP, win/loss stats\n    \"\"\"\n    logger.info(\n        \"Fetching league exp entries\",\n        queue=params.queue,\n        tier=params.tier,\n        division=params.division,\n        region=query.region,\n        page=query.page,\n    )\n\n    # Check cache first\n    cache_key = f\"league-exp:entries:{query.region}:{params.queue}:{params.tier}:{params.division}:{query.page}\"\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for league exp entries\")\n        return cached_data\n\n    # Fetch from Riot API\n    path = f\"/lol/league-exp/v4/entries/{params.queue}/{params.tier}/{params.division}\"\n    # Add page parameter if not default\n    if query.page != 1:\n        path += f\"?page={query.page}\"\n\n    data = await riot_client.get(path, query.region, is_platform_endpoint=False)\n\n    # Store in cache (1 hour - league entries change frequently)\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_league)\n\n    logger.success(\n        \"League exp entries fetched\",\n        queue=params.queue,\n        tier=params.tier,\n        division=params.division,\n        entries=len(data),\n    )\n    return data\n</code></pre>"},{"location":"api/routers/#champion-router","title":"Champion Router","text":""},{"location":"api/routers/#app.routers.champion","title":"<code>app.routers.champion</code>","text":"<p>Champion-V3 API endpoints.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#champion-v3</p>"},{"location":"api/routers/#app.routers.champion.get_champion_rotations","title":"<code>get_champion_rotations(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get current champion rotation (free-to-play champions).</p> <p>API Reference: https://developer.riotgames.com/apis#champion-v3/GET_getChampionInfo</p> <p>Returns:</p> Type Description <ul> <li>freeChampionIds: List of free champion IDs</li> </ul> <ul> <li>freeChampionIdsForNewPlayers: List for new players</li> </ul> <ul> <li>maxNewPlayerLevel: Max level for new player rotation</li> </ul> Source code in <code>app/routers/champion.py</code> <pre><code>@router.get(\"/champion-rotations\")\nasync def get_champion_rotations(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get current champion rotation (free-to-play champions).\n\n    API Reference: https://developer.riotgames.com/apis#champion-v3/GET_getChampionInfo\n\n    Returns:\n        - freeChampionIds: List of free champion IDs\n        - freeChampionIdsForNewPlayers: List for new players\n        - maxNewPlayerLevel: Max level for new player rotation\n    \"\"\"\n    cache_key = f\"champion:rotation:{region}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for champion rotation\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching champion rotation from Riot API\", region=region)\n    path = \"/lol/platform/v3/champion-rotations\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_champion_rotation)\n    logger.success(\"Champion rotation fetched\", region=region)\n\n    return data\n</code></pre>"},{"location":"api/routers/#champion-mastery-router","title":"Champion Mastery Router","text":""},{"location":"api/routers/#app.routers.champion_mastery","title":"<code>app.routers.champion_mastery</code>","text":"<p>Champion-Mastery-V4 API endpoints.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#champion-mastery-v4</p>"},{"location":"api/routers/#app.routers.champion_mastery.get_all_champion_masteries","title":"<code>get_all_champion_masteries(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get all champion mastery entries for a summoner by PUUID.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getAllChampionMasteries</p> <p>Returns list of champion mastery objects sorted by champion level descending.</p> Source code in <code>app/routers/champion_mastery.py</code> <pre><code>@router.get(\"/champion-masteries/by-puuid/{puuid}\")\nasync def get_all_champion_masteries(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Get all champion mastery entries for a summoner by PUUID.\n\n    API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getAllChampionMasteries\n\n    Returns list of champion mastery objects sorted by champion level descending.\n    \"\"\"\n    cache_key = f\"mastery:all:{region}:{puuid}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for champion masteries\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching all champion masteries\", puuid=puuid[:8], region=region)\n    path = f\"/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with 1 hour TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_mastery)\n    logger.success(\"Champion masteries fetched\", puuid=puuid[:8], count=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.champion_mastery.get_champion_mastery","title":"<code>get_champion_mastery(puuid: str, championId: int, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get champion mastery entry for a specific champion.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getChampionMastery</p> <p>Returns champion mastery object with level, points, tokens, etc.</p> Source code in <code>app/routers/champion_mastery.py</code> <pre><code>@router.get(\"/champion-masteries/by-puuid/{puuid}/by-champion/{championId}\")\nasync def get_champion_mastery(\n    puuid: str,\n    championId: int,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get champion mastery entry for a specific champion.\n\n    API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getChampionMastery\n\n    Returns champion mastery object with level, points, tokens, etc.\n    \"\"\"\n    cache_key = f\"mastery:champion:{region}:{puuid}:{championId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for champion mastery\", puuid=puuid[:8], championId=championId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching champion mastery\", puuid=puuid[:8], championId=championId, region=region)\n    path = f\"/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/by-champion/{championId}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with 1 hour TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_mastery)\n    logger.success(\"Champion mastery fetched\", puuid=puuid[:8], championId=championId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.champion_mastery.get_top_champion_masteries","title":"<code>get_top_champion_masteries(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'), count: int = Query(default=3, ge=1, le=20, description='Number of top champions'))</code>  <code>async</code>","text":"<p>Get top N champion mastery entries for a summoner.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getTopChampionMasteries</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of top champions (1-20, default 3)</p> <code>Query(default=3, ge=1, le=20, description='Number of top champions')</code> <p>Returns list of top champion mastery objects.</p> Source code in <code>app/routers/champion_mastery.py</code> <pre><code>@router.get(\"/champion-masteries/by-puuid/{puuid}/top\")\nasync def get_top_champion_masteries(\n    puuid: str,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n    count: int = Query(default=3, ge=1, le=20, description=\"Number of top champions\"),\n):\n    \"\"\"\n    Get top N champion mastery entries for a summoner.\n\n    API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getTopChampionMasteries\n\n    Args:\n        count: Number of top champions (1-20, default 3)\n\n    Returns list of top champion mastery objects.\n    \"\"\"\n    cache_key = f\"mastery:top:{region}:{puuid}:{count}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for top masteries\", puuid=puuid[:8], count=count)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching top champion masteries\", puuid=puuid[:8], count=count, region=region)\n    path = f\"/lol/champion-mastery/v4/champion-masteries/by-puuid/{puuid}/top\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False, params={\"count\": count})\n\n    # Cache with 1 hour TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_mastery)\n    logger.success(\"Top champion masteries fetched\", puuid=puuid[:8], count=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.champion_mastery.get_mastery_score","title":"<code>get_mastery_score(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get total mastery score for a summoner.</p> <p>API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getChampionMasteryScore</p> <p>Returns integer representing total mastery points across all champions.</p> Source code in <code>app/routers/champion_mastery.py</code> <pre><code>@router.get(\"/scores/by-puuid/{puuid}\")\nasync def get_mastery_score(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Get total mastery score for a summoner.\n\n    API Reference: https://developer.riotgames.com/apis#champion-mastery-v4/GET_getChampionMasteryScore\n\n    Returns integer representing total mastery points across all champions.\n    \"\"\"\n    cache_key = f\"mastery:score:{region}:{puuid}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data is not None:  # Score can be 0\n        logger.debug(\"Cache hit for mastery score\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching mastery score\", puuid=puuid[:8], region=region)\n    path = f\"/lol/champion-mastery/v4/scores/by-puuid/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with 1 hour TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_mastery)\n    logger.success(\"Mastery score fetched\", puuid=puuid[:8], score=data)\n\n    return data\n</code></pre>"},{"location":"api/routers/#spectator-router","title":"Spectator Router","text":""},{"location":"api/routers/#app.routers.spectator","title":"<code>app.routers.spectator</code>","text":"<p>Spectator-V5 API endpoints.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#spectator-v5</p>"},{"location":"api/routers/#app.routers.spectator.get_active_game","title":"<code>get_active_game(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get current game information for a summoner (if in game).</p> <p>Returns 404 if player is not currently in a game.</p> <p>API Reference: https://developer.riotgames.com/apis#spectator-v5/GET_getCurrentGameInfoByPuuid</p> <p>Returns:</p> Type Description <ul> <li>gameId: Current game ID</li> </ul> <ul> <li>gameMode: Game mode</li> </ul> <ul> <li>gameStartTime: Start time (epoch ms)</li> </ul> <ul> <li>participants: List of players in the game</li> </ul> <ul> <li>bannedChampions: Banned champions</li> </ul> <ul> <li>observers: Spectator key</li> </ul> Source code in <code>app/routers/spectator.py</code> <pre><code>@router.get(\"/active-games/by-summoner/{puuid}\")\nasync def get_active_game(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Get current game information for a summoner (if in game).\n\n    Returns 404 if player is not currently in a game.\n\n    API Reference: https://developer.riotgames.com/apis#spectator-v5/GET_getCurrentGameInfoByPuuid\n\n    Returns:\n        - gameId: Current game ID\n        - gameMode: Game mode\n        - gameStartTime: Start time (epoch ms)\n        - participants: List of players in the game\n        - bannedChampions: Banned champions\n        - observers: Spectator key\n    \"\"\"\n    # Note: Active games should not be cached heavily as they change quickly\n    cache_key = f\"spectator:active:{region}:{puuid}\"\n\n    # Check cache with short TTL\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for active game\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching active game\", puuid=puuid[:8], region=region)\n    path = f\"/lol/spectator/v5/active-games/by-summoner/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_spectator_active)\n    logger.success(\"Active game fetched\", puuid=puuid[:8], gameId=data.get(\"gameId\"))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.spectator.get_featured_games","title":"<code>get_featured_games(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get list of featured games (high-profile matches shown in client).</p> <p>API Reference: https://developer.riotgames.com/apis#spectator-v5/GET_getFeaturedGames</p> <p>Returns:</p> Type Description <ul> <li>gameList: List of featured game objects</li> </ul> <ul> <li>clientRefreshInterval: Refresh interval (ms)</li> </ul> Source code in <code>app/routers/spectator.py</code> <pre><code>@router.get(\"/featured-games\")\nasync def get_featured_games(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get list of featured games (high-profile matches shown in client).\n\n    API Reference: https://developer.riotgames.com/apis#spectator-v5/GET_getFeaturedGames\n\n    Returns:\n        - gameList: List of featured game objects\n        - clientRefreshInterval: Refresh interval (ms)\n    \"\"\"\n    cache_key = f\"spectator:featured:{region}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for featured games\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching featured games\", region=region)\n    path = \"/lol/spectator/v5/featured-games\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_spectator_featured)\n    logger.success(\"Featured games fetched\", region=region, count=len(data.get(\"gameList\", [])))\n\n    return data\n</code></pre>"},{"location":"api/routers/#platform-router","title":"Platform Router","text":""},{"location":"api/routers/#app.routers.platform","title":"<code>app.routers.platform</code>","text":"<p>Platform-V4 / LOL-STATUS-V4 API endpoints.</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#lol-status-v4</p>"},{"location":"api/routers/#app.routers.platform.get_platform_status","title":"<code>get_platform_status(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get League of Legends platform status for a region.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-status-v4/GET_getPlatformData</p> <p>Returns:</p> Type Description <ul> <li>id: Region ID</li> </ul> <ul> <li>name: Region name</li> </ul> <ul> <li>locales: Supported locales</li> </ul> <ul> <li>maintenances: Scheduled maintenance events</li> </ul> <ul> <li>incidents: Current incidents/issues</li> </ul> Source code in <code>app/routers/platform.py</code> <pre><code>@router.get(\"/platform-data\")\nasync def get_platform_status(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get League of Legends platform status for a region.\n\n    API Reference: https://developer.riotgames.com/apis#lol-status-v4/GET_getPlatformData\n\n    Returns:\n        - id: Region ID\n        - name: Region name\n        - locales: Supported locales\n        - maintenances: Scheduled maintenance events\n        - incidents: Current incidents/issues\n    \"\"\"\n    cache_key = f\"platform:status:{region}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for platform status\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching platform status\", region=region)\n    path = \"/lol/status/v4/platform-data\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_platform_status)\n\n    logger.success(\n        \"Platform status fetched\",\n        region=region,\n        maintenances=len(data.get(\"maintenances\", [])),\n        incidents=len(data.get(\"incidents\", [])),\n    )\n\n    return data\n</code></pre>"},{"location":"api/routers/#account-router","title":"Account Router","text":""},{"location":"api/routers/#app.routers.account","title":"<code>app.routers.account</code>","text":"<p>Account-V1 API endpoints (Riot ID lookups).</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#account-v1</p>"},{"location":"api/routers/#app.routers.account.get_account_by_puuid","title":"<code>get_account_by_puuid(params: Annotated[AccountByPuuidParams, Depends()], query: Annotated[AccountByPuuidQuery, Depends()])</code>  <code>async</code>","text":"<p>Get account by PUUID.</p> <p>Note: This endpoint uses regional routing (americas, europe, asia, sea).</p> <p>API Reference: https://developer.riotgames.com/apis#account-v1/GET_getByPuuid</p> <p>Returns:</p> Type Description <ul> <li>puuid: Player UUID</li> </ul> <ul> <li>gameName: Riot ID game name</li> </ul> <ul> <li>tagLine: Riot ID tag line</li> </ul> Source code in <code>app/routers/account.py</code> <pre><code>@router.get(\"/accounts/by-puuid/{puuid}\")\nasync def get_account_by_puuid(\n    params: Annotated[AccountByPuuidParams, Depends()],\n    query: Annotated[AccountByPuuidQuery, Depends()],\n):\n    \"\"\"\n    Get account by PUUID.\n\n    Note: This endpoint uses regional routing (americas, europe, asia, sea).\n\n    API Reference: https://developer.riotgames.com/apis#account-v1/GET_getByPuuid\n\n    Returns:\n        - puuid: Player UUID\n        - gameName: Riot ID game name\n        - tagLine: Riot ID tag line\n    \"\"\"\n    cache_key = f\"account:puuid:{query.region}:{params.puuid}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for account by PUUID\", puuid=params.puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API (use platform endpoint for regional routing)\n    logger.info(\"Fetching account by PUUID\", puuid=params.puuid[:8], region=query.region)\n    path = f\"/riot/account/v1/accounts/by-puuid/{params.puuid}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_account)\n    logger.success(\n        \"Account fetched by PUUID\", puuid=params.puuid[:8], gameName=data.get(\"gameName\")\n    )\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.account.get_account_by_riot_id","title":"<code>get_account_by_riot_id(params: Annotated[AccountByRiotIdParams, Depends()], query: Annotated[AccountByRiotIdQuery, Depends()])</code>  <code>async</code>","text":"<p>Get account by Riot ID (gameName#tagLine).</p> <p>Note: This endpoint uses regional routing (americas, europe, asia, sea).</p> <p>API Reference: https://developer.riotgames.com/apis#account-v1/GET_getByRiotId</p> <p>Parameters:</p> Name Type Description Default <code>gameName</code> <p>Riot ID game name (before the #)</p> required <code>tagLine</code> <p>Riot ID tag line (after the #)</p> required <code>region</code> <p>Regional routing (americas, europe, asia, sea)</p> required <p>Returns:</p> Type Description <ul> <li>puuid: Player UUID</li> </ul> <ul> <li>gameName: Riot ID game name</li> </ul> <ul> <li>tagLine: Riot ID tag line</li> </ul> Source code in <code>app/routers/account.py</code> <pre><code>@router.get(\"/accounts/by-riot-id/{gameName}/{tagLine}\")\nasync def get_account_by_riot_id(\n    params: Annotated[AccountByRiotIdParams, Depends()],\n    query: Annotated[AccountByRiotIdQuery, Depends()],\n):\n    \"\"\"\n    Get account by Riot ID (gameName#tagLine).\n\n    Note: This endpoint uses regional routing (americas, europe, asia, sea).\n\n    API Reference: https://developer.riotgames.com/apis#account-v1/GET_getByRiotId\n\n    Args:\n        gameName: Riot ID game name (before the #)\n        tagLine: Riot ID tag line (after the #)\n        region: Regional routing (americas, europe, asia, sea)\n\n    Returns:\n        - puuid: Player UUID\n        - gameName: Riot ID game name\n        - tagLine: Riot ID tag line\n    \"\"\"\n    cache_key = f\"account:riotid:{query.region}:{params.gameName}:{params.tagLine}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\n            \"Cache hit for account by Riot ID\", gameName=params.gameName, tagLine=params.tagLine\n        )\n        return cached_data\n\n    # Fetch from Riot API (use platform endpoint for regional routing)\n    logger.info(\n        \"Fetching account by Riot ID\",\n        gameName=params.gameName,\n        tagLine=params.tagLine,\n        region=query.region,\n    )\n    path = f\"/riot/account/v1/accounts/by-riot-id/{params.gameName}/{params.tagLine}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_account)\n    logger.success(\n        \"Account fetched by Riot ID\", gameName=params.gameName, puuid=data.get(\"puuid\", \"\")[:8]\n    )\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.account.get_active_shard","title":"<code>get_active_shard(params: Annotated[ActiveShardParams, Depends()], query: Annotated[ActiveShardQuery, Depends()])</code>  <code>async</code>","text":"<p>Get active shard for a player (which server they're actively playing on).</p> <p>Note: This endpoint uses regional routing (americas, europe, asia, sea).</p> <p>API Reference: https://developer.riotgames.com/apis#account-v1/GET_getActiveShard</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <p>Game identifier (val for Valorant, lor for LoR)</p> required <code>puuid</code> <p>Player UUID</p> required <code>region</code> <p>Regional routing</p> required <p>Returns:</p> Type Description <ul> <li>puuid: Player UUID</li> </ul> <ul> <li>game: Game identifier</li> </ul> <ul> <li>activeShard: Active shard identifier</li> </ul> Source code in <code>app/routers/account.py</code> <pre><code>@router.get(\"/active-shards/by-game/{game}/by-puuid/{puuid}\")\nasync def get_active_shard(\n    params: Annotated[ActiveShardParams, Depends()],\n    query: Annotated[ActiveShardQuery, Depends()],\n):\n    \"\"\"\n    Get active shard for a player (which server they're actively playing on).\n\n    Note: This endpoint uses regional routing (americas, europe, asia, sea).\n\n    API Reference: https://developer.riotgames.com/apis#account-v1/GET_getActiveShard\n\n    Args:\n        game: Game identifier (val for Valorant, lor for LoR)\n        puuid: Player UUID\n        region: Regional routing\n\n    Returns:\n        - puuid: Player UUID\n        - game: Game identifier\n        - activeShard: Active shard identifier\n    \"\"\"\n    cache_key = f\"account:shard:{query.region}:{params.game}:{params.puuid}\"\n\n    # Check cache (short TTL as active shard can change)\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for active shard\", puuid=params.puuid[:8], game=params.game)\n        return cached_data\n\n    # Fetch from Riot API (use platform endpoint for regional routing)\n    logger.info(\n        \"Fetching active shard\", puuid=params.puuid[:8], game=params.game, region=query.region\n    )\n    path = f\"/riot/account/v1/active-shards/by-game/{params.game}/by-puuid/{params.puuid}\"\n    data = await riot_client.get(path, query.region, is_platform_endpoint=True)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_account_shard)\n    logger.success(\"Active shard fetched\", puuid=params.puuid[:8], shard=data.get(\"activeShard\"))\n\n    return data\n</code></pre>"},{"location":"api/routers/#clash-router","title":"Clash Router","text":""},{"location":"api/routers/#app.routers.clash","title":"<code>app.routers.clash</code>","text":"<p>Clash-V1 API endpoints (Clash tournament data).</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#clash-v1</p>"},{"location":"api/routers/#app.routers.clash.get_clash_player","title":"<code>get_clash_player(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get clash player info by PUUID.</p> <p>Returns list of clash tournament registrations for the player.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getPlayersByPUUID</p> <p>Returns:</p> Type Description <p>List of player registration objects with:</p> <ul> <li>summonerId</li> </ul> <ul> <li>teamId</li> </ul> <ul> <li>position</li> </ul> <ul> <li>role</li> </ul> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/players/by-puuid/{puuid}\")\nasync def get_clash_player(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Get clash player info by PUUID.\n\n    Returns list of clash tournament registrations for the player.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getPlayersByPUUID\n\n    Returns:\n        List of player registration objects with:\n        - summonerId\n        - teamId\n        - position\n        - role\n    \"\"\"\n    cache_key = f\"clash:player:{region}:{puuid}\"\n\n    # Check cache (short TTL as tournament data changes)\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash player\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash player data\", puuid=puuid[:8], region=region)\n    path = f\"/lol/clash/v1/players/by-puuid/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_player)\n    logger.success(\"Clash player data fetched\", puuid=puuid[:8], registrations=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.clash.get_clash_team","title":"<code>get_clash_team(teamId: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get clash team by team ID.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTeamById</p> <p>Returns:</p> Type Description <p>Team object with:</p> <ul> <li>id: Team ID</li> </ul> <ul> <li>tournamentId</li> </ul> <ul> <li>name: Team name</li> </ul> <ul> <li>iconId: Team icon</li> </ul> <ul> <li>tier: Tournament tier</li> </ul> <ul> <li>captain: Captain summoner ID</li> </ul> <ul> <li>abbreviation: Team abbreviation</li> </ul> <ul> <li>players: List of player objects</li> </ul> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/teams/{teamId}\")\nasync def get_clash_team(\n    teamId: str,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get clash team by team ID.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTeamById\n\n    Returns:\n        Team object with:\n        - id: Team ID\n        - tournamentId\n        - name: Team name\n        - iconId: Team icon\n        - tier: Tournament tier\n        - captain: Captain summoner ID\n        - abbreviation: Team abbreviation\n        - players: List of player objects\n    \"\"\"\n    cache_key = f\"clash:team:{region}:{teamId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash team\", teamId=teamId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash team data\", teamId=teamId, region=region)\n    path = f\"/lol/clash/v1/teams/{teamId}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_team)\n    logger.success(\"Clash team data fetched\", teamId=teamId, name=data.get(\"name\"))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.clash.get_clash_tournaments","title":"<code>get_clash_tournaments(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get all active and upcoming clash tournaments.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournaments</p> <p>Returns:</p> Type Description <p>List of tournament objects with:</p> <ul> <li>id: Tournament ID</li> </ul> <ul> <li>themeId: Theme ID</li> </ul> <ul> <li>nameKey: Name key for localization</li> </ul> <ul> <li>nameKeySecondary: Secondary name key</li> </ul> <ul> <li>schedule: List of tournament phase objects</li> </ul> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/tournaments\")\nasync def get_clash_tournaments(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get all active and upcoming clash tournaments.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournaments\n\n    Returns:\n        List of tournament objects with:\n        - id: Tournament ID\n        - themeId: Theme ID\n        - nameKey: Name key for localization\n        - nameKeySecondary: Secondary name key\n        - schedule: List of tournament phase objects\n    \"\"\"\n    cache_key = f\"clash:tournaments:{region}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash tournaments\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash tournaments\", region=region)\n    path = \"/lol/clash/v1/tournaments\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_tournament)\n    logger.success(\"Clash tournaments fetched\", region=region, count=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.clash.get_clash_tournament","title":"<code>get_clash_tournament(tournamentId: int, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get clash tournament by tournament ID.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournamentById</p> <p>Returns:</p> Type Description <p>Tournament object with:</p> <ul> <li>id: Tournament ID</li> </ul> <ul> <li>themeId: Theme ID</li> </ul> <ul> <li>nameKey: Name key</li> </ul> <ul> <li>nameKeySecondary: Secondary name key</li> </ul> <ul> <li>schedule: Tournament schedule phases</li> </ul> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/tournaments/{tournamentId}\")\nasync def get_clash_tournament(\n    tournamentId: int,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get clash tournament by tournament ID.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournamentById\n\n    Returns:\n        Tournament object with:\n        - id: Tournament ID\n        - themeId: Theme ID\n        - nameKey: Name key\n        - nameKeySecondary: Secondary name key\n        - schedule: Tournament schedule phases\n    \"\"\"\n    cache_key = f\"clash:tournament:{region}:{tournamentId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash tournament\", tournamentId=tournamentId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash tournament\", tournamentId=tournamentId, region=region)\n    path = f\"/lol/clash/v1/tournaments/{tournamentId}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_tournament)\n    logger.success(\"Clash tournament fetched\", tournamentId=tournamentId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.clash.get_clash_tournament_by_team","title":"<code>get_clash_tournament_by_team(teamId: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get clash tournament that a team is registered for.</p> <p>API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournamentByTeam</p> <p>Returns:</p> Type Description <p>Tournament object for the team's registered tournament.</p> Source code in <code>app/routers/clash.py</code> <pre><code>@router.get(\"/tournaments/by-team/{teamId}\")\nasync def get_clash_tournament_by_team(\n    teamId: str,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get clash tournament that a team is registered for.\n\n    API Reference: https://developer.riotgames.com/apis#clash-v1/GET_getTournamentByTeam\n\n    Returns:\n        Tournament object for the team's registered tournament.\n    \"\"\"\n    cache_key = f\"clash:tournament:team:{region}:{teamId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for clash tournament by team\", teamId=teamId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching clash tournament by team\", teamId=teamId, region=region)\n    path = f\"/lol/clash/v1/tournaments/by-team/{teamId}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_clash_team)\n    logger.success(\"Clash tournament by team fetched\", teamId=teamId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#challenges-router","title":"Challenges Router","text":""},{"location":"api/routers/#app.routers.challenges","title":"<code>app.routers.challenges</code>","text":"<p>Challenges-V1 API endpoints (Player challenges and progression).</p> <p>Riot Developer Portal API Reference: https://developer.riotgames.com/apis#lol-challenges-v1</p>"},{"location":"api/routers/#app.routers.challenges.get_all_challenges_config","title":"<code>get_all_challenges_config(region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get configuration for all challenges.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getAllChallengeConfigs</p> <p>Returns list of all challenge configuration objects with: - id: Challenge ID - localizedNames: Localized challenge names - state: Challenge state (ENABLED, DISABLED, etc.) - leaderboard: Whether has leaderboard - thresholds: Thresholds for tiers</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/challenges/config\")\nasync def get_all_challenges_config(\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get configuration for all challenges.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getAllChallengeConfigs\n\n    Returns list of all challenge configuration objects with:\n    - id: Challenge ID\n    - localizedNames: Localized challenge names\n    - state: Challenge state (ENABLED, DISABLED, etc.)\n    - leaderboard: Whether has leaderboard\n    - thresholds: Thresholds for tiers\n    \"\"\"\n    cache_key = f\"challenges:config:{region}\"\n\n    # Check cache (challenges config changes rarely)\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenges config\", region=region)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching challenges config\", region=region)\n    path = \"/lol/challenges/v1/challenges/config\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_config)\n    logger.success(\"Challenges config fetched\", region=region, count=len(data))\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.challenges.get_challenge_config","title":"<code>get_challenge_config(challengeId: int, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get configuration for a specific challenge.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengeConfigs</p> <p>Returns:</p> Type Description <p>Challenge configuration object with thresholds, localized names, etc.</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/challenges/{challengeId}/config\")\nasync def get_challenge_config(\n    challengeId: int,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get configuration for a specific challenge.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengeConfigs\n\n    Returns:\n        Challenge configuration object with thresholds, localized names, etc.\n    \"\"\"\n    cache_key = f\"challenges:config:{region}:{challengeId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenge config\", challengeId=challengeId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching challenge config\", challengeId=challengeId, region=region)\n    path = f\"/lol/challenges/v1/challenges/{challengeId}/config\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_config)\n    logger.success(\"Challenge config fetched\", challengeId=challengeId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.challenges.get_challenge_leaderboard","title":"<code>get_challenge_leaderboard(challengeId: int, level: str, region: str = Query(default=(settings.riot_default_region), description='Region code'), limit: int = Query(default=None, ge=1, description='Limit results (optional)'))</code>  <code>async</code>","text":"<p>Get leaderboard for a specific challenge at a specific level.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengeLeaderboards</p> <p>Parameters:</p> Name Type Description Default <code>challengeId</code> <code>int</code> <p>Challenge ID</p> required <code>level</code> <code>str</code> <p>Challenge level (MASTER, GRANDMASTER, CHALLENGER)</p> required <code>limit</code> <code>int</code> <p>Optional limit on results</p> <code>Query(default=None, ge=1, description='Limit results (optional)')</code> <p>Returns:</p> Type Description <p>List of leaderboard entries with player PUUIDs and values.</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/challenges/{challengeId}/leaderboards/by-level/{level}\")\nasync def get_challenge_leaderboard(\n    challengeId: int,\n    level: str,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n    limit: int = Query(default=None, ge=1, description=\"Limit results (optional)\"),\n):\n    \"\"\"\n    Get leaderboard for a specific challenge at a specific level.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengeLeaderboards\n\n    Args:\n        challengeId: Challenge ID\n        level: Challenge level (MASTER, GRANDMASTER, CHALLENGER)\n        limit: Optional limit on results\n\n    Returns:\n        List of leaderboard entries with player PUUIDs and values.\n    \"\"\"\n    cache_key = f\"challenges:leaderboard:{region}:{challengeId}:{level}:{limit}\"\n\n    # Check cache (short TTL as leaderboards change frequently)\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenge leaderboard\", challengeId=challengeId, level=level)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\n        \"Fetching challenge leaderboard\", challengeId=challengeId, level=level, region=region\n    )\n    path = f\"/lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}\"\n    params = {\"limit\": limit} if limit else None\n    data = await riot_client.get(path, region, is_platform_endpoint=False, params=params)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_leaderboard)\n    logger.success(\"Challenge leaderboard fetched\", challengeId=challengeId, level=level)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.challenges.get_challenge_percentiles","title":"<code>get_challenge_percentiles(challengeId: int, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get percentile distribution for a challenge.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengePercentiles</p> <p>Returns map of challenge values to percentiles.</p> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/challenges/{challengeId}/percentiles\")\nasync def get_challenge_percentiles(\n    challengeId: int,\n    region: str = Query(default=settings.riot_default_region, description=\"Region code\"),\n):\n    \"\"\"\n    Get percentile distribution for a challenge.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getChallengePercentiles\n\n    Returns map of challenge values to percentiles.\n    \"\"\"\n    cache_key = f\"challenges:percentiles:{region}:{challengeId}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for challenge percentiles\", challengeId=challengeId)\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching challenge percentiles\", challengeId=challengeId, region=region)\n    path = f\"/lol/challenges/v1/challenges/{challengeId}/percentiles\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_percentiles)\n    logger.success(\"Challenge percentiles fetched\", challengeId=challengeId)\n\n    return data\n</code></pre>"},{"location":"api/routers/#app.routers.challenges.get_player_challenges","title":"<code>get_player_challenges(puuid: str, region: str = Query(default=(settings.riot_default_region), description='Region code'))</code>  <code>async</code>","text":"<p>Get all challenge data for a player by PUUID.</p> <p>API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getPlayerData</p> <p>Returns:</p> Type Description <ul> <li>totalPoints: Total challenge points</li> </ul> <ul> <li>categoryPoints: Points per category</li> </ul> <ul> <li>challenges: List of all challenge progress</li> </ul> <ul> <li>preferences: Player challenge preferences</li> </ul> Source code in <code>app/routers/challenges.py</code> <pre><code>@router.get(\"/player-data/{puuid}\")\nasync def get_player_challenges(\n    puuid: str, region: str = Query(default=settings.riot_default_region, description=\"Region code\")\n):\n    \"\"\"\n    Get all challenge data for a player by PUUID.\n\n    API Reference: https://developer.riotgames.com/apis#lol-challenges-v1/GET_getPlayerData\n\n    Returns:\n        - totalPoints: Total challenge points\n        - categoryPoints: Points per category\n        - challenges: List of all challenge progress\n        - preferences: Player challenge preferences\n    \"\"\"\n    cache_key = f\"challenges:player:{region}:{puuid}\"\n\n    # Check cache\n    cached_data = await cache.get(cache_key)\n    if cached_data:\n        logger.debug(\"Cache hit for player challenges\", puuid=puuid[:8])\n        return cached_data\n\n    # Fetch from Riot API\n    logger.info(\"Fetching player challenges\", puuid=puuid[:8], region=region)\n    path = f\"/lol/challenges/v1/player-data/{puuid}\"\n    data = await riot_client.get(path, region, is_platform_endpoint=False)\n\n    # Cache with configured TTL\n    await cache.set(cache_key, data, ttl=settings.cache_ttl_challenges_player)\n    logger.success(\n        \"Player challenges fetched\",\n        puuid=puuid[:8],\n        totalPoints=data.get(\"totalPoints\", {}).get(\"current\", 0),\n    )\n\n    return data\n</code></pre>"},{"location":"architecture/caching/","title":"Caching Architecture","text":"<p>This section details the comprehensive caching strategy implemented in the LOLStonks API Gateway, designed to optimize performance while ensuring data freshness.</p>"},{"location":"architecture/caching/#overview","title":"Overview","text":"<p>The caching system uses Redis as the primary caching backend with a multi-layer approach that balances performance, data freshness, and storage efficiency.</p>"},{"location":"architecture/caching/#caching-architecture_1","title":"Caching Architecture","text":"<pre><code>graph TB\n    Request[Client Request] --&gt; Gateway[API Gateway]\n    Gateway --&gt; CheckCache{Check Cache}\n\n    CheckCache --&gt;|Hit| ReturnCached[Return Cached Response]\n    CheckCache --&gt;|Miss| APICall[Make API Call]\n\n    APICall --&gt; RiotAPI[Riot API]\n    RiotAPI --&gt; ProcessResponse[Process Response]\n    ProcessResponse --&gt; StoreCache[Store in Cache]\n    StoreCache --&gt; ReturnResponse[Return Response]\n\n    ReturnCached --&gt; Client[Client Response]\n    ReturnResponse --&gt; Client\n\n    subgraph \"Cache Layers\"\n        L1[TTL Cache - Fast Access]\n        L2[Persistent Storage]\n        L3[Match Tracking Set]\n    end\n\n    StoreCache --&gt; L1\n    StoreCache --&gt; L2\n    StoreCache --&gt; L3\n</code></pre>"},{"location":"architecture/caching/#cache-configuration","title":"Cache Configuration","text":""},{"location":"architecture/caching/#environment-variables","title":"Environment Variables","text":"<pre><code># Redis connection settings\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=\nREDIS_POOL_SIZE=10\nREDIS_POOL_TIMEOUT=30\n\n# Cache TTL settings (in seconds)\nCACHE_TTL_SUMMONER=3600     # 1 hour\nCACHE_TTL_MATCH=86400       # 24 hours\nCACHE_TTL_LEAGUE=1800       # 30 minutes\nCACHE_TTL_MASTERY=7200      # 2 hours\nCACHE_TTL_CHAMPION=604800   # 1 week\nCACHE_TTL_CLASH=3600        # 1 hour\nCACHE_TTL_CHALLENGES=1800   # 30 minutes\n\n# Match tracking settings\nMATCH_TRACKING_TTL=604800   # 1 week\n</code></pre>"},{"location":"architecture/caching/#ttl-strategy","title":"TTL Strategy","text":"<p>Different data types have different TTL (Time To Live) values based on their volatility:</p> Data Type TTL Rationale Summoner Info 1 hour Profile data changes relatively infrequently Match Data 24 hours Historical data never changes League Data 30 minutes Competitive data changes frequently Champion Mastery 2 hours Mastery scores change regularly Champion Info 1 week Static data changes very infrequently Clash Data 1 hour Tournament data changes during events Challenges 30 minutes Challenge data updates frequently"},{"location":"architecture/caching/#redis-cache-implementation","title":"Redis Cache Implementation","text":""},{"location":"architecture/caching/#core-cache-class","title":"Core Cache Class","text":"<pre><code># app/cache/redis_cache.py\nimport json\nimport asyncio\nfrom typing import Optional, Any, Union\nfrom datetime import datetime, timedelta\nimport redis.asyncio as redis\nfrom redis.asyncio import ConnectionPool\n\nclass RedisCache:\n    \"\"\"\n    High-performance Redis cache with TTL support and connection pooling.\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str = \"localhost\",\n        port: int = 6379,\n        db: int = 0,\n        password: Optional[str] = None,\n        pool_size: int = 10,\n        pool_timeout: int = 30\n    ):\n        self.pool = ConnectionPool.from_url(\n            f\"redis://:{password}@{host}:{port}/{db}\" if password else f\"redis://{host}:{port}/{db}\",\n            max_connections=pool_size,\n            socket_timeout=pool_timeout,\n            socket_connect_timeout=5,\n            retry_on_timeout=True\n        )\n        self.redis = redis.Redis(connection_pool=self.pool)\n        self.ttl_config = self._load_ttl_config()\n\n    def _load_ttl_config(self) -&gt; dict:\n        \"\"\"Load TTL configuration from environment variables.\"\"\"\n        return {\n            \"summoner\": int(os.getenv(\"CACHE_TTL_SUMMONER\", 3600)),\n            \"match\": int(os.getenv(\"CACHE_TTL_MATCH\", 86400)),\n            \"league\": int(os.getenv(\"CACHE_TTL_LEAGUE\", 1800)),\n            \"mastery\": int(os.getenv(\"CACHE_TTL_MASTERY\", 7200)),\n            \"champion\": int(os.getenv(\"CACHE_TTL_CHAMPION\", 604800)),\n            \"clash\": int(os.getenv(\"CACHE_TTL_CLASH\", 3600)),\n            \"challenges\": int(os.getenv(\"CACHE_TTL_CHALLENGES\", 1800))\n        }\n\n    def _generate_key(self, endpoint: str, region: str, identifier: str) -&gt; str:\n        \"\"\"Generate consistent cache key.\"\"\"\n        return f\"lolstonks:{endpoint}:{region}:{identifier}\"\n\n    async def get(self, endpoint: str, region: str, identifier: str) -&gt; Optional[dict]:\n        \"\"\"Get cached data.\"\"\"\n        key = self._generate_key(endpoint, region, identifier)\n        try:\n            cached_data = await self.redis.get(key)\n            if cached_data:\n                return json.loads(cached_data)\n        except Exception as e:\n            logger.error(f\"Cache get error for key {key}: {e}\")\n        return None\n\n    async def set(\n        self,\n        endpoint: str,\n        region: str,\n        identifier: str,\n        data: dict,\n        ttl: Optional[int] = None\n    ) -&gt; bool:\n        \"\"\"Set data in cache with TTL.\"\"\"\n        key = self._generate_key(endpoint, region, identifier)\n        if ttl is None:\n            ttl = self.ttl_config.get(endpoint, 3600)\n\n        try:\n            await self.redis.setex(\n                key,\n                ttl,\n                json.dumps(data, default=str)\n            )\n            return True\n        except Exception as e:\n            logger.error(f\"Cache set error for key {key}: {e}\")\n            return False\n\n    async def delete(self, endpoint: str, region: str, identifier: str) -&gt; bool:\n        \"\"\"Delete data from cache.\"\"\"\n        key = self._generate_key(endpoint, region, identifier)\n        try:\n            await self.redis.delete(key)\n            return True\n        except Exception as e:\n            logger.error(f\"Cache delete error for key {key}: {e}\")\n            return False\n</code></pre>"},{"location":"architecture/caching/#cache-decorator","title":"Cache Decorator","text":"<pre><code># app/cache/decorators.py\nimport functools\nfrom typing import Callable, Any\n\ndef cached(endpoint: str, ttl: Optional[int] = None):\n    \"\"\"\n    Decorator for caching function results.\n\n    Args:\n        endpoint: Cache endpoint type\n        ttl: Custom TTL override\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        @functools.wraps(func)\n        async def wrapper(*args, **kwargs) -&gt; Any:\n            # Extract cache parameters\n            region = kwargs.get('region', 'euw1')\n            cache_key = kwargs.get('cache_key', str(args[1:]) if args else str(kwargs))\n\n            cache: RedisCache = kwargs.get('cache')\n            if not cache:\n                return await func(*args, **kwargs)\n\n            # Try to get from cache\n            cached_result = await cache.get(endpoint, region, cache_key)\n            if cached_result:\n                logger.debug(f\"Cache hit for {endpoint}:{region}:{cache_key}\")\n                return cached_result\n\n            # Cache miss - execute function\n            logger.debug(f\"Cache miss for {endpoint}:{region}:{cache_key}\")\n            result = await func(*args, **kwargs)\n\n            # Store in cache\n            await cache.set(endpoint, region, cache_key, result, ttl)\n            return result\n\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"architecture/caching/#match-tracking-system","title":"Match Tracking System","text":""},{"location":"architecture/caching/#dual-storage-approach","title":"Dual Storage Approach","text":"<p>The match tracking system uses both TTL cache and persistent storage:</p> <pre><code># app/cache/tracking.py\nimport json\nfrom typing import Set\nfrom datetime import datetime, timedelta\n\nclass MatchTracker:\n    \"\"\"\n    Match tracking service to prevent duplicate match processing.\n\n    Uses dual storage:\n    1. TTL cache for recent matches (fast access)\n    2. Persistent Redis set for all processed matches\n    \"\"\"\n\n    def __init__(self, redis_cache: RedisCache, ttl: int = 604800):\n        self.cache = redis_cache\n        self.ttl = ttl\n        self.processed_key = \"lolstonks:matches:processed\"\n        self.recent_key = \"lolstonks:matches:recent\"\n\n    async def is_processed(self, match_id: str) -&gt; bool:\n        \"\"\"Check if match has been processed.\"\"\"\n        # Check TTL cache first (fast path)\n        in_recent = await self.cache.redis.exists(f\"{self.recent_key}:{match_id}\")\n        if in_recent:\n            return True\n\n        # Check persistent set\n        is_processed = await self.cache.redis.sismember(self.processed_key, match_id)\n\n        # If found in persistent set, add to recent cache for faster future checks\n        if is_processed:\n            await self.cache.redis.setex(\n                f\"{self.recent_key}:{match_id}\",\n                self.ttl,\n                \"1\"\n            )\n\n        return is_processed\n\n    async def mark_processed(self, match_id: str) -&gt; None:\n        \"\"\"Mark match as processed.\"\"\"\n        # Add to persistent set\n        await self.cache.redis.sadd(self.processed_key, match_id)\n\n        # Add to TTL cache for fast access\n        await self.cache.redis.setex(\n            f\"{self.recent_key}:{match_id}\",\n            self.ttl,\n            \"1\"\n        )\n\n    async def get_processed_count(self) -&gt; int:\n        \"\"\"Get total number of processed matches.\"\"\"\n        return await self.cache.redis.scard(self.processed_key)\n\n    async def cleanup_expired(self) -&gt; int:\n        \"\"\"Clean up expired entries from recent cache.\"\"\"\n        # This is handled automatically by Redis TTL\n        # But we can force cleanup if needed\n        pattern = f\"{self.recent_key}:*\"\n        cursor = 0\n        deleted = 0\n\n        while True:\n            cursor, keys = await self.cache.redis.scan(cursor, match=pattern, count=100)\n            if keys:\n                deleted += await self.cache.redis.delete(*keys)\n            if cursor == 0:\n                break\n\n        return deleted\n</code></pre>"},{"location":"architecture/caching/#cache-integration-with-routers","title":"Cache Integration with Routers","text":""},{"location":"architecture/caching/#example-router-with-caching","title":"Example Router with Caching","text":"<pre><code># app/routers/summoner.py\nfrom fastapi import APIRouter, Depends, Query\nfrom app.cache.redis_cache import RedisCache\nfrom app.cache.decorators import cached\nfrom app.riot.client import RiotClient\n\nrouter = APIRouter(prefix=\"/summoner\", tags=[\"summoner\"])\n\n@router.get(\"/by-name/{summonerName}\")\n@cached(endpoint=\"summoner\", ttl=3600)\nasync def get_summoner_by_name(\n    summonerName: str,\n    region: str = Query(default=\"euw1\"),\n    riot_client: RiotClient = Depends(),\n    cache: RedisCache = Depends()\n) -&gt; dict:\n    \"\"\"\n    Get summoner by summoner name with caching.\n\n    Cached for 1 hour to balance performance and data freshness.\n    \"\"\"\n    # Generate unique cache key\n    cache_key = f\"by-name:{summonerName.lower()}\"\n\n    # Make API call (only if cache miss)\n    return await riot_client.get(\n        f\"/lol/summoner/v4/summoners/by-name/{summonerName}\",\n        region=region\n    )\n\n@router.get(\"/by-puuid/{puuid}\")\n@cached(endpoint=\"summoner\", ttl=3600)\nasync def get_summoner_by_puuid(\n    puuid: str,\n    region: str = Query(default=\"euw1\"),\n    riot_client: RiotClient = Depends(),\n    cache: RedisCache = Depends()\n) -&gt; dict:\n    \"\"\"Get summoner by PUUID with caching.\"\"\"\n    cache_key = f\"by-puuid:{puuid}\"\n    return await riot_client.get(\n        f\"/lol/summoner/v4/summoners/by-puuid/{puuid}\",\n        region=region\n    )\n</code></pre>"},{"location":"architecture/caching/#cache-performance-optimization","title":"Cache Performance Optimization","text":""},{"location":"architecture/caching/#connection-pooling","title":"Connection Pooling","text":"<pre><code># Optimized connection pool configuration\nclass OptimizedRedisCache(RedisCache):\n    \"\"\"\n    Redis cache with optimized connection pooling.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        # Enhanced connection pool settings\n        pool_config = {\n            \"max_connections\": kwargs.get(\"pool_size\", 20),\n            \"retry_on_timeout\": True,\n            \"socket_keepalive\": True,\n            \"socket_keepalive_options\": {},\n            \"health_check_interval\": 30\n        }\n\n        super().__init__(**{**kwargs, **pool_config})\n\n    async def batch_get(self, keys: list[str]) -&gt; dict[str, Optional[dict]]:\n        \"\"\"Batch get multiple keys for better performance.\"\"\"\n        try:\n            values = await self.redis.mget(keys)\n            return {\n                key: json.loads(value) if value else None\n                for key, value in zip(keys, values)\n            }\n        except Exception as e:\n            logger.error(f\"Batch get error: {e}\")\n            return {key: None for key in keys}\n\n    async def batch_set(self, data: dict[str, dict], ttl: int) -&gt; bool:\n        \"\"\"Batch set multiple keys.\"\"\"\n        try:\n            pipe = self.redis.pipeline()\n            for key, value in data.items():\n                pipe.setex(key, ttl, json.dumps(value, default=str))\n            await pipe.execute()\n            return True\n        except Exception as e:\n            logger.error(f\"Batch set error: {e}\")\n            return False\n</code></pre>"},{"location":"architecture/caching/#cache-warming-strategy","title":"Cache Warming Strategy","text":"<pre><code># app/cache/warming.py\nclass CacheWarmer:\n    \"\"\"\n    Proactive cache warming for frequently accessed data.\n    \"\"\"\n\n    def __init__(self, riot_client: RiotClient, cache: RedisCache):\n        self.riot_client = riot_client\n        self.cache = cache\n        self.high_activity_summoners = set()\n\n    async def warm_summoner_cache(self, summoner_names: list[str], region: str) -&gt; None:\n        \"\"\"Warm cache for high-activity summoners.\"\"\"\n        for name in summoner_names:\n            try:\n                # Check if already cached\n                cached = await self.cache.get(\"summoner\", region, f\"by-name:{name}\")\n                if not cached:\n                    # Fetch and cache\n                    data = await self.riot_client.get(\n                        f\"/lol/summoner/v4/summoners/by-name/{name}\",\n                        region=region\n                    )\n                    await self.cache.set(\"summoner\", region, f\"by-name:{name}\", data)\n            except Exception as e:\n                logger.error(f\"Cache warming error for {name}: {e}\")\n\n    async def schedule_warming(self) -&gt; None:\n        \"\"\"Schedule periodic cache warming.\"\"\"\n        while True:\n            try:\n                # Warm cache for high-activity summoners\n                await self.warm_summoner_cache(\n                    list(self.high_activity_summoners),\n                    \"euw1\"  # Default region\n                )\n                await asyncio.sleep(300)  # Every 5 minutes\n            except Exception as e:\n                logger.error(f\"Cache warming error: {e}\")\n                await asyncio.sleep(60)  # Retry after 1 minute\n</code></pre>"},{"location":"architecture/caching/#cache-monitoring-and-metrics","title":"Cache Monitoring and Metrics","text":""},{"location":"architecture/caching/#cache-performance-metrics","title":"Cache Performance Metrics","text":"<pre><code># app/cache/metrics.py\nclass CacheMetrics:\n    \"\"\"\n    Cache performance metrics collection.\n    \"\"\"\n\n    def __init__(self):\n        self.hits = 0\n        self.misses = 0\n        self.sets = 0\n        self.errors = 0\n        self.start_time = datetime.utcnow()\n\n    def record_hit(self) -&gt; None:\n        \"\"\"Record cache hit.\"\"\"\n        self.hits += 1\n\n    def record_miss(self) -&gt; None:\n        \"\"\"Record cache miss.\"\"\"\n        self.misses += 1\n\n    def record_set(self) -&gt; None:\n        \"\"\"Record cache set operation.\"\"\"\n        self.sets += 1\n\n    def record_error(self) -&gt; None:\n        \"\"\"Record cache error.\"\"\"\n        self.errors += 1\n\n    def get_hit_rate(self) -&gt; float:\n        \"\"\"Calculate cache hit rate.\"\"\"\n        total = self.hits + self.misses\n        return (self.hits / total * 100) if total &gt; 0 else 0.0\n\n    def get_metrics(self) -&gt; dict:\n        \"\"\"Get current metrics.\"\"\"\n        uptime = (datetime.utcnow() - self.start_time).total_seconds()\n        return {\n            \"hits\": self.hits,\n            \"misses\": self.misses,\n            \"sets\": self.sets,\n            \"errors\": self.errors,\n            \"hit_rate\": self.get_hit_rate(),\n            \"uptime_seconds\": uptime,\n            \"operations_per_second\": (self.hits + self.misses + self.sets) / uptime\n        }\n</code></pre>"},{"location":"architecture/caching/#health-check-integration","title":"Health Check Integration","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check including cache status.\"\"\"\n    cache_metrics = cache_metrics_collector.get_metrics()\n\n    # Test Redis connection\n    try:\n        await cache.redis.ping()\n        cache_status = \"healthy\"\n    except Exception:\n        cache_status = \"unhealthy\"\n\n    return {\n        \"status\": \"ok\",\n        \"cache\": {\n            \"status\": cache_status,\n            \"hit_rate\": cache_metrics[\"hit_rate\"],\n            \"operations_per_second\": cache_metrics[\"operations_per_second\"],\n            \"total_operations\": cache_metrics[\"hits\"] + cache_metrics[\"misses\"]\n        }\n    }\n</code></pre>"},{"location":"architecture/caching/#advanced-features","title":"Advanced Features","text":""},{"location":"architecture/caching/#cache-invalidation","title":"Cache Invalidation","text":"<pre><code>class CacheInvalidation:\n    \"\"\"\n    Smart cache invalidation based on data changes.\n    \"\"\"\n\n    def __init__(self, cache: RedisCache):\n        self.cache = cache\n\n    async def invalidate_summoner_cache(self, puuid: str, region: str) -&gt; None:\n        \"\"\"Invalidate all cache entries for a summoner.\"\"\"\n        patterns = [\n            f\"lolstonks:summoner:{region}:by-puuid:{puuid}\",\n            f\"lolstonks:summoner:{region}:by-account:*\",  # Account-based entries\n            f\"lolstonks:mastery:{region}:{puuid}\",\n            f\"lolstonks:league:{region}:by-summoner:{puuid}\"\n        ]\n\n        for pattern in patterns:\n            if \"*\" in pattern:\n                # Delete all matching keys\n                cursor = 0\n                while True:\n                    cursor, keys = await self.cache.redis.scan(cursor, match=pattern)\n                    if keys:\n                        await self.cache.redis.delete(*keys)\n                    if cursor == 0:\n                        break\n            else:\n                await self.cache.redis.delete(pattern)\n\n    async def invalidate_match_cache(self, match_id: str, region: str) -&gt; None:\n        \"\"\"Invalidate cache entries for a match.\"\"\"\n        patterns = [\n            f\"lolstonks:match:{region}:by-id:{match_id}\",\n            f\"lolstonks:match:{region}:timeline:{match_id}\"\n        ]\n\n        for pattern in patterns:\n            await self.cache.redis.delete(pattern)\n</code></pre>"},{"location":"architecture/caching/#distributed-caching","title":"Distributed Caching","text":"<p>For multi-instance deployments:</p> <pre><code>class DistributedCache:\n    \"\"\"\n    Cache coordination across multiple instances.\n    \"\"\"\n\n    def __init__(self, cache: RedisCache, instance_id: str):\n        self.cache = cache\n        self.instance_id = instance_id\n        self.coordination_channel = \"cache:coordination\"\n\n    async def invalidate_global(self, key_pattern: str) -&gt; None:\n        \"\"\"Broadcast cache invalidation to all instances.\"\"\"\n        message = {\n            \"instance_id\": self.instance_id,\n            \"action\": \"invalidate\",\n            \"pattern\": key_pattern,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n\n        await self.cache.redis.publish(\n            self.coordination_channel,\n            json.dumps(message)\n        )\n\n    async def listen_for_invalidations(self) -&gt; None:\n        \"\"\"Listen for cache invalidation messages.\"\"\"\n        pubsub = self.cache.redis.pubsub()\n        await pubsub.subscribe(self.coordination_channel)\n\n        async for message in pubsub.listen():\n            if message[\"type\"] == \"message\":\n                try:\n                    data = json.loads(message[\"data\"])\n                    if data[\"instance_id\"] != self.instance_id:\n                        await self._handle_invalidation(data)\n                except Exception as e:\n                    logger.error(f\"Invalidation handling error: {e}\")\n</code></pre>"},{"location":"architecture/caching/#best-practices","title":"Best Practices","text":""},{"location":"architecture/caching/#cache-design-principles","title":"Cache Design Principles","text":"<ol> <li>Appropriate TTL: Set TTL based on data volatility</li> <li>Consistent Keys: Use consistent cache key patterns</li> <li>Error Handling: Graceful degradation when cache fails</li> <li>Monitoring: Track cache hit rates and performance</li> <li>Size Management: Monitor memory usage and implement eviction policies</li> </ol>"},{"location":"architecture/caching/#performance-guidelines","title":"Performance Guidelines","text":"<ol> <li>Batch Operations: Use batch get/set operations when possible</li> <li>Connection Pooling: Reuse Redis connections efficiently</li> <li>Async Operations: Use async/await throughout the cache layer</li> <li>Cache Warming: Proactively cache frequently accessed data</li> <li>Compression: Compress large data objects before caching</li> </ol>"},{"location":"architecture/caching/#security-considerations","title":"Security Considerations","text":"<ol> <li>Access Control: Secure Redis access with authentication</li> <li>Network Security: Use secure connections for Redis</li> <li>Data Sanitization: Sanitize cache keys and values</li> <li>Isolation: Use separate Redis databases for different environments</li> </ol> <p>The comprehensive caching strategy provides optimal performance while maintaining data consistency and supporting the high-throughput requirements of the LOLStonks API Gateway.</p>"},{"location":"architecture/models/","title":"Data Models &amp; Validation","text":"<p>This section describes the comprehensive Pydantic V2 input validation system used throughout the LOLStonks API Gateway.</p>"},{"location":"architecture/models/#overview","title":"Overview","text":"<p>All API endpoints use Pydantic V2 models for input validation, providing:</p> <ul> <li>Type Safety: Automatic validation of input types and constraints</li> <li>Self-Documenting API: Automatic OpenAPI schema generation</li> <li>Reusability: Shared models reduce code duplication</li> <li>Extensibility: Easy to add new validation rules and constraints</li> <li>Better Error Handling: Detailed validation error messages</li> </ul>"},{"location":"architecture/models/#model-architecture","title":"Model Architecture","text":""},{"location":"architecture/models/#directory-structure","title":"Directory Structure","text":"<pre><code>app/models/\n\u251c\u2500\u2500 __init__.py          # Central exports and registry\n\u251c\u2500\u2500 common.py            # Base models, enums, and shared utilities\n\u251c\u2500\u2500 account.py           # ACCOUNT-V1 (Riot ID) models\n\u251c\u2500\u2500 summoner.py          # SUMMONER-V4 models\n\u251c\u2500\u2500 match.py             # MATCH-V5 models\n\u251c\u2500\u2500 league.py            # LEAGUE-V4 models\n\u251c\u2500\u2500 champion_mastery.py  # CHAMPION-MASTERY-V4 models\n\u251c\u2500\u2500 challenges.py        # CHALLENGES-V1 models\n\u251c\u2500\u2500 clash.py             # CLASH-V1 models\n\u251c\u2500\u2500 spectator.py         # SPECTATOR-V5 models\n\u251c\u2500\u2500 platform.py          # LOL-STATUS-V4 models\n\u2514\u2500\u2500 champion.py          # CHAMPION-V3 models\n</code></pre>"},{"location":"architecture/models/#core-components","title":"Core Components","text":""},{"location":"architecture/models/#regional-routing-models","title":"Regional Routing Models","text":""},{"location":"architecture/models/#platform-regions","title":"Platform Regions","text":"<p>Used for Account-V1 and Match-V5 APIs that require regional routing:</p> <pre><code>class PlatformRegion(str, Enum):\n    \"\"\"Regional routing for platform endpoints.\"\"\"\n    AMERICAS = \"americas\"\n    EUROPE = \"europe\"\n    ASIA = \"asia\"\n    SEA = \"sea\"\n</code></pre>"},{"location":"architecture/models/#game-regions","title":"Game Regions","text":"<p>Used for game-specific endpoints (summoner, league, etc.):</p> <pre><code>class GameRegion(str, Enum):\n    \"\"\"Game-specific regions.\"\"\"\n    # Europe\n    EUW1 = \"euw1\"     # Europe West\n    EUN1 = \"eun1\"     # Europe Nordic &amp; East\n    TR1 = \"tr1\"       # Turkey\n    RU = \"ru\"         # Russia\n\n    # Americas\n    NA1 = \"na1\"       # North America\n    BR1 = \"br1\"       # Brazil\n    LA1 = \"la1\"       # Latin America North\n    LA2 = \"la2\"       # Latin America South\n\n    # Asia\n    KR = \"kr\"         # Korea\n    JP1 = \"jp1\"       # Japan\n\n    # SEA/Oceania\n    OC1 = \"oc1\"       # Oceania\n    PH2 = \"ph2\"       # Philippines\n    SG2 = \"sg2\"       # Singapore\n    TH2 = \"th2\"       # Thailand\n    TW2 = \"tw2\"       # Taiwan\n    VN2 = \"vn2\"       # Vietnam\n</code></pre>"},{"location":"architecture/models/#base-query-models","title":"Base Query Models","text":""},{"location":"architecture/models/#region-query","title":"Region Query","text":"<p>Standard region parameter for game-specific endpoints:</p> <pre><code>class RegionQuery(BaseModel):\n    \"\"\"Standard region parameter for game-specific endpoints.\"\"\"\n    region: Annotated[GameRegion, Field(\n        default_factory=lambda: GameRegion(settings.riot_default_region),\n        description=\"Riot API game region\"\n    )]\n</code></pre>"},{"location":"architecture/models/#platform-region-query","title":"Platform Region Query","text":"<p>Regional routing for platform endpoints:</p> <pre><code>class PlatformRegionQuery(BaseModel):\n    \"\"\"Regional routing for platform endpoints (ACCOUNT, MATCH APIs).\"\"\"\n    region: Annotated[PlatformRegion, Field(\n        default=PlatformRegion.AMERICAS,\n        description=\"Riot API platform region\"\n    )]\n</code></pre>"},{"location":"architecture/models/#pagination-query","title":"Pagination Query","text":"<p>Standard pagination parameters for list endpoints:</p> <pre><code>class PaginationQuery(BaseModel):\n    \"\"\"Pagination parameters for list endpoints.\"\"\"\n    start: Annotated[int, Field(\n        default=0,\n        ge=0,\n        description=\"Start index for pagination\"\n    )]\n    count: Annotated[int, Field(\n        default=20,\n        ge=1,\n        le=100,\n        description=\"Number of items to return (1-100)\"\n    )]\n</code></pre>"},{"location":"architecture/models/#specialized-enums","title":"Specialized Enums","text":""},{"location":"architecture/models/#queue-types","title":"Queue Types","text":"<p>Ranked queue identifiers:</p> <pre><code>class QueueType(str, Enum):\n    \"\"\"Ranked queue types.\"\"\"\n    RANKED_SOLO_5x5 = \"RANKED_SOLO_5x5\"\n    RANKED_FLEX_SR = \"RANKED_FLEX_SR\"\n    RANKED_FLEX_TT = \"RANKED_FLEX_TT\"\n</code></pre>"},{"location":"architecture/models/#challenge-levels","title":"Challenge Levels","text":"<p>Challenge tier levels:</p> <pre><code>class ChallengeLevel(str, Enum):\n    \"\"\"Challenge tier levels.\"\"\"\n    MASTER = \"MASTER\"\n    GRANDMASTER = \"GRANDMASTER\"\n    CHALLENGER = \"CHALLENGER\"\n</code></pre>"},{"location":"architecture/models/#usage-patterns","title":"Usage Patterns","text":""},{"location":"architecture/models/#router-implementation","title":"Router Implementation","text":"<p>Endpoints use FastAPI's dependency injection system with Pydantic models:</p> <pre><code>from typing import Annotated\nfrom fastapi import APIRouter, Depends\nfrom app.models.match import MatchIdsByPuuidParams, MatchIdsByPuuidQuery\n\nrouter = APIRouter()\n\n@router.get(\"/matches/by-puuid/{puuid}/ids\")\nasync def get_match_ids_by_puuid(\n    params: Annotated[MatchIdsByPuuidParams, Depends()],\n    query: Annotated[MatchIdsByPuuidQuery, Depends()],\n):\n    # Access validated parameters\n    puuid = params.puuid\n    region = query.region\n    start = query.start\n    count = query.count\n\n    # Optional filtering parameters\n    if query.startTime:\n        # Filter by start time\n        pass\n</code></pre>"},{"location":"architecture/models/#model-naming-conventions","title":"Model Naming Conventions","text":"<p>Models follow consistent naming patterns:</p> <ul> <li>Path Parameters: <code>{EndpointName}Params</code></li> <li> <p>Examples: <code>MatchIdsByPuuidParams</code>, <code>AccountByPuuidParams</code></p> </li> <li> <p>Query Parameters: <code>{EndpointName}Query</code></p> </li> <li>Examples: <code>MatchIdsByPuuidQuery</code>, <code>AccountByPuuidQuery</code></li> </ul>"},{"location":"architecture/models/#api-specific-examples","title":"API-Specific Examples","text":""},{"location":"architecture/models/#match-v5-models","title":"Match V5 Models","text":"<p>Enhanced query parameters for match history:</p> <pre><code>class MatchIdsByPuuidQuery(PlatformRegionQuery, PaginationQuery):\n    \"\"\"Match history query parameters with comprehensive filtering.\"\"\"\n    startTime: Annotated[Optional[int], Field(\n        default=None,\n        description=\"Filter matches after this timestamp (epoch milliseconds)\"\n    )]\n    endTime: Annotated[Optional[int], Field(\n        default=None,\n        description=\"Filter matches before this timestamp (epoch milliseconds)\"\n    )]\n    queue: Annotated[Optional[int], Field(\n        default=None,\n        description=\"Filter by queue ID (420 for Ranked Solo)\"\n    )]\n    type: Annotated[Optional[str], Field(\n        default=None,\n        description=\"Match type: ranked, normal, tourney, tutorial\"\n    )]\n</code></pre> <p>Example Usage: <pre><code>GET /lol/match/v5/matches/by-puuid/{puuid}/ids?region=europe&amp;start=0&amp;count=20&amp;startTime=1640000000&amp;queue=420&amp;type=ranked\n</code></pre></p>"},{"location":"architecture/models/#account-v1-models","title":"Account V1 Models","text":"<p>Riot ID validation with proper constraints:</p> <pre><code>class AccountByRiotIdParams(BaseModel):\n    \"\"\"Riot ID components with validation.\"\"\"\n    gameName: Annotated[str, Field(\n        min_length=1,\n        max_length=100,\n        description=\"Summoner name (1-100 characters)\"\n    )]\n    tagLine: Annotated[str, Field(\n        min_length=1,\n        max_length=100,\n        description=\"Tag line (1-100 characters)\"\n    )]\n</code></pre>"},{"location":"architecture/models/#league-v4-models","title":"League V4 Models","text":"<p>Enum-based queue validation:</p> <pre><code>class LeagueByQueueParams(BaseModel):\n    \"\"\"League parameters with queue type validation.\"\"\"\n    queue: Annotated[QueueType, Field(\n        description=\"Ranked queue type\"\n    )]\n</code></pre>"},{"location":"architecture/models/#validation-features","title":"Validation Features","text":""},{"location":"architecture/models/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"architecture/models/#string-length-validation","title":"String Length Validation","text":"<pre><code>puuid: Annotated[str, Field(\n    min_length=1,\n    max_length=100,\n    description=\"Player UUID (1-100 characters)\"\n)]\n</code></pre>"},{"location":"architecture/models/#numeric-range-validation","title":"Numeric Range Validation","text":"<pre><code>count: Annotated[int, Field(\n    ge=1,\n    le=100,\n    description=\"Number of items (1-100)\"\n)]\n</code></pre>"},{"location":"architecture/models/#pattern-matching","title":"Pattern Matching","text":"<pre><code>matchId: Annotated[str, Field(\n    pattern=r\"^[A-Z0-9]+_\\d+$\",\n    description=\"Match ID format: TRAILING_NUMBER\"\n)]\n</code></pre>"},{"location":"architecture/models/#enum-validation","title":"Enum Validation","text":"<pre><code>queue: Annotated[QueueType, Field(\n    description=\"Queue type for ranked play\"\n)]\n</code></pre>"},{"location":"architecture/models/#migration-status","title":"Migration Status","text":""},{"location":"architecture/models/#completed-migrations","title":"\u2705 Completed Migrations","text":"<ul> <li>Account-V1: All endpoints migrated to PlatformRegionQuery</li> <li>Match-V5: All endpoints migrated with enhanced filtering parameters</li> </ul>"},{"location":"architecture/models/#pending-migrations","title":"\ud83d\udd04 Pending Migrations","text":"<p>The following endpoints are scheduled for migration to Pydantic models:</p> <ul> <li>SUMMONER-V4 (summonerByName, summonerByPuuid, etc.)</li> <li>LEAGUE-V4 (challengerByQueue, grandmasterByQueue, etc.)</li> <li>CHAMPION-MASTERY-V4 (all mastery endpoints)</li> <li>CHALLENGES-V1 (player challenges)</li> <li>CLASH-V1 (tournament information)</li> <li>SPECTATOR-V5 (live game data)</li> <li>LOL-STATUS-V4 (platform status)</li> <li>CHAMPION-V3 (champion information)</li> </ul>"},{"location":"architecture/models/#benefits","title":"Benefits","text":""},{"location":"architecture/models/#1-type-safety-validation","title":"1. Type Safety &amp; Validation","text":"<pre><code># Before: No validation\nasync def get_summoner(name: str, region: str = \"euw1\"):\n    pass  # Any string accepted, no validation\n\n# After: Comprehensive validation\nasync def get_summoner(\n    params: Annotated[SummonerByNameParams, Depends()],\n    query: Annotated[RegionQuery, Depends()],\n):\n    pass  # Validated summoner name and region\n</code></pre>"},{"location":"architecture/models/#2-automatic-openapi-documentation","title":"2. Automatic OpenAPI Documentation","text":"<p>FastAPI generates detailed API documentation from Pydantic models: - Field types and constraints - Default values and descriptions - Enum values and meanings - Validation rules and error messages</p>"},{"location":"architecture/models/#3-code-reusability","title":"3. Code Reusability","text":"<pre><code># Region query used across multiple endpoints\nclass SummonerByNameQuery(RegionQuery):\n    pass\n\nclass SummonerByPuuidQuery(RegionQuery):\n    pass\n\n# Both inherit region validation automatically\n</code></pre>"},{"location":"architecture/models/#4-easy-extension","title":"4. Easy Extension","text":"<pre><code># Add new optional parameter without breaking changes\nclass MatchIdsByPuuidQuery(PlatformRegionQuery, PaginationQuery):\n    # Future extensions\n    champion: Annotated[Optional[int], Field(\n        default=None,\n        description=\"Filter by champion ID\"\n    )]\n    role: Annotated[Optional[str], Field(\n        default=None,\n        description=\"Filter by role\"\n    )]\n</code></pre>"},{"location":"architecture/models/#error-handling","title":"Error Handling","text":"<p>Pydantic provides detailed validation errors:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"loc\": [\"query\", \"count\"],\n      \"msg\": \"ensure this value is less than or equal to 100\",\n      \"type\": \"value_error.number.not_le\",\n      \"ctx\": {\"limit_value\": 100}\n    }\n  ]\n}\n</code></pre> <p>This validation system ensures API reliability, developer productivity, and excellent user experience through clear error messages and comprehensive API documentation.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>This section provides a comprehensive overview of the LOLStonks API Gateway architecture, its components, and design principles.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":""},{"location":"architecture/overview/#simplified-request-flow","title":"Simplified Request Flow","text":"<pre><code>flowchart LR\n    Client --&gt;|HTTP Request| Gateway[FastAPI Gateway]\n    Gateway --&gt;|Cache Lookup| Redis[Redis Cache]\n    Gateway --&gt;|Rate-Limited Request| Riot[Riot API]\n    Riot --&gt;|Response| Gateway\n    Gateway --&gt;|Store Processed Data| Redis\n</code></pre>"},{"location":"architecture/overview/#detailed-system-architecture","title":"Detailed System Architecture","text":"<pre><code>graph TB\n    Client[Client Applications] --&gt; Gateway[LOLStonks API Gateway]\n    Gateway --&gt; RateLimiter[Rate Limiter]\n    Gateway --&gt; Cache[Redis Cache]\n    Gateway --&gt; RiotAPI[Riot Games API]\n\n    subgraph \"Gateway Components\"\n        Gateway --&gt; FastAPI[FastAPI Application]\n        Gateway --&gt; Routers[API Routers]\n        Gateway --&gt; Client[Riot Client]\n        Gateway --&gt; MatchTracking[Match Tracking]\n    end\n\n    subgraph \"External Services\"\n        Redis[(Redis Server)]\n        Riot[Riot Developer Portal]\n    end\n\n    Cache --&gt; Redis\n    MatchTracking --&gt; Redis\n    Client --&gt; Riot\n    Client -.-&gt; Riot\n</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#1-fastapi-application-appmain","title":"1. FastAPI Application (<code>app.main</code>)","text":"<p>The main entry point that provides: - Async HTTP server with automatic documentation - Request routing to appropriate API endpoints - Middleware for request processing and error handling - OpenAPI specification generation</p> <p>Key Features: - Automatic request/response validation - Interactive API documentation (Swagger UI, ReDoc) - High performance async request handling - Built-in support for CORS, middleware, and dependency injection</p>"},{"location":"architecture/overview/#2-riot-client-appriotclient","title":"2. Riot Client (<code>app.riot.client</code>)","text":"<p>Specialized HTTP client for Riot API communication:</p> <pre><code>class RiotClient:\n    \"\"\"\n    HTTP client for Riot API with rate limiting and retry logic.\n\n    Features:\n    - Automatic rate limiting before requests\n    - Retry on 429 responses with exponential backoff\n    - Region-aware URL routing\n    - Authentication header management\n    \"\"\"\n</code></pre> <p>Responsibilities: - Rate Limiting: Token bucket algorithm for request throttling - Retry Logic: Automatic retry with <code>Retry-After</code> header handling - Region Management: Dynamic URL construction per region - Authentication: Automatic API key injection</p>"},{"location":"architecture/overview/#3-rate-limiter-appriotrate_limiter","title":"3. Rate Limiter (<code>app.riot.rate_limiter</code>)","text":"<p>Implements sophisticated rate limiting using the token bucket algorithm:</p> <pre><code>class RateLimiter:\n    \"\"\"\n    Token bucket rate limiter for Riot API compliance.\n\n    - Configurable requests per second (RPS)\n    - Burst capacity handling\n    - Automatic token refill\n    \"\"\"\n</code></pre> <p>Algorithm: - Tokens: Available request capacity - Refill Rate: Tokens added per second - Burst Capacity: Maximum token accumulation - Wait Strategy: Queue requests when tokens exhausted</p>"},{"location":"architecture/overview/#4-redis-cache-appcacheredis_cache","title":"4. Redis Cache (<code>app.cache.redis_cache</code>)","text":"<p>High-performance caching layer:</p> <pre><code>class RedisCache:\n    \"\"\"\n    Redis-based caching with TTL support.\n\n    - Automatic TTL management\n    - Connection pooling\n    - Error handling and fallbacks\n    \"\"\"\n</code></pre> <p>Cache Strategy: - TTL-based Expiration: Different TTLs per data type - Intelligent Key Generation: Consistent cache key patterns - Connection Pooling: Efficient Redis connection management - Graceful Degradation: Continue operation when cache unavailable</p>"},{"location":"architecture/overview/#5-match-tracking-appcachetracking","title":"5. Match Tracking (<code>app.cache.tracking</code>)","text":"<p>Prevents duplicate match processing:</p> <pre><code>class MatchTracker:\n    \"\"\"\n    Match tracking service to prevent duplicate processing.\n\n    - TTL cache for recent matches\n    - Persistent set for all processed matches\n    - Automatic cleanup of expired entries\n    \"\"\"\n</code></pre> <p>Dual Storage Approach: - TTL Cache: Fast lookup for recent matches (1 week) - Persistent Set: Complete record of all processed matches - Automatic Cleanup: Removal of expired TTL entries</p>"},{"location":"architecture/overview/#api-router-architecture","title":"API Router Architecture","text":""},{"location":"architecture/overview/#router-organization","title":"Router Organization","text":"<pre><code>graph LR\n    Gateway --&gt; Routers\n    Routers --&gt; Summoner[Summoner Router]\n    Routers --&gt; Match[Match Router]\n    Routers --&gt; League[League Router]\n    Routers --&gt; Mastery[Champion Mastery Router]\n    Routers --&gt; Spectator[Spectator Router]\n    Routers --&gt; Account[Account Router]\n    Routers --&gt; Champion[Champion Router]\n    Routers --&gt; Clash[Clash Router]\n    Routers --&gt; Challenges[Challenges Router]\n    Routers --&gt; Platform[Platform Router]\n</code></pre>"},{"location":"architecture/overview/#router-responsibilities","title":"Router Responsibilities","text":"<p>Each router handles: - Path Parameter Validation: Pydantic models for route parameters - Query Parameter Handling: Optional parameters and defaults - Response Transformation: Standardized response format - Error Handling: Consistent error responses - Caching Integration: Automatic cache integration per endpoint</p>"},{"location":"architecture/overview/#example-router-structure","title":"Example Router Structure","text":"<pre><code># app/routers/summoner.py\nrouter = APIRouter(prefix=\"/summoner\", tags=[\"summoner\"])\n\n@router.get(\"/by-name/{summonerName}\")\nasync def get_summoner_by_name(\n    summonerName: str,\n    region: str = Query(default=\"euw1\"),\n    riot_client: RiotClient = Depends(),\n    cache: RedisCache = Depends()\n) -&gt; SummonerDto:\n    \"\"\"Get summoner by summoner name.\"\"\"\n    # Implementation with caching and error handling\n</code></pre>"},{"location":"architecture/overview/#data-flow-architecture","title":"Data Flow Architecture","text":""},{"location":"architecture/overview/#request-processing-flow","title":"Request Processing Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant G as Gateway\n    participant RL as Rate Limiter\n    participant Cache as Redis Cache\n    participant RC as Riot Client\n    participant R as Riot API\n\n    C-&gt;&gt;G: HTTP Request\n    G-&gt;&gt;RL: Check Rate Limit\n    RL--&gt;&gt;G: Rate Limit OK\n    G-&gt;&gt;Cache: Check Cache\n    alt Cache Hit\n        Cache--&gt;&gt;G: Cached Response\n        G--&gt;&gt;C: HTTP Response\n    else Cache Miss\n        G-&gt;&gt;RC: Make API Request\n        RC-&gt;&gt;R: Riot API Call\n        R--&gt;&gt;RC: API Response\n        RC--&gt;&gt;G: Process Response\n        G-&gt;&gt;Cache: Store in Cache\n        G--&gt;&gt;C: HTTP Response\n    end\n</code></pre>"},{"location":"architecture/overview/#caching-strategy","title":"Caching Strategy","text":"<p>Cache Key Pattern: <pre><code>lolstonks:{endpoint}:{region}:{identifier}\n</code></pre></p> <p>TTL Configuration: - Summoner Data: 1 hour (relatively stable) - Match Data: 24 hours (historical data) - League Data: 30 minutes (competitive data) - Champion Data: 1 week (static data)</p>"},{"location":"architecture/overview/#error-handling-flow","title":"Error Handling Flow","text":"<pre><code>graph TD\n    Request[Incoming Request] --&gt; Validation[Request Validation]\n    Validation --&gt; RateCheck[Rate Limit Check]\n    RateCheck --&gt; CacheHit{Cache Hit?}\n\n    CacheHit --&gt;|Yes| CachedResponse[Return Cached Data]\n    CacheHit --&gt;|No| APIRequest[Make Riot API Request]\n\n    APIRequest --&gt; APISuccess{API Success?}\n    APISuccess --&gt;|Yes| StoreCache[Store in Cache]\n    APISuccess --&gt;|No| APIError{Error Type?}\n\n    APIError --&gt;|429| RetryWithBackoff[Retry with Exponential Backoff]\n    APIError --&gt;|404| NotFound[Return 404]\n    APIError --&gt;|Other| ServerError[Return 500]\n\n    RetryWithBackoff --&gt; APISuccess\n    StoreCache --&gt; SuccessResponse[Return Success Response]\n    NotFound --&gt; ErrorResponse[Return Error Response]\n    ServerError --&gt; ErrorResponse\n</code></pre>"},{"location":"architecture/overview/#configuration-architecture","title":"Configuration Architecture","text":""},{"location":"architecture/overview/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<ol> <li>Environment Variables: Primary configuration source</li> <li><code>.env</code> File: Local development configuration</li> <li>Defaults: Built-in fallback values</li> <li>Runtime: Dynamic configuration updates</li> </ol>"},{"location":"architecture/overview/#configuration-management","title":"Configuration Management","text":"<pre><code># app/config.py\nclass Settings(BaseSettings):\n    \"\"\"Configuration settings with environment variable support.\"\"\"\n\n    # Riot API Configuration\n    riot_api_key: str\n    riot_default_region: str = \"euw1\"\n\n    # Server Configuration\n    host: str = \"0.0.0.0\"\n    port: int = 8080\n    log_level: str = \"INFO\"\n\n    # Redis Configuration\n    redis_host: str = \"localhost\"\n    redis_port: int = 6379\n\n    class Config:\n        env_file = \".env\"\n        case_sensitive = False\n</code></pre>"},{"location":"architecture/overview/#performance-architecture","title":"Performance Architecture","text":""},{"location":"architecture/overview/#performance-optimizations","title":"Performance Optimizations","text":"<ol> <li>Async Processing: Non-blocking I/O throughout the stack</li> <li>Connection Pooling: Efficient database and HTTP connections</li> <li>Intelligent Caching: Multi-layer caching strategy</li> <li>Rate Limiting: Protects against API abuse and ensures compliance</li> <li>Batch Operations: Support for concurrent requests</li> </ol>"},{"location":"architecture/overview/#scalability-considerations","title":"Scalability Considerations","text":"<ul> <li>Horizontal Scaling: Stateless design allows multiple instances</li> <li>Redis Cluster: Support for distributed caching</li> <li>Load Balancing: Compatible with standard load balancers</li> <li>Monitoring: Built-in health checks and metrics</li> </ul>"},{"location":"architecture/overview/#security-architecture","title":"Security Architecture","text":""},{"location":"architecture/overview/#security-layers","title":"Security Layers","text":"<ol> <li>API Key Management: Secure storage and rotation of Riot API keys</li> <li>Input Validation: Comprehensive request validation using Pydantic</li> <li>Rate Limiting: Protection against abuse and DoS attacks</li> <li>Error Sanitization: Prevents information leakage in error messages</li> <li>CORS Configuration: Configurable cross-origin resource sharing</li> </ol>"},{"location":"architecture/overview/#best-practices","title":"Best Practices","text":"<ul> <li>Principle of Least Privilege: Minimal required permissions</li> <li>Defense in Depth: Multiple security layers</li> <li>Secure Defaults: Secure configuration out of the box</li> <li>Audit Logging: Comprehensive request and error logging</li> </ul>"},{"location":"architecture/overview/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"architecture/overview/#health-checks","title":"Health Checks","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Comprehensive health check endpoint.\"\"\"\n    return {\n        \"status\": \"ok\",\n        \"timestamp\": datetime.utcnow(),\n        \"version\": \"1.0.0\",\n        \"dependencies\": {\n            \"redis\": await check_redis_health(),\n            \"riot_api\": await check_riot_api_health()\n        }\n    }\n</code></pre>"},{"location":"architecture/overview/#logging-strategy","title":"Logging Strategy","text":"<ul> <li>Structured Logging: JSON-formatted logs for easy parsing</li> <li>Request Tracking: Unique request IDs for tracing</li> <li>Performance Metrics: Request timing and cache hit rates</li> <li>Error Tracking: Comprehensive error logging and alerting</li> </ul>"},{"location":"architecture/overview/#future-architecture-considerations","title":"Future Architecture Considerations","text":""},{"location":"architecture/overview/#planned-enhancements","title":"Planned Enhancements","text":"<ol> <li>Metrics Collection: Prometheus metrics integration</li> <li>Distributed Tracing: OpenTelemetry support</li> <li>API Versioning: Versioned API endpoints</li> <li>Webhook Support: Real-time event notifications</li> <li>Admin Interface: Management dashboard for operations</li> </ol>"},{"location":"architecture/overview/#scalability-roadmap","title":"Scalability Roadmap","text":"<ul> <li>Multi-Region Deployment: Geographic distribution</li> <li>Circuit Breakers: Fault tolerance for external dependencies</li> <li>Event Streaming: Kafka/Redis Streams for real-time data</li> <li>GraphQL Support: Alternative API interface</li> </ul>"},{"location":"architecture/overview/#design-principles","title":"Design Principles","text":"<p>The LOLStonks API Gateway follows these design principles:</p> <ol> <li>Performance First: Optimized for high throughput and low latency</li> <li>Developer Experience: Clear APIs and comprehensive documentation</li> <li>Reliability: Graceful degradation and error handling</li> <li>Observability: Built-in monitoring and debugging capabilities</li> <li>Security: Secure by design with defense in depth</li> <li>Scalability: Designed to scale horizontally and vertically</li> </ol>"},{"location":"architecture/overview/#production-deployment","title":"Production Deployment","text":""},{"location":"architecture/overview/#deployment-architecture","title":"Deployment Architecture","text":"<p>For production deployments, the API Gateway should be run behind a reverse proxy with proper process management:</p> <pre><code>graph TB\n    Internet[Internet] --&gt; LB[Load Balancer/Nginx]\n    LB --&gt; Gateway1[API Gateway Instance 1]\n    LB --&gt; Gateway2[API Gateway Instance 2]\n    LB --&gt; GatewayN[API Gateway Instance N]\n\n    Gateway1 --&gt; Redis[Redis Cluster]\n    Gateway2 --&gt; Redis\n    GatewayN --&gt; Redis\n\n    Gateway1 --&gt; Riot[Riot API]\n    Gateway2 --&gt; Riot\n    GatewayN --&gt; Riot\n\n    subgraph \"Monitoring\"\n        Prometheus[Prometheus]\n        Grafana[Grafana]\n        Alerts[Alert Manager]\n    end\n\n    Gateway1 --&gt; Prometheus\n    Gateway2 --&gt; Prometheus\n    GatewayN --&gt; Prometheus\n    Prometheus --&gt; Grafana\n    Prometheus --&gt; Alerts\n</code></pre>"},{"location":"architecture/overview/#production-requirements","title":"Production Requirements","text":"<ol> <li>Process Management: Use systemd, supervisor, or similar process manager</li> <li>Reverse Proxy: Nginx or similar for SSL termination and load balancing</li> <li>Environment Variables: Secure configuration management for API keys</li> <li>Monitoring: Health checks, metrics collection, and alerting</li> <li>Logging: Centralized log aggregation and analysis</li> <li>Security: Firewall, rate limiting, and access controls</li> </ol>"},{"location":"architecture/overview/#scaling-considerations","title":"Scaling Considerations","text":"<ul> <li>Horizontal Scaling: Stateless design enables multiple instances</li> <li>Redis Cluster: Distributed caching for high availability</li> <li>Database Connection Pooling: Efficient resource utilization</li> <li>Circuit Breakers: Fault tolerance for external dependencies</li> </ul> <p>This architecture provides a solid foundation for a production-ready API Gateway that can handle high traffic while maintaining reliability and performance.</p>"},{"location":"architecture/rate-limiting/","title":"Rate Limiting Architecture","text":"<p>This section details the rate limiting implementation in the LOLStonks API Gateway, designed to ensure compliance with Riot Games API rate limits while providing optimal performance.</p>"},{"location":"architecture/rate-limiting/#overview","title":"Overview","text":"<p>The rate limiting system uses a token bucket algorithm to control the flow of requests to the Riot Games API, preventing rate limit violations and ensuring fair usage.</p>"},{"location":"architecture/rate-limiting/#token-bucket-algorithm","title":"Token Bucket Algorithm","text":""},{"location":"architecture/rate-limiting/#algorithm-description","title":"Algorithm Description","text":"<p>The token bucket algorithm works as follows:</p> <ol> <li>Bucket Capacity: Maximum number of tokens that can be stored</li> <li>Refill Rate: Number of tokens added per second</li> <li>Token Consumption: Each request consumes one token</li> <li>Wait Strategy: Requests wait when tokens are unavailable</li> </ol> <pre><code>graph TD\n    Bucket[Token Bucket] --&gt; Refill[Refill: 20 tokens/sec]\n    Bucket --&gt; Capacity[Max Capacity: 100 tokens]\n\n    Request1[Request 1] --&gt; Consume1[Consume 1 token]\n    Request2[Request 2] --&gt; Consume2[Consume 1 token]\n    Request3[Request 3] --&gt; Consume3[Consume 1 token]\n\n    Consume1 --&gt; Available{Tokens Available?}\n    Consume2 --&gt; Available\n    Consume3 --&gt; Available\n\n    Available --&gt;|Yes| Process[Process Request]\n    Available --&gt;|No| Wait[Wait for Refill]\n\n    Wait --&gt; Available\n    Process --&gt; Bucket\n</code></pre>"},{"location":"architecture/rate-limiting/#implementation-details","title":"Implementation Details","text":"<pre><code># app/riot/rate_limiter.py\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nclass RateLimiter:\n    \"\"\"\n    Token bucket rate limiter for Riot API compliance.\n\n    Default configuration:\n    - 20 requests per second\n    - 100 token burst capacity\n    - 120-second refill period for burst capacity\n    \"\"\"\n\n    def __init__(self, rate: float = 20.0, capacity: int = 100):\n        self.rate = rate  # tokens per second\n        self.capacity = capacity  # maximum tokens\n        self.tokens = capacity  # current tokens\n        self.last_refill = datetime.utcnow()\n        self._lock = asyncio.Lock()\n\n    async def acquire(self) -&gt; None:\n        \"\"\"Acquire a token, waiting if necessary.\"\"\"\n        async with self._lock:\n            await self._refill()\n            if self.tokens &gt;= 1:\n                self.tokens -= 1\n                return\n\n            # Calculate wait time for next token\n            wait_time = 1.0 / self.rate\n            await asyncio.sleep(wait_time)\n            await self._refill()\n            self.tokens -= 1\n\n    async def _refill(self) -&gt; None:\n        \"\"\"Refill tokens based on elapsed time.\"\"\"\n        now = datetime.utcnow()\n        elapsed = (now - self.last_refill).total_seconds()\n        tokens_to_add = elapsed * self.rate\n\n        self.tokens = min(self.capacity, self.tokens + tokens_to_add)\n        self.last_refill = now\n</code></pre>"},{"location":"architecture/rate-limiting/#configuration","title":"Configuration","text":""},{"location":"architecture/rate-limiting/#environment-variables","title":"Environment Variables","text":"<pre><code># Rate limiting configuration\nRATE_LIMIT_RPS=20           # Requests per second\nRATE_LIMIT_BURST=100        # Burst capacity\nRATE_LIMIT_PERIOD=120       # Period for burst refill (seconds)\n</code></pre>"},{"location":"architecture/rate-limiting/#custom-rate-limits","title":"Custom Rate Limits","text":"<p>You can configure different rate limits for different endpoint types:</p> <pre><code># Custom rate limits per endpoint type\nRATE_LIMITS = {\n    \"summoner\": {\"rps\": 30, \"burst\": 150},    # Higher limit for summoner data\n    \"match\": {\"rps\": 10, \"burst\": 50},        # Lower limit for match data\n    \"league\": {\"rps\": 20, \"burst\": 100},      # Standard limit for league data\n    \"spectator\": {\"rps\": 5, \"burst\": 25}      # Very low limit for spectator\n}\n</code></pre>"},{"location":"architecture/rate-limiting/#integration-with-http-client","title":"Integration with HTTP Client","text":""},{"location":"architecture/rate-limiting/#rate-limited-http-client","title":"Rate-Limited HTTP Client","text":"<pre><code># app/riot/client.py\nimport httpx\nfrom app.riot.rate_limiter import RateLimiter\n\nclass RiotClient:\n    \"\"\"\n    HTTP client for Riot API with integrated rate limiting.\n    \"\"\"\n\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.client = httpx.AsyncClient()\n        self.rate_limiter = RateLimiter(\n            rate=float(os.getenv(\"RATE_LIMIT_RPS\", 20)),\n            capacity=int(os.getenv(\"RATE_LIMIT_BURST\", 100))\n        )\n\n    async def get(self, path: str, region: str, **kwargs) -&gt; dict:\n        \"\"\"\n        Make GET request with automatic rate limiting and retry.\n        \"\"\"\n        await self.rate_limiter.acquire()\n\n        # Make request\n        response = await self.client.get(\n            self._build_url(path, region),\n            headers=self._get_headers(),\n            **kwargs\n        )\n\n        # Handle rate limiting from Riot API\n        if response.status_code == 429:\n            retry_after = int(response.headers.get(\"Retry-After\", 1))\n            await asyncio.sleep(retry_after)\n            return await self.get(path, region, **kwargs)  # Retry\n\n        response.raise_for_status()\n        return response.json()\n</code></pre>"},{"location":"architecture/rate-limiting/#rate-limit-response-handling","title":"Rate Limit Response Handling","text":""},{"location":"architecture/rate-limiting/#429-response-handling","title":"429 Response Handling","text":"<p>When Riot API returns a 429 (Too Many Requests) response:</p> <pre><code>async def _handle_rate_limit_response(self, response: httpx.Response) -&gt; dict:\n    \"\"\"\n    Handle 429 responses from Riot API.\n\n    Riot API provides:\n    - Retry-After header: Seconds to wait before retrying\n    - X-Rate-Limit-* headers: Current rate limit status\n    \"\"\"\n    if response.status_code != 429:\n        response.raise_for_status()\n        return response.json()\n\n    # Extract retry information\n    retry_after = int(response.headers.get(\"Retry-After\", 1))\n    app_rate_limit = response.headers.get(\"X-App-Rate-Limit\", \"\")\n    app_rate_count = response.headers.get(\"X-App-Rate-Limit-Count\", \"\")\n\n    # Log rate limit information\n    logger.warning(\n        f\"Rate limited. Retry after {retry_after}s. \"\n        f\"App limit: {app_rate_count}/{app_rate_limit}\"\n    )\n\n    # Wait for the specified time\n    await asyncio.sleep(retry_after)\n\n    # The request will be retried by the calling method\n    raise RateLimitExceeded(retry_after=retry_after)\n</code></pre>"},{"location":"architecture/rate-limiting/#rate-limit-headers-monitoring","title":"Rate Limit Headers Monitoring","text":"<pre><code>def _monitor_rate_limits(self, response: httpx.Response) -&gt; None:\n    \"\"\"\n    Monitor rate limit headers for proactive management.\n\n    Riot API headers:\n    - X-App-Rate-Limit: application limits (e.g., \"20:1,100:120\")\n    - X-App-Rate-Limit-Count: current usage (e.g., \"5:1,17:120\")\n    - X-Method-Rate-Limit: method-specific limits\n    - X-Method-Rate-Limit-Count: current method usage\n    \"\"\"\n    app_limit = response.headers.get(\"X-App-Rate-Limit\", \"\")\n    app_count = response.headers.get(\"X-App-Rate-Limit-Count\", \"\")\n\n    if app_limit and app_count:\n        # Parse rate limit information\n        limits = self._parse_rate_limit_header(app_limit)\n        counts = self._parse_rate_limit_header(app_count)\n\n        # Check if we're approaching limits\n        for (limit_period, limit_count), (_, current_count) in zip(limits, counts):\n            usage_percentage = (current_count / limit_count) * 100\n\n            if usage_percentage &gt; 80:\n                logger.warning(\n                    f\"Approaching rate limit: {current_count}/{limit_count} \"\n                    f\"({usage_percentage:.1f}%) for {limit_period}s period\"\n                )\n</code></pre>"},{"location":"architecture/rate-limiting/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/rate-limiting/#rate-limiter-performance","title":"Rate Limiter Performance","text":"<pre><code># Optimized rate limiter with minimal blocking\nclass HighPerformanceRateLimiter:\n    \"\"\"\n    High-performance rate limiter using async primitives.\n    \"\"\"\n\n    def __init__(self, rate: float, capacity: int):\n        self.rate = rate\n        self.capacity = capacity\n        self.tokens = capacity\n        self.last_refill = time.time()\n        self._lock = asyncio.Lock()\n        self._not_empty = asyncio.Condition(self._lock)\n\n    async def acquire(self) -&gt; None:\n        \"\"\"Acquire token with efficient waiting.\"\"\"\n        async with self._not_empty:\n            while self.tokens &lt; 1:\n                # Calculate wait time more precisely\n                now = time.time()\n                time_since_refill = now - self.last_refill\n                tokens_needed = 1 - self.tokens\n                wait_time = max(0, tokens_needed / self.rate - time_since_refill)\n\n                if wait_time &gt; 0:\n                    await asyncio.sleep(wait_time)\n                else:\n                    await self._refill()\n\n            self.tokens -= 1\n            self._not_empty.notify()\n</code></pre>"},{"location":"architecture/rate-limiting/#connection-pooling-with-rate-limiting","title":"Connection Pooling with Rate Limiting","text":"<pre><code># HTTP client configuration optimized for rate limiting\nclass OptimizedRiotClient:\n    def __init__(self, api_key: str):\n        self.client = httpx.AsyncClient(\n            limits=httpx.Limits(\n                max_keepalive_connections=20,\n                max_connections=100,\n                keepalive_expiry=30.0\n            ),\n            timeout=httpx.Timeout(30.0, connect=5.0)\n        )\n        self.rate_limiter = RateLimiter(rate=20, capacity=100)\n</code></pre>"},{"location":"architecture/rate-limiting/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"architecture/rate-limiting/#rate-limit-metrics","title":"Rate Limit Metrics","text":"<pre><code># Metrics collection for rate limiting\nclass RateLimitMetrics:\n    \"\"\"\n    Collect and report rate limiting metrics.\n    \"\"\"\n\n    def __init__(self):\n        self.requests_total = 0\n        self.requests_limited = 0\n        self.wait_time_total = 0.0\n        self.tokens_consumed = 0\n\n    def record_request(self, wait_time: float, was_limited: bool = False) -&gt; None:\n        \"\"\"Record a request with its wait time.\"\"\"\n        self.requests_total += 1\n        self.wait_time_total += wait_time\n        if was_limited:\n            self.requests_limited += 1\n        self.tokens_consumed += 1\n\n    def get_metrics(self) -&gt; dict:\n        \"\"\"Get current metrics.\"\"\"\n        return {\n            \"requests_total\": self.requests_total,\n            \"requests_limited\": self.requests_limited,\n            \"limit_rate\": self.requests_limited / self.requests_total * 100,\n            \"average_wait_time\": self.wait_time_total / self.requests_total,\n            \"tokens_consumed\": self.tokens_consumed\n        }\n</code></pre>"},{"location":"architecture/rate-limiting/#health-check-integration","title":"Health Check Integration","text":"<pre><code>@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check including rate limiting status.\"\"\"\n    rate_limiter_metrics = riot_client.rate_limiter.get_metrics()\n\n    return {\n        \"status\": \"ok\",\n        \"rate_limiting\": {\n            \"status\": \"healthy\",\n            \"current_tokens\": rate_limiter_metrics[\"current_tokens\"],\n            \"requests_per_second\": rate_limiter_metrics[\"current_rate\"],\n            \"limit_rate\": rate_limiter_metrics[\"limit_rate_percentage\"]\n        }\n    }\n</code></pre>"},{"location":"architecture/rate-limiting/#advanced-features","title":"Advanced Features","text":""},{"location":"architecture/rate-limiting/#adaptive-rate-limiting","title":"Adaptive Rate Limiting","text":"<pre><code>class AdaptiveRateLimiter(RateLimiter):\n    \"\"\"\n    Rate limiter that adapts based on Riot API responses.\n    \"\"\"\n\n    def __init__(self, initial_rate: float, initial_capacity: int):\n        super().__init__(initial_rate, initial_capacity)\n        self.adaptive_mode = True\n        self.consecutive_429s = 0\n        self.last_adjustment = time.time()\n\n    async def adapt_after_429(self, retry_after: int) -&gt; None:\n        \"\"\"Adjust rate limits after receiving 429 response.\"\"\"\n        self.consecutive_429s += 1\n\n        if self.consecutive_429s &gt;= 3:\n            # Reduce rate limit if we get multiple 429s\n            new_rate = max(1, self.rate * 0.8)\n            self.rate = new_rate\n            logger.warning(f\"Reduced rate limit to {new_rate} RPS due to 429s\")\n\n    async def adapt_success(self) -&gt; None:\n        \"\"\"Gradually increase rate limit on success.\"\"\"\n        if self.consecutive_429s == 0 and time.time() - self.last_adjustment &gt; 300:\n            # Gradually increase if no recent 429s\n            self.rate = min(30, self.rate * 1.1)\n            self.last_adjustment = time.time()\n</code></pre>"},{"location":"architecture/rate-limiting/#distributed-rate-limiting","title":"Distributed Rate Limiting","text":"<p>For multi-instance deployments:</p> <pre><code>class DistributedRateLimiter:\n    \"\"\"\n    Rate limiter using Redis for distributed coordination.\n    \"\"\"\n\n    def __init__(self, redis_client, rate: float, capacity: int):\n        self.redis = redis_client\n        self.rate = rate\n        self.capacity = capacity\n        self.key = \"rate_limiter:tokens\"\n\n    async def acquire(self) -&gt; None:\n        \"\"\"Acquire token using Redis-based rate limiting.\"\"\"\n        script = \"\"\"\n        local key = KEYS[1]\n        local capacity = tonumber(ARGV[1])\n        local tokens = tonumber(ARGV[2])\n        local interval = tonumber(ARGV[3])\n\n        local current = redis.call('GET', key)\n        if not current then\n            current = capacity\n        else\n            current = tonumber(current)\n        end\n\n        if current &gt;= 1 then\n            redis.call('SET', key, current - 1)\n            redis.call('EXPIRE', key, interval)\n            return 1\n        else\n            return 0\n        end\n        \"\"\"\n\n        result = await self.redis.eval(\n            script,\n            keys=[self.key],\n            args=[self.capacity, 1, self.capacity / self.rate]\n        )\n\n        if result == 0:\n            # No tokens available, wait\n            await asyncio.sleep(1.0 / self.rate)\n            await self.acquire()\n</code></pre>"},{"location":"architecture/rate-limiting/#best-practices","title":"Best Practices","text":""},{"location":"architecture/rate-limiting/#configuration-guidelines","title":"Configuration Guidelines","text":"<ol> <li>Conservative Rate Limits: Start with conservative limits and adjust based on usage</li> <li>Monitor Usage: Regularly monitor rate limit headers and adjust accordingly</li> <li>Graceful Degradation: Handle rate limit errors gracefully without failing completely</li> <li>Burst Capacity: Maintain adequate burst capacity for traffic spikes</li> </ol>"},{"location":"architecture/rate-limiting/#error-handling","title":"Error Handling","text":"<ol> <li>Exponential Backoff: Use exponential backoff for retries</li> <li>Circuit Breaker: Implement circuit breaker for repeated failures</li> <li>Logging: Comprehensive logging of rate limit events</li> <li>Alerting: Set up alerts for high rate limit usage</li> </ol>"},{"location":"architecture/rate-limiting/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Async Operations: Use async/await throughout the stack</li> <li>Connection Pooling: Reuse HTTP connections efficiently</li> <li>Batch Operations: Batch requests when possible</li> <li>Caching: Cache responses to reduce API calls</li> </ol> <p>The rate limiting system ensures reliable operation while respecting Riot Games API limits, providing a robust foundation for high-volume API access.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to LOLStonks API Gateway! This guide will help you get started with contributing to the project.</p>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to be respectful, inclusive, and constructive in all interactions. We expect contributors to:</p> <ul> <li>Be respectful of differing viewpoints and experiences</li> <li>Accept constructive criticism gracefully</li> <li>Focus on what is best for the community</li> <li>Show empathy towards other community members</li> </ul>"},{"location":"development/contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are many ways to contribute to this project:</p> <ul> <li>Report bugs: Submit detailed bug reports with reproduction steps</li> <li>Suggest features: Propose new features or enhancements</li> <li>Improve documentation: Fix typos, clarify instructions, or add examples</li> <li>Submit code: Fix bugs or implement new features</li> <li>Review pull requests: Help review and test other contributors' code</li> </ul>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#development-environment-setup","title":"Development Environment Setup","text":"<ol> <li>Fork and clone the repository:</li> </ol> <pre><code>git clone https://github.com/YOUR_USERNAME/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code># Using UV (recommended)\nuv pip install -e \".[dev,docs]\"\n\n# Or using pip\npip install -e \".[dev,docs]\"\n</code></pre> <ol> <li>Set up environment variables:</li> </ol> <pre><code>cp .env.example .env\n# Edit .env and add your Riot API key\n</code></pre> <ol> <li>Start Redis (required for development):</li> </ol> <pre><code># Using Docker\ndocker-compose up -d redis\n\n# Or install Redis locally\n</code></pre> <ol> <li>Run the development server:</li> </ol> <pre><code>python -m app.main\n</code></pre>"},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>lolstonks-api-gateway/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 main.py              # Application entry point\n\u2502   \u251c\u2500\u2500 config.py            # Configuration management\n\u2502   \u251c\u2500\u2500 routers/             # API endpoint routers\n\u2502   \u251c\u2500\u2500 riot/                # Riot API client and rate limiting\n\u2502   \u251c\u2500\u2500 cache/               # Caching and match tracking\n\u2502   \u2514\u2500\u2500 models/              # Data models\n\u251c\u2500\u2500 docs/                    # Documentation source\n\u251c\u2500\u2500 tests/                   # Test suite\n\u2514\u2500\u2500 scripts/                 # Utility scripts\n</code></pre>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<p>Create a feature branch from <code>main</code> or <code>develop</code>:</p> <pre><code>git checkout -b feat/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre> <p>Branch naming conventions: - <code>feat/</code> - New features - <code>fix/</code> - Bug fixes - <code>docs/</code> - Documentation changes - <code>refactor/</code> - Code refactoring - <code>test/</code> - Test additions or modifications - <code>chore/</code> - Maintenance tasks</p>"},{"location":"development/contributing/#2-make-your-changes","title":"2. Make Your Changes","text":"<ul> <li>Follow the existing code style and patterns</li> <li>Write clear, concise commit messages</li> <li>Keep changes focused and atomic</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> </ul>"},{"location":"development/contributing/#3-test-your-changes","title":"3. Test Your Changes","text":"<p>Before submitting, ensure your changes pass all checks:</p> <pre><code># Run tests (when available)\npytest\n\n# Run type checking (if configured)\nmypy app\n\n# Run linting (if configured)\nruff check app\n</code></pre>"},{"location":"development/contributing/#4-commit-your-changes","title":"4. Commit Your Changes","text":"<p>Write clear commit messages following this format:</p> <pre><code>git commit -m \"feat: add support for new Riot API endpoint\"\ngit commit -m \"fix: resolve rate limiting issue with burst requests\"\ngit commit -m \"docs: update installation instructions\"\n</code></pre> <p>Commit message format: - Use present tense (\"add feature\" not \"added feature\") - Use imperative mood (\"move cursor to...\" not \"moves cursor to...\") - Limit first line to 72 characters - Reference issues and pull requests when relevant</p>"},{"location":"development/contributing/#5-push-and-create-pull-request","title":"5. Push and Create Pull Request","text":"<pre><code>git push origin feat/your-feature-name\n</code></pre> <p>Then open a pull request on GitHub with:</p> <ul> <li>Clear title describing the change</li> <li>Detailed description of what changed and why</li> <li>Reference to any related issues</li> <li>Screenshots or examples if applicable</li> </ul>"},{"location":"development/contributing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<ul> <li>Follow PEP 8 guidelines</li> <li>Use type hints for function parameters and return values</li> <li>Write docstrings for all public functions and classes</li> <li>Keep functions focused and single-purpose</li> <li>Use meaningful variable and function names</li> </ul> <p>Example:</p> <pre><code>from typing import Optional\n\nasync def get_summoner_by_name(\n    summoner_name: str,\n    region: str = \"euw1\"\n) -&gt; Optional[dict]:\n    \"\"\"\n    Retrieve summoner information by name.\n\n    Args:\n        summoner_name: The summoner's in-game name\n        region: The game region (default: euw1)\n\n    Returns:\n        Summoner data dictionary or None if not found\n    \"\"\"\n    # Implementation here\n    pass\n</code></pre>"},{"location":"development/contributing/#documentation-style","title":"Documentation Style","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples for complex features</li> <li>Keep line length reasonable (80-100 characters)</li> <li>Use proper markdown formatting</li> <li>Avoid jargon and explain technical terms</li> </ul>"},{"location":"development/contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"development/contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Write tests for all new functionality</li> <li>Ensure tests are isolated and reproducible</li> <li>Use descriptive test names</li> <li>Test both success and failure cases</li> <li>Mock external API calls</li> </ul> <p>Example test structure:</p> <pre><code>import pytest\nfrom app.riot.client import RiotClient\n\n@pytest.mark.asyncio\nasync def test_get_summoner_by_name_success():\n    \"\"\"Test successful summoner retrieval.\"\"\"\n    client = RiotClient(api_key=\"test-key\")\n    # Test implementation\n    pass\n\n@pytest.mark.asyncio\nasync def test_get_summoner_by_name_not_found():\n    \"\"\"Test summoner not found scenario.\"\"\"\n    # Test implementation\n    pass\n</code></pre>"},{"location":"development/contributing/#documentation-guidelines","title":"Documentation Guidelines","text":""},{"location":"development/contributing/#updating-documentation","title":"Updating Documentation","text":"<p>When making changes that affect documentation:</p> <ol> <li>Update relevant <code>.md</code> files in the <code>docs/</code> directory</li> <li>Test documentation locally:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <ol> <li>Ensure all links work correctly</li> <li>Add code examples for new features</li> <li>Update API reference if endpoints change</li> </ol>"},{"location":"development/contributing/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Getting Started: Installation and quick start guides</li> <li>API Reference: Endpoint documentation</li> <li>Architecture: System design and component documentation</li> <li>Development: Contributing and development guides</li> <li>Operations: Deployment and maintenance guides</li> </ul>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Before submitting:</li> <li>Ensure all tests pass</li> <li>Update documentation</li> <li>Rebase on latest main/develop</li> <li> <p>Resolve any merge conflicts</p> </li> <li> <p>PR requirements:</p> </li> <li>Clear description of changes</li> <li>Link to related issue (if applicable)</li> <li>Tests pass and coverage maintained</li> <li>Documentation updated</li> <li> <p>Code reviewed by at least one maintainer</p> </li> <li> <p>After submission:</p> </li> <li>Respond to review comments</li> <li>Make requested changes</li> <li>Keep PR updated with main branch</li> <li>Be patient and respectful</li> </ol>"},{"location":"development/contributing/#issue-reporting","title":"Issue Reporting","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, include:</p> <ul> <li>Clear, descriptive title</li> <li>Steps to reproduce</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Environment details (OS, Python version, etc.)</li> <li>Error messages and stack traces</li> <li>Relevant logs</li> </ul> <p>Example:</p> <pre><code>## Bug Description\nRate limiter fails under high concurrent load\n\n## Steps to Reproduce\n1. Start gateway with default configuration\n2. Send 100 concurrent requests\n3. Observe rate limit errors\n\n## Expected Behavior\nAll requests should be properly rate limited\n\n## Actual Behavior\nSome requests bypass rate limiter\n\n## Environment\n- Python: 3.12.0\n- OS: Ubuntu 22.04\n- Redis: 7.0.5\n</code></pre>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>When suggesting features, include:</p> <ul> <li>Clear description of the feature</li> <li>Use case and motivation</li> <li>Proposed implementation (optional)</li> <li>Potential impact on existing functionality</li> </ul>"},{"location":"development/contributing/#contributor-license-agreement","title":"Contributor License Agreement","text":"<p>By contributing to this repository, you agree that:</p> <ul> <li>Your contributions will be licensed under the MIT License</li> <li>You have the right to contribute the code/documentation</li> <li>You understand your contributions may be modified or rejected</li> </ul>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<p>If you need help with contributing:</p> <ul> <li>Check existing documentation</li> <li>Search existing issues and pull requests</li> <li>Open a discussion on GitHub</li> <li>Ask questions in pull request comments</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>All contributors will be recognized in the project. Significant contributions may be highlighted in release notes.</p>"},{"location":"development/contributing/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub Flow Guide</li> <li>Writing Good Commit Messages</li> <li>Python Type Hints</li> <li>FastAPI Documentation</li> </ul> <p>Thank you for contributing to LOLStonks API Gateway!</p>"},{"location":"development/documentation/","title":"Documentation Guide","text":"<p>This guide explains how to contribute to and maintain the documentation for the LOLStonks API Gateway.</p>"},{"location":"development/documentation/#documentation-system-overview","title":"Documentation System Overview","text":"<p>The project uses MkDocs with the mkdocstrings plugin to generate documentation directly from Python docstrings. This ensures that the documentation stays in sync with the codebase.</p>"},{"location":"development/documentation/#documentation-stack","title":"Documentation Stack","text":"<ul> <li>MkDocs: Static site generator</li> <li>mkdocstrings: Automatic API documentation from docstrings</li> <li>Material for MkDocs: Modern documentation theme</li> <li>Markdown: Source format for all documentation</li> </ul>"},{"location":"development/documentation/#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md                   # Homepage and project overview\n\u251c\u2500\u2500 getting-started/           # User guides\n\u2502   \u251c\u2500\u2500 installation.md\n\u2502   \u251c\u2500\u2500 quick-start.md\n\u2502   \u2514\u2500\u2500 configuration.md\n\u251c\u2500\u2500 api/                       # API reference (auto-generated)\n\u2502   \u251c\u2500\u2500 overview.md\n\u2502   \u251c\u2500\u2500 riot-client.md\n\u2502   \u251c\u2500\u2500 models.md\n\u2502   \u251c\u2500\u2500 routers.md\n\u2502   \u2514\u2500\u2500 cache.md\n\u251c\u2500\u2500 architecture/              # Architecture documentation\n\u2502   \u251c\u2500\u2500 overview.md\n\u2502   \u251c\u2500\u2500 rate-limiting.md\n\u2502   \u2514\u2500\u2500 caching.md\n\u251c\u2500\u2500 development/               # Developer documentation\n\u2502   \u251c\u2500\u2500 contributing.md\n\u2502   \u251c\u2500\u2500 testing.md\n\u2502   \u2514\u2500\u2500 documentation.md\n\u251c\u2500\u2500 legacy/                    # Legacy documentation\n\u2502   \u251c\u2500\u2500 api.md\n\u2502   \u251c\u2500\u2500 setup.md\n\u2502   \u2514\u2500\u2500 architecture.md\n\u2514\u2500\u2500 data/                      # Generated data files\n    \u2514\u2500\u2500 openapi.json\n</code></pre>"},{"location":"development/documentation/#writing-documentation","title":"Writing Documentation","text":""},{"location":"development/documentation/#markdown-guidelines","title":"Markdown Guidelines","text":""},{"location":"development/documentation/#headers","title":"Headers","text":"<pre><code># Level 1 Header (Page Title)\n## Level 2 Header\n### Level 3 Header\n#### Level 4 Header\n</code></pre>"},{"location":"development/documentation/#code-blocks","title":"Code Blocks","text":"<pre><code># Inline code\nUse `inline code` for short code snippets.\n\n# Fenced code blocks\n```python\ndef example_function():\n    \"\"\"Example function with docstring.\"\"\"\n    return \"Hello, World!\"\n</code></pre>"},{"location":"development/documentation/#code-blocks-with-syntax-highlighting","title":"Code blocks with syntax highlighting","text":"<p><pre><code>def api_request():\n    \"\"\"Make API request with error handling.\"\"\"\n    try:\n        response = await client.get(\"/api/endpoint\")\n        return response.json()\n    except httpx.HTTPError as e:\n        logger.error(f\"API error: {e}\")\n        return None\n</code></pre> <pre><code>#### Lists\n\n```markdown\n# Unordered list\n- Item 1\n- Item 2\n  - Nested item\n  - Another nested item\n\n# Ordered list\n1. First step\n2. Second step\n   1. Sub-step 2.1\n   2. Sub-step 2.2\n3. Third step\n</code></pre></p>"},{"location":"development/documentation/#tables","title":"Tables","text":"<pre><code>| Parameter | Type | Description | Required |\n|-----------|------|-------------|----------|\n| region | str | Riot API region | Yes |\n| count | int | Number of results | No |\n| start | int | Starting index | No |\n</code></pre>"},{"location":"development/documentation/#admonitions","title":"Admonitions","text":"<pre><code>!!! note \"Note Title\"\n    This is a note admonition.\n\n!!! tip \"Tip\"\n    This is a tip for users.\n\n!!! warning \"Warning\"\n    This is a warning message.\n\n!!! danger \"Danger\"\n    This indicates a dangerous action.\n</code></pre>"},{"location":"development/documentation/#links","title":"Links","text":"<pre><code># Internal links\n[Link to installation guide](getting-started/installation.md)\n\n# External links\n[Riot Developer Portal](https://developer.riotgames.com/)\n\n# Reference links\n[API Reference][api-reference]\n\n[api-reference]: api/overview.md\n</code></pre>"},{"location":"development/documentation/#docstring-standards","title":"Docstring Standards","text":""},{"location":"development/documentation/#google-style-docstrings","title":"Google Style Docstrings","text":"<p>The project uses Google Style docstrings for consistency and mkdocstrings compatibility.</p>"},{"location":"development/documentation/#functionmethod-docstrings","title":"Function/Method Docstrings","text":"<pre><code>async def get_summoner_by_name(\n    summonerName: str,\n    region: str = \"euw1\",\n    riot_client: RiotClient = Depends(),\n    cache: RedisCache = Depends()\n) -&gt; SummonerDto:\n    \"\"\"\n    Get summoner information by summoner name.\n\n    Retrieves comprehensive summoner data including profile information,\n    level, and account details from the Riot API.\n\n    Args:\n        summonerName: The summoner name to search for (case-insensitive)\n        region: Riot API region code (default: \"euw1\")\n        riot_client: Dependency-injected Riot API client\n        cache: Dependency-injected Redis cache instance\n\n    Returns:\n        SummonerDto: Summoner information including:\n            - id: Summoner ID\n            - accountId: Account ID\n            - puuid: Player UUID\n            - name: Summoner name\n            - profileIconId: Profile icon ID\n            - summonerLevel: Summoner level\n            - revisionDate: Last data revision timestamp\n\n    Raises:\n        ValueError: If summonerName is empty or invalid\n        httpx.HTTPStatusError: If Riot API returns an error\n        CacheError: If cache operations fail\n\n    Example:\n        &gt;&gt;&gt; summoner = await get_summoner_by_name(\"Faker\", \"kr\")\n        &gt;&gt;&gt; print(f\"Summoner: {summoner['name']} (Level {summoner['summonerLevel']})\")\n        Summoner: Faker (Level 523)\n\n    Note:\n        This endpoint is rate limited and cached for 1 hour to improve\n        performance and reduce API load.\n    \"\"\"\n</code></pre>"},{"location":"development/documentation/#class-docstrings","title":"Class Docstrings","text":"<pre><code>class RiotClient:\n    \"\"\"\n    HTTP client for Riot API with rate limiting and retry logic.\n\n    Provides a robust wrapper around httpx for making requests to the Riot Games API\n    with automatic rate limiting, retry on 429 responses, and proper error handling.\n\n    Attributes:\n        api_key: Riot Games API key for authentication\n        client: Underlying httpx AsyncClient instance\n        rate_limiter: Rate limiter for API request throttling\n\n    Example:\n        &gt;&gt;&gt; client = RiotClient(\"RGAPI-example-key\")\n        &gt;&gt;&gt; summoner = await client.get(\n        ...     \"/lol/summoner/v4/summoners/by-name/Faker\",\n        ...     region=\"kr\"\n        ... )\n        &gt;&gt;&gt; print(summoner[\"name\"])\n        Faker\n    \"\"\"\n</code></pre>"},{"location":"development/documentation/#module-docstrings","title":"Module Docstrings","text":"<pre><code>\"\"\"\nRiot API HTTP client with rate limiting and automatic retries.\n\nThis module provides a comprehensive client for interacting with Riot Games APIs,\nincluding:\n\n- Automatic rate limiting using token bucket algorithm\n- Intelligent retry logic with exponential backoff\n- Region-aware URL routing\n- Comprehensive error handling and logging\n- Support for all Riot API endpoints\n\nThe client is designed to be production-ready with proper error handling,\nlogging, and monitoring capabilities.\n\nExample:\n    &gt;&gt;&gt; from app.riot.client import RiotClient\n    &gt;&gt;&gt; client = RiotClient(\"your-api-key\")\n    &gt;&gt;&gt; data = await client.get(\"/lol/summoner/v4/summoners/by-name/Faker\", \"kr\")\n\"\"\"\n</code></pre>"},{"location":"development/documentation/#api-documentation","title":"API Documentation","text":""},{"location":"development/documentation/#auto-generated-api-docs","title":"Auto-Generated API Docs","text":"<p>API documentation is automatically generated from docstrings using mkdocstrings.</p>"},{"location":"development/documentation/#creating-api-reference-pages","title":"Creating API Reference Pages","text":"<pre><code># Riot Client\n\nThis section documents the Riot API client implementation.\n\n## RiotClient\n\n::: app.riot.client.RiotClient\n    options:\n      show_source: true\n      show_root_heading: true\n      show_root_members_full_path: false\n      members_order: source\n\n## RateLimiter\n\n::: app.riot.rate_limiter.RateLimiter\n    options:\n      show_source: true\n      show_root_heading: true\n      show_root_members_full_path: false\n      members_order: source\n</code></pre>"},{"location":"development/documentation/#mkdocstrings-configuration-options","title":"mkdocstrings Configuration Options","text":"<pre><code>plugins:\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            docstring_style: google\n            show_source: true\n            show_root_heading: true\n            show_root_members_full_path: false\n            show_signature_annotations: true\n            signature_crossrefs: true\n            merge_init_into_class: true\n            members_order: source\n          paths: [.]\n</code></pre>"},{"location":"development/documentation/#cross-references","title":"Cross-References","text":"<p>Use automatic cross-references to link between documentation:</p> <pre><code># Link to specific class/methods\nUse the [`RiotClient`][app.riot.client.RiotClient] for API requests.\n\n# Link to specific method\nCall the [`get()`][app.riot.client.RiotClient.get] method.\n\n# Link with custom text\nThe [rate limiting][app.riot.rate_limiter.RateLimiter] system prevents API abuse.\n</code></pre>"},{"location":"development/documentation/#diagrams-and-visualizations","title":"Diagrams and Visualizations","text":""},{"location":"development/documentation/#mermaid-diagrams","title":"Mermaid Diagrams","text":"<p>Use Mermaid for architecture diagrams and flowcharts:</p> <p><pre><code>### Request Flow\n\n```mermaid\nsequenceDiagram\n    participant C as Client\n    participant G as Gateway\n    participant RL as Rate Limiter\n    participant Cache as Redis Cache\n    participant API as Riot API\n\n    C-&gt;&gt;G: HTTP Request\n    G-&gt;&gt;RL: Check Rate Limit\n    RL--&gt;&gt;G: Rate Limit OK\n    G-&gt;&gt;Cache: Check Cache\n\n    alt Cache Hit\n        Cache--&gt;&gt;G: Cached Response\n        G--&gt;&gt;C: HTTP Response\n    else Cache Miss\n        G-&gt;&gt;API: Make API Request\n        API--&gt;&gt;G: API Response\n        G-&gt;&gt;Cache: Store in Cache\n        G--&gt;&gt;C: HTTP Response\n    end\n</code></pre> <pre><code>### Architecture Diagrams\n\n```markdown\n### System Architecture\n\n```mermaid\ngraph TB\n    Client[Client Applications] --&gt; Gateway[API Gateway]\n    Gateway --&gt; RateLimiter[Rate Limiter]\n    Gateway --&gt; Cache[Redis Cache]\n    Gateway --&gt; RiotAPI[Riot Games API]\n\n    subgraph \"Gateway Components\"\n        Gateway --&gt; FastAPI[FastAPI App]\n        Gateway --&gt; Routers[API Routers]\n        Gateway --&gt; Client[Riot Client]\n    end\n\n    subgraph \"External Services\"\n        Redis[(Redis Server)]\n        Riot[Riot Developer Portal]\n    end\n\n    Cache --&gt; Redis\n    Client --&gt; Riot\n</code></pre> <pre><code>## Local Documentation Development\n\n### Setup\n\n```bash\n# Install documentation dependencies (using UV - recommended)\nuv pip install -e \".[docs]\"\n# or using pip:\npip install -e \".[docs]\"\n</code></pre></p>"},{"location":"development/documentation/#running-local-development-server","title":"Running Local Development Server","text":"<pre><code># Start MkDocs development server\nmkdocs serve\n\n# Start with live reload on specific port\nmkdocs serve --dev-addr=127.0.0.1:8001\n\n# Start with strict mode (better error checking)\nmkdocs serve --strict\n</code></pre>"},{"location":"development/documentation/#building-documentation","title":"Building Documentation","text":"<pre><code># Build documentation\nmkdocs build\n\n# Build with clean output\nmkdocs build --clean\n\n# Build to specific directory\nmkdocs build --site-dir /path/to/output\n</code></pre>"},{"location":"development/documentation/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Make Changes <pre><code># Edit documentation files\nvim docs/getting-started/installation.md\n</code></pre></p> </li> <li> <p>Preview Changes <pre><code># Start development server\nmkdocs serve\n# Visit http://127.0.0.1:8000\n</code></pre></p> </li> <li> <p>Check for Issues <pre><code># Build with strict checking\nmkdocs build --strict\n\n# Check for broken links\nmkdocs build --strict --verbose\n</code></pre></p> </li> <li> <p>Test Documentation <pre><code># Verify API documentation generates correctly\ncurl http://127.0.0.1:8000/api/riot-client/\n</code></pre></p> </li> </ol>"},{"location":"development/documentation/#documentation-quality","title":"Documentation Quality","text":""},{"location":"development/documentation/#review-checklist","title":"Review Checklist","text":"<p>Before submitting documentation changes:</p> <ul> <li>[ ] Accuracy: Information is correct and up-to-date</li> <li>[ ] Clarity: Language is clear and easy to understand</li> <li>[ ] Completeness: All necessary information is included</li> <li>[ ] Consistency: Style and terminology are consistent</li> <li>[ ] Formatting: Markdown formatting is correct</li> <li>[ ] Links: All links work and point to correct locations</li> <li>[ ] Code Examples: Code examples are tested and working</li> <li>[ ] Diagrams: Diagrams are clear and accurate</li> </ul>"},{"location":"development/documentation/#style-guidelines","title":"Style Guidelines","text":"<ol> <li>Active Voice: Use active voice (\"Click here\" not \"The button should be clicked\")</li> <li>Present Tense: Use present tense for instructions (\"Open the file\" not \"Open the file\")</li> <li>Simple Language: Avoid jargon and complex terminology</li> <li>Consistent Terminology: Use the same terms throughout the documentation</li> <li>Examples: Provide concrete examples for complex concepts</li> </ol>"},{"location":"development/documentation/#automated-documentation","title":"Automated Documentation","text":""},{"location":"development/documentation/#api-documentation-generation","title":"API Documentation Generation","text":"<p>The existing script generates API documentation from the running FastAPI app:</p> <pre><code># scripts/generate_api_docs.py\nimport asyncio\nimport httpx\nimport json\nfrom pathlib import Path\n\nasync def generate_api_docs():\n    \"\"\"Generate comprehensive API documentation.\"\"\"\n\n    # Get OpenAPI schema from running app\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\"http://localhost:8000/openapi.json\")\n        openapi_schema = response.json()\n\n    # Generate documentation pages\n    generate_endpoints_overview(openapi_schema)\n    generate_schemas_documentation(openapi_schema)\n</code></pre>"},{"location":"development/documentation/#cicd-integration","title":"CI/CD Integration","text":"<p>Documentation is automatically built and deployed:</p> <pre><code># .github/workflows/docs.yml\nname: Deploy Documentation\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Setup Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.12'\n\n    - name: Install dependencies\n      run: |\n        pip install -e \".[docs]\"\n\n    - name: Build documentation\n      run: mkdocs build\n\n    - name: Deploy to GitHub Pages\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: ./site\n</code></pre>"},{"location":"development/documentation/#contributing-to-documentation","title":"Contributing to Documentation","text":""},{"location":"development/documentation/#adding-new-documentation","title":"Adding New Documentation","text":"<ol> <li>Create the file in the appropriate directory</li> <li>Follow the style guidelines for formatting and structure</li> <li>Add cross-references to related documentation</li> <li>Update the navigation in <code>mkdocs.yml</code></li> <li>Test locally with <code>mkdocs serve</code></li> <li>Submit pull request with clear description</li> </ol>"},{"location":"development/documentation/#updating-existing-documentation","title":"Updating Existing Documentation","text":"<ol> <li>Make minimal changes to fix issues</li> <li>Preserve existing style and structure</li> <li>Update related documentation if necessary</li> <li>Test changes thoroughly</li> <li>Document the changes in pull request</li> </ol>"},{"location":"development/documentation/#documentation-review-process","title":"Documentation Review Process","text":"<ol> <li>Self-review your changes before submitting</li> <li>Check links and formatting</li> <li>Test code examples to ensure they work</li> <li>Request review from maintainers</li> <li>Address feedback promptly</li> </ol>"},{"location":"development/documentation/#best-practices","title":"Best Practices","text":""},{"location":"development/documentation/#documentation-maintenance","title":"Documentation Maintenance","text":"<ol> <li>Keep documentation current with code changes</li> <li>Review regularly for accuracy and completeness</li> <li>Update examples when APIs change</li> <li>Remove outdated information promptly</li> <li>Add new features to documentation as they're added</li> </ol>"},{"location":"development/documentation/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Optimize images for web (compress, appropriate formats)</li> <li>Minimize external dependencies in documentation</li> <li>Use code highlighting efficiently</li> <li>Avoid excessive nesting in documentation structure</li> </ol>"},{"location":"development/documentation/#accessibility","title":"Accessibility","text":"<ol> <li>Use semantic HTML in generated output</li> <li>Provide alt text for images and diagrams</li> <li>Ensure sufficient color contrast in diagrams</li> <li>Use descriptive link text instead of \"click here\"</li> </ol> <p>This documentation system ensures that the LOLStonks API Gateway has comprehensive, maintainable, and user-friendly documentation that stays synchronized with the codebase.</p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide covers testing strategies, tools, and best practices for the LOLStonks API Gateway.</p>"},{"location":"development/testing/#testing-overview","title":"Testing Overview","text":"<p>The project uses a comprehensive testing approach with multiple test types:</p> <ul> <li>Unit Tests: Test individual components in isolation</li> <li>Integration Tests: Test component interactions</li> <li>End-to-End Tests: Test complete request flows</li> <li>Performance Tests: Test system performance under load</li> </ul>"},{"location":"development/testing/#test-setup","title":"Test Setup","text":""},{"location":"development/testing/#installation","title":"Installation","text":"<pre><code># Install test dependencies\npip install -e \".[dev]\"\n\n# Or with uv\nuv install --extra dev\n</code></pre>"},{"location":"development/testing/#test-configuration","title":"Test Configuration","text":"<p>Create a test environment file:</p> <pre><code># .env.test\nRIOT_API_KEY=test-key-for-testing\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=1  # Separate database for testing\nLOG_LEVEL=DEBUG\nRATE_LIMIT_RPS=1000  # High limits for testing\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#basic-test-commands","title":"Basic Test Commands","text":"<pre><code># Run all tests\npytest\n\n# Run tests with coverage\npytest --cov=app --cov-report=html\n\n# Run specific test file\npytest tests/test_summoner.py\n\n# Run tests with specific marker\npytest -m unit\npytest -m integration\npytest -m slow\n</code></pre>"},{"location":"development/testing/#test-configuration_1","title":"Test Configuration","text":"<pre><code># pytest.ini\n[tool:pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\naddopts =\n    --strict-markers\n    --strict-config\n    --tb=short\n    -v\nmarkers =\n    unit: Unit tests (fast, no external dependencies)\n    integration: Integration tests (requires external services)\n    slow: Slow tests (performance, load testing)\n    external: Tests that hit external APIs\n</code></pre>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Pytest configuration and fixtures\n\u251c\u2500\u2500 unit/                    # Unit tests\n\u2502   \u251c\u2500\u2500 test_rate_limiter.py\n\u2502   \u251c\u2500\u2500 test_cache.py\n\u2502   \u2514\u2500\u2500 test_models.py\n\u251c\u2500\u2500 integration/             # Integration tests\n\u2502   \u251c\u2500\u2500 test_client.py\n\u2502   \u251c\u2500\u2500 test_cache_integration.py\n\u2502   \u2514\u2500\u2500 test_routers.py\n\u251c\u2500\u2500 end_to_end/              # End-to-end tests\n\u2502   \u251c\u2500\u2500 test_api_flows.py\n\u2502   \u2514\u2500\u2500 test_full_scenarios.py\n\u251c\u2500\u2500 performance/             # Performance tests\n\u2502   \u251c\u2500\u2500 test_load.py\n\u2502   \u2514\u2500\u2500 test_stress.py\n\u2514\u2500\u2500 fixtures/                # Test data\n    \u251c\u2500\u2500 summoner_data.json\n    \u251c\u2500\u2500 match_data.json\n    \u2514\u2500\u2500 league_data.json\n</code></pre>"},{"location":"development/testing/#fixtures-and-configuration","title":"Fixtures and Configuration","text":""},{"location":"development/testing/#conftestpy","title":"conftest.py","text":"<pre><code># tests/conftest.py\nimport pytest\nimport asyncio\nimport json\nfrom pathlib import Path\nfrom unittest.mock import AsyncMock, MagicMock\nfrom httpx import AsyncClient\n\nfrom app.main import app\nfrom app.riot.client import RiotClient\nfrom app.cache.redis_cache import RedisCache\nfrom app.cache.tracking import MatchTracker\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create an instance of the default event loop for the test session.\"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\nasync def client():\n    \"\"\"Test client for FastAPI app.\"\"\"\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        yield ac\n\n@pytest.fixture\ndef mock_redis():\n    \"\"\"Mock Redis client for testing.\"\"\"\n    redis_mock = AsyncMock()\n    redis_mock.get.return_value = None\n    redis_mock.setex.return_value = True\n    redis_mock.delete.return_value = True\n    redis_mock.sismember.return_value = False\n    redis_mock.sadd.return_value = True\n    return redis_mock\n\n@pytest.fixture\ndef cache(mock_redis):\n    \"\"\"Redis cache fixture with mocked Redis.\"\"\"\n    cache = RedisCache()\n    cache.redis = mock_redis\n    return cache\n\n@pytest.fixture\ndef mock_riot_client():\n    \"\"\"Mock Riot client for testing.\"\"\"\n    client = AsyncMock()\n    return client\n\n@pytest.fixture\ndef rate_limiter():\n    \"\"\"Rate limiter fixture for testing.\"\"\"\n    from app.riot.rate_limiter import RateLimiter\n    return RateLimiter(rate=100, capacity=1000)  # High limits for tests\n\n@pytest.fixture\ndef match_tracker(cache):\n    \"\"\"Match tracker fixture.\"\"\"\n    return MatchTracker(cache)\n\n@pytest.fixture\ndef sample_summoner_data():\n    \"\"\"Sample summoner data for testing.\"\"\"\n    return {\n        \"id\": \"test-summoner-id\",\n        \"accountId\": \"test-account-id\",\n        \"puuid\": \"test-puuid\",\n        \"name\": \"TestSummoner\",\n        \"profileIconId\": 1,\n        \"revisionDate\": 1234567890,\n        \"summonerLevel\": 30\n    }\n\n@pytest.fixture\ndef sample_match_data():\n    \"\"\"Sample match data for testing.\"\"\"\n    return {\n        \"gameId\": 1234567890,\n        \"gameDuration\": 1800,\n        \"gameMode\": \"CLASSIC\",\n        \"gameType\": \"MATCHED_GAME\",\n        \"participants\": [],\n        \"teams\": []\n    }\n\ndef load_fixture(filename):\n    \"\"\"Load test data from JSON fixture.\"\"\"\n    fixture_path = Path(__file__).parent / \"fixtures\" / filename\n    with open(fixture_path, 'r') as f:\n        return json.load(f)\n</code></pre>"},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":""},{"location":"development/testing/#rate-limiter-tests","title":"Rate Limiter Tests","text":"<pre><code># tests/unit/test_rate_limiter.py\nimport pytest\nimport asyncio\nfrom unittest.mock import patch\nfrom datetime import datetime, timedelta\n\nfrom app.riot.rate_limiter import RateLimiter\n\nclass TestRateLimiter:\n    \"\"\"Test the rate limiter implementation.\"\"\"\n\n    @pytest.mark.unit\n    def test_rate_limiter_initialization(self):\n        \"\"\"Test rate limiter initialization.\"\"\"\n        limiter = RateLimiter(rate=10, capacity=50)\n        assert limiter.rate == 10\n        assert limiter.capacity == 50\n        assert limiter.tokens == 50\n\n    @pytest.mark.unit\n    async def test_token_consumption(self):\n        \"\"\"Test token consumption.\"\"\"\n        limiter = RateLimiter(rate=10, capacity=50)\n\n        # Should consume one token\n        await limiter.acquire()\n        assert limiter.tokens == 49\n\n    @pytest.mark.unit\n    async def test_token_refill(self):\n        \"\"\"Test token refill over time.\"\"\"\n        limiter = RateLimiter(rate=10, capacity=50)\n\n        # Consume all tokens\n        for _ in range(50):\n            await limiter.acquire()\n\n        assert limiter.tokens == 0\n\n        # Wait for refill (mock time passage)\n        with patch('datetime.datetime') as mock_datetime:\n            mock_datetime.utcnow.return_value = datetime.utcnow() + timedelta(seconds=2)\n            await limiter._refill()\n\n            # Should have 20 tokens after 2 seconds (10 * 2)\n            assert limiter.tokens == 20\n\n    @pytest.mark.unit\n    async def test_rate_limit_exceeded(self):\n        \"\"\"Test behavior when rate limit is exceeded.\"\"\"\n        limiter = RateLimiter(rate=1, capacity=2)\n\n        # Consume all tokens\n        await limiter.acquire()\n        await limiter.acquire()\n\n        # Next acquire should wait\n        start_time = asyncio.get_event_loop().time()\n        await limiter.acquire()\n        end_time = asyncio.get_event_loop().time()\n\n        # Should have waited at least 1 second\n        assert end_time - start_time &gt;= 1.0\n\n    @pytest.mark.unit\n    async def test_concurrent_acquisition(self):\n        \"\"\"Test concurrent token acquisition.\"\"\"\n        limiter = RateLimiter(rate=100, capacity=100)\n\n        async def acquire_tokens():\n            for _ in range(10):\n                await limiter.acquire()\n\n        # Run multiple concurrent tasks\n        tasks = [acquire_tokens() for _ in range(10)]\n        await asyncio.gather(*tasks)\n\n        # Should have consumed exactly 100 tokens\n        assert limiter.tokens == 0\n</code></pre>"},{"location":"development/testing/#cache-tests","title":"Cache Tests","text":"<pre><code># tests/unit/test_cache.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\nimport json\n\nfrom app.cache.redis_cache import RedisCache\n\nclass TestRedisCache:\n    \"\"\"Test Redis cache implementation.\"\"\"\n\n    @pytest.mark.unit\n    def test_cache_key_generation(self):\n        \"\"\"Test cache key generation.\"\"\"\n        cache = RedisCache()\n\n        key = cache._generate_key(\"summoner\", \"euw1\", \"test-id\")\n        assert key == \"lolstonks:summoner:euw1:test-id\"\n\n    @pytest.mark.unit\n    async def test_cache_set_and_get(self, mock_redis):\n        \"\"\"Test setting and getting cache values.\"\"\"\n        cache = RedisCache()\n        cache.redis = mock_redis\n\n        test_data = {\"id\": \"test\", \"name\": \"Test User\"}\n\n        # Set cache\n        result = await cache.set(\"summoner\", \"euw1\", \"test-id\", test_data, ttl=3600)\n        assert result is True\n\n        # Configure mock for get\n        mock_redis.get.return_value = json.dumps(test_data)\n\n        # Get cache\n        result = await cache.get(\"summoner\", \"euw1\", \"test-id\")\n        assert result == test_data\n\n    @pytest.mark.unit\n    async def test_cache_miss(self, mock_redis):\n        \"\"\"Test cache miss scenario.\"\"\"\n        cache = RedisCache()\n        cache.redis = mock_redis\n\n        # Configure mock to return None (cache miss)\n        mock_redis.get.return_value = None\n\n        result = await cache.get(\"summoner\", \"euw1\", \"nonexistent\")\n        assert result is None\n\n    @pytest.mark.unit\n    async def test_cache_delete(self, mock_redis):\n        \"\"\"Test cache deletion.\"\"\"\n        cache = RedisCache()\n        cache.redis = mock_redis\n\n        result = await cache.delete(\"summoner\", \"euw1\", \"test-id\")\n        assert result is True\n\n        mock_redis.delete.assert_called_once_with(\"lolstonks:summoner:euw1:test-id\")\n\n    @pytest.mark.unit\n    async def test_cache_error_handling(self, mock_redis):\n        \"\"\"Test cache error handling.\"\"\"\n        cache = RedisCache()\n        cache.redis = mock_redis\n\n        # Configure mock to raise exception\n        mock_redis.get.side_effect = Exception(\"Redis error\")\n\n        result = await cache.get(\"summoner\", \"euw1\", \"test-id\")\n        assert result is None\n\n    @pytest.mark.unit\n    def test_ttl_config_loading(self, monkeypatch):\n        \"\"\"Test TTL configuration loading.\"\"\"\n        # Set environment variables\n        monkeypatch.setenv(\"CACHE_TTL_SUMMONER\", \"7200\")\n        monkeypatch.setenv(\"CACHE_TTL_MATCH\", \"86400\")\n\n        cache = RedisCache()\n\n        assert cache.ttl_config[\"summoner\"] == 7200\n        assert cache.ttl_config[\"match\"] == 86400\n</code></pre>"},{"location":"development/testing/#model-tests","title":"Model Tests","text":"<pre><code># tests/unit/test_models.py\nimport pytest\nfrom pydantic import ValidationError\n\nfrom app.models.summoner import SummonerDto, SummonerByNameParams\nfrom app.models.match import MatchDto, MatchIdsByPuuidParams\n\nclass TestModels:\n    \"\"\"Test Pydantic models.\"\"\"\n\n    @pytest.mark.unit\n    def test_summoner_dto_validation(self, sample_summoner_data):\n        \"\"\"Test SummonerDto validation.\"\"\"\n        summoner = SummonerDto(**sample_summoner_data)\n\n        assert summoner.id == \"test-summoner-id\"\n        assert summoner.name == \"TestSummoner\"\n        assert summoner.summonerLevel == 30\n\n    @pytest.mark.unit\n    def test_summoner_dto_missing_required_fields(self):\n        \"\"\"Test SummonerDto validation with missing fields.\"\"\"\n        invalid_data = {\n            \"id\": \"test-id\",\n            # Missing required fields\n        }\n\n        with pytest.raises(ValidationError):\n            SummonerDto(**invalid_data)\n\n    @pytest.mark.unit\n    def test_summoner_by_name_params(self):\n        \"\"\"Test SummonerByNameParams validation.\"\"\"\n        params = SummonerByNameParams(summonerName=\"TestSummoner\")\n        assert params.summonerName == \"TestSummoner\"\n\n    @pytest.mark.unit\n    def test_match_ids_by_puuid_params(self):\n        \"\"\"Test MatchIdsByPuuidParams validation.\"\"\"\n        params = MatchIdsByPuuidParams(\n            puuid=\"test-puuid\",\n            count=10,\n            start=0\n        )\n        assert params.puuid == \"test-puuid\"\n        assert params.count == 10\n        assert params.start == 0\n\n    @pytest.mark.unit\n    def test_model_serialization(self, sample_summoner_data):\n        \"\"\"Test model serialization.\"\"\"\n        summoner = SummonerDto(**sample_summoner_data)\n\n        serialized = summoner.model_dump()\n        assert serialized[\"id\"] == \"test-summoner-id\"\n        assert serialized[\"name\"] == \"TestSummoner\"\n\n    @pytest.mark.unit\n    def test_model_json_serialization(self, sample_summoner_data):\n        \"\"\"Test model JSON serialization.\"\"\"\n        summoner = SummonerDto(**sample_summoner_data)\n\n        json_str = summoner.model_dump_json()\n        assert \"test-summoner-id\" in json_str\n        assert \"TestSummoner\" in json_str\n</code></pre>"},{"location":"development/testing/#integration-tests","title":"Integration Tests","text":""},{"location":"development/testing/#client-integration-tests","title":"Client Integration Tests","text":"<pre><code># tests/integration/test_client.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\nimport httpx\n\nfrom app.riot.client import RiotClient, RateLimitExceeded\n\nclass TestRiotClient:\n    \"\"\"Test Riot client integration.\"\"\"\n\n    @pytest.mark.integration\n    async def test_successful_request(self, mock_riot_client, rate_limiter):\n        \"\"\"Test successful API request.\"\"\"\n        mock_riot_client.get.return_value = {\"id\": \"test-summoner-id\"}\n\n        client = RiotClient(\"test-api-key\")\n        client.client = mock_riot_client\n        client.rate_limiter = rate_limiter\n\n        result = await client.get(\"/summoner/v4/summoners/by-name/test\", \"euw1\")\n\n        assert result[\"id\"] == \"test-summoner-id\"\n\n    @pytest.mark.integration\n    async def test_rate_limit_handling(self, mock_riot_client, rate_limiter):\n        \"\"\"Test rate limit handling.\"\"\"\n        # Mock 429 response\n        mock_response = AsyncMock()\n        mock_response.status_code = 429\n        mock_response.headers = {\"Retry-After\": \"1\"}\n        mock_riot_client.get.return_value = mock_response\n\n        client = RiotClient(\"test-api-key\")\n        client.client = mock_riot_client\n        client.rate_limiter = rate_limiter\n\n        with pytest.raises(RateLimitExceeded):\n            await client.get(\"/summoner/v4/summoners/by-name/test\", \"euw1\")\n\n    @pytest.mark.integration\n    async def test_retry_mechanism(self, mock_riot_client, rate_limiter):\n        \"\"\"Test retry mechanism.\"\"\"\n        # First call returns 429, second call succeeds\n        mock_429_response = AsyncMock()\n        mock_429_response.status_code = 429\n        mock_429_response.headers = {\"Retry-After\": \"1\"}\n\n        mock_success_response = AsyncMock()\n        mock_success_response.status_code = 200\n        mock_success_response.json.return_value = {\"id\": \"test-summoner-id\"}\n\n        mock_riot_client.get.side_effect = [mock_429_response, mock_success_response]\n\n        client = RiotClient(\"test-api-key\")\n        client.client = mock_riot_client\n        client.rate_limiter = rate_limiter\n\n        with patch('asyncio.sleep'):  # Skip actual sleep\n            result = await client.get(\"/summoner/v4/summoners/by-name/test\", \"euw1\")\n\n        assert result[\"id\"] == \"test-summoner-id\"\n        assert mock_riot_client.get.call_count == 2\n</code></pre>"},{"location":"development/testing/#router-integration-tests","title":"Router Integration Tests","text":"<pre><code># tests/integration/test_routers.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\nfrom fastapi.testclient import TestClient\n\nfrom app.main import app\n\nclass TestRouters:\n    \"\"\"Test router integration.\"\"\"\n\n    @pytest.mark.integration\n    async def test_summoner_by_name_endpoint(self, client, mock_riot_client):\n        \"\"\"Test summoner by name endpoint.\"\"\"\n        sample_response = {\n            \"id\": \"test-summoner-id\",\n            \"name\": \"TestSummoner\",\n            \"summonerLevel\": 30\n        }\n\n        with patch('app.routers.summoner.riot_client', mock_riot_client):\n            mock_riot_client.get.return_value = sample_response\n\n            response = await client.get(\n                \"/summoner/by-name/TestSummoner?region=euw1\"\n            )\n\n            assert response.status_code == 200\n            data = response.json()\n            assert data[\"id\"] == \"test-summoner-id\"\n            assert data[\"name\"] == \"TestSummoner\"\n\n    @pytest.mark.integration\n    async def test_summoner_not_found(self, client, mock_riot_client):\n        \"\"\"Test summoner not found scenario.\"\"\"\n        with patch('app.routers.summoner.riot_client', mock_riot_client):\n            mock_riot_client.get.side_effect = httpx.HTTPStatusError(\n                \"Not Found\", request=AsyncMock(), response=AsyncMock(status_code=404)\n            )\n\n            response = await client.get(\n                \"/summoner/by-name/NonexistentSummoner?region=euw1\"\n            )\n\n            assert response.status_code == 404\n\n    @pytest.mark.integration\n    async def test_health_check_endpoint(self, client):\n        \"\"\"Test health check endpoint.\"\"\"\n        response = await client.get(\"/health\")\n\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"status\"] == \"ok\"\n\n    @pytest.mark.integration\n    async def test_rate_limit_headers(self, client, mock_riot_client):\n        \"\"\"Test rate limit headers in response.\"\"\"\n        sample_response = {\"id\": \"test-id\"}\n\n        with patch('app.routers.summoner.riot_client', mock_riot_client):\n            mock_riot_client.get.return_value = sample_response\n\n            response = await client.get(\n                \"/summoner/by-name/Test?region=euw1\"\n            )\n\n            # Check for rate limit headers\n            assert \"X-Rate-Limit-Remaining\" in response.headers\n            assert \"X-Rate-Limit-Limit\" in response.headers\n</code></pre>"},{"location":"development/testing/#performance-tests","title":"Performance Tests","text":""},{"location":"development/testing/#load-testing","title":"Load Testing","text":"<pre><code># tests/performance/test_load.py\nimport pytest\nimport asyncio\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\nfrom app.riot.rate_limiter import RateLimiter\nfrom app.cache.redis_cache import RedisCache\n\n@pytest.mark.slow\nclass TestPerformance:\n    \"\"\"Performance and load tests.\"\"\"\n\n    @pytest.mark.slow\n    async def test_rate_limiter_performance(self):\n        \"\"\"Test rate limiter under load.\"\"\"\n        limiter = RateLimiter(rate=100, capacity=1000)\n\n        start_time = time.time()\n\n        # Make 1000 concurrent requests\n        tasks = [limiter.acquire() for _ in range(1000)]\n        await asyncio.gather(*tasks)\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        # Should complete in reasonable time (within 15 seconds)\n        assert duration &lt; 15.0\n\n        # Rate limiter should still work\n        assert limiter.tokens &gt;= 0\n\n    @pytest.mark.slow\n    async def test_cache_performance(self, cache):\n        \"\"\"Test cache performance under load.\"\"\"\n        test_data = {\"id\": \"test\", \"data\": \"x\" * 1000}  # 1KB data\n\n        start_time = time.time()\n\n        # Perform 1000 cache operations\n        tasks = []\n        for i in range(1000):\n            tasks.append(cache.set(\"test\", \"euw1\", f\"key{i}\", test_data))\n            tasks.append(cache.get(\"test\", \"euw1\", f\"key{i}\"))\n\n        await asyncio.gather(*tasks)\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        # Should complete quickly (within 5 seconds)\n        assert duration &lt; 5.0\n\n        # Performance: at least 200 operations per second\n        operations_per_second = 2000 / duration\n        assert operations_per_second &gt; 200\n\n    @pytest.mark.slow\n    async def test_concurrent_api_requests(self, client):\n        \"\"\"Test concurrent API request handling.\"\"\"\n        async def make_request():\n            response = await client.get(\"/health\")\n            return response.status_code\n\n        start_time = time.time()\n\n        # Make 100 concurrent requests\n        tasks = [make_request() for _ in range(100)]\n        results = await asyncio.gather(*tasks)\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        # All requests should succeed\n        assert all(status == 200 for status in results)\n\n        # Should complete quickly (within 2 seconds)\n        assert duration &lt; 2.0\n\n        # Performance: at least 50 requests per second\n        requests_per_second = 100 / duration\n        assert requests_per_second &gt; 50\n</code></pre>"},{"location":"development/testing/#external-api-tests","title":"External API Tests","text":""},{"location":"development/testing/#real-api-tests","title":"Real API Tests","text":"<pre><code># tests/integration/test_external_api.py\nimport pytest\nimport os\n\nfrom app.riot.client import RiotClient\n\n@pytest.mark.external\n@pytest.mark.slow\nclass TestExternalAPI:\n    \"\"\"Tests against real Riot API (requires API key).\"\"\"\n\n    @pytest.fixture\n    def real_riot_client(self):\n        \"\"\"Real Riot client using actual API key.\"\"\"\n        api_key = os.getenv(\"RIOT_API_KEY\")\n        if not api_key:\n            pytest.skip(\"No RIOT_API_KEY environment variable set\")\n\n        return RiotClient(api_key)\n\n    @pytest.mark.external\n    async def test_real_summoner_lookup(self, real_riot_client):\n        \"\"\"Test real summoner lookup.\"\"\"\n        try:\n            result = await real_riot_client.get(\n                \"/lol/summoner/v4/summoners/by-name/Faker\",\n                \"kr\"\n            )\n\n            assert \"id\" in result\n            assert \"name\" in result\n            assert result[\"name\"] == \"Faker\"\n        except Exception as e:\n            pytest.skip(f\"External API test failed: {e}\")\n\n    @pytest.mark.external\n    async def test_real_challenger_lookup(self, real_riot_client):\n        \"\"\"Test real challenger league lookup.\"\"\"\n        try:\n            result = await real_riot_client.get(\n                \"/lol/league/v4/challengerleagues/by-queue/RANKED_SOLO_5x5\",\n                \"kr\"\n            )\n\n            assert \"tier\" in result\n            assert \"entries\" in result\n            assert result[\"tier\"] == \"CHALLENGER\"\n        except Exception as e:\n            pytest.skip(f\"External API test failed: {e}\")\n</code></pre>"},{"location":"development/testing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/testing/#common-test-issues","title":"Common Test Issues","text":"<ol> <li> <p>Redis Connection Errors <pre><code># Make sure Redis is running\nredis-server\n\n# Or run in Docker\ndocker run -d -p 6379:6379 redis:7-alpine\n</code></pre></p> </li> <li> <p>Rate Limiting in Tests <pre><code># Set high rate limits for tests\nRATE_LIMIT_RPS=1000\nRATE_LIMIT_BURST=10000\n</code></pre></p> </li> <li> <p>Test Database Issues <pre><code># Use separate Redis database for testing\nREDIS_DB=1\n\n# Flush test database between runs\nredis-cli -n 1 FLUSHDB\n</code></pre></p> </li> <li> <p>Import Errors <pre><code># Make sure you're in the project root\ncd /path/to/lolstonks-api-gateway\n\n# Install in development mode\npip install -e \".[dev]\"\n</code></pre></p> </li> </ol>"},{"location":"development/testing/#debugging-tests","title":"Debugging Tests","text":"<pre><code># Run with verbose output\npytest -v -s\n\n# Stop on first failure\npytest -x\n\n# Run with debugger\npytest --pdb\n\n# Show local variables on failure\npytest -l\n\n# Run specific test with debug\npytest tests/unit/test_rate_limiter.py::TestRateLimiter::test_token_consumption -v -s\n</code></pre> <p>This comprehensive testing strategy ensures the LOLStonks API Gateway is reliable, performant, and maintainable across different scenarios and conditions.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>This guide covers all configuration options available for the LOLStonks API Gateway.</p>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>The gateway uses environment variables for configuration. You can set these in a <code>.env</code> file or as system environment variables.</p>"},{"location":"getting-started/configuration/#required-variables","title":"Required Variables","text":"<pre><code># Riot Games API Key\nRIOT_API_KEY=RGAPI-your-api-key-here\n</code></pre> <p>Get your API key from the Riot Developer Portal.</p>"},{"location":"getting-started/configuration/#optional-variables","title":"Optional Variables","text":""},{"location":"getting-started/configuration/#core-configuration","title":"Core Configuration","text":"<pre><code># Default Riot API region (default: euw1)\nRIOT_DEFAULT_REGION=euw1\n\n# Server configuration\nHOST=0.0.0.0\nPORT=8080\n\n# Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\nLOG_LEVEL=INFO\n</code></pre>"},{"location":"getting-started/configuration/#redis-configuration","title":"Redis Configuration","text":"<pre><code># Redis connection settings\nREDIS_HOST=redis\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=\n\n# Redis connection pool settings\nREDIS_POOL_SIZE=10\nREDIS_POOL_TIMEOUT=30\n</code></pre>"},{"location":"getting-started/configuration/#rate-limiting-configuration","title":"Rate Limiting Configuration","text":"<pre><code># Rate limiting settings\nRATE_LIMIT_RPS=20           # Requests per second\nRATE_LIMIT_BURST=100        # Burst capacity\nRATE_LIMIT_PERIOD=120       # Period in seconds for burst refill\n</code></pre>"},{"location":"getting-started/configuration/#caching-configuration","title":"Caching Configuration","text":"<pre><code># Cache TTL settings (in seconds)\nCACHE_TTL_SUMMONER=3600     # 1 hour\nCACHE_TTL_MATCH=86400       # 24 hours\nCACHE_TTL_LEAGUE=1800       # 30 minutes\nCACHE_TTL_MASTERY=7200      # 2 hours\nCACHE_TTL_CHAMPION=604800   # 1 week\n\n# Match tracking TTL\nMATCH_TRACKING_TTL=604800   # 1 week\n</code></pre>"},{"location":"getting-started/configuration/#complete-env-example","title":"Complete .env Example","text":"<pre><code># =============================================================================\n# Riot API Configuration\n# =============================================================================\nRIOT_API_KEY=RGAPI-your-actual-api-key-here\nRIOT_DEFAULT_REGION=euw1\n\n# =============================================================================\n# Server Configuration\n# =============================================================================\nHOST=0.0.0.0\nPORT=8080\nLOG_LEVEL=INFO\n\n# =============================================================================\n# Redis Configuration\n# =============================================================================\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=\nREDIS_POOL_SIZE=10\nREDIS_POOL_TIMEOUT=30\n\n# =============================================================================\n# Rate Limiting Configuration\n# =============================================================================\nRATE_LIMIT_RPS=20\nRATE_LIMIT_BURST=100\nRATE_LIMIT_PERIOD=120\n\n# =============================================================================\n# Caching Configuration\n# =============================================================================\nCACHE_TTL_SUMMONER=3600\nCACHE_TTL_MATCH=86400\nCACHE_TTL_LEAGUE=1800\nCACHE_TTL_MASTERY=7200\nCACHE_TTL_CHAMPION=604800\nMATCH_TRACKING_TTL=604800\n</code></pre>"},{"location":"getting-started/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"getting-started/configuration/#env-file","title":".env File","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code># Copy the example file\ncp .env.example .env\n\n# Edit with your configuration\nnano .env  # or use your preferred editor\n</code></pre>"},{"location":"getting-started/configuration/#docker-compose-configuration","title":"Docker Compose Configuration","text":"<p>When using Docker Compose, you can override environment variables:</p> <pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  api-gateway:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      - RIOT_API_KEY=${RIOT_API_KEY}\n      - REDIS_HOST=redis\n      - LOG_LEVEL=DEBUG\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n</code></pre>"},{"location":"getting-started/configuration/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"getting-started/configuration/#custom-rate-limiting","title":"Custom Rate Limiting","text":"<p>You can customize rate limiting per endpoint or per region:</p> <pre><code># In your custom configuration\nCUSTOM_RATE_LIMITS = {\n    \"summoner\": {\"rps\": 30, \"burst\": 150},\n    \"match\": {\"rps\": 10, \"burst\": 50},\n    \"league\": {\"rps\": 20, \"burst\": 100}\n}\n</code></pre>"},{"location":"getting-started/configuration/#redis-cluster-configuration","title":"Redis Cluster Configuration","text":"<p>For production deployments, you can use Redis Cluster:</p> <pre><code># Redis Cluster configuration\nREDIS_CLUSTER_ENABLED=true\nREDIS_CLUSTER_NODES=redis-node1:6379,redis-node2:6379,redis-node3:6379\nREDIS_CLUSTER_PASSWORD=your-cluster-password\n</code></pre>"},{"location":"getting-started/configuration/#custom-cache-keys","title":"Custom Cache Keys","text":"<p>Customize cache key patterns:</p> <pre><code># Cache key patterns\nCACHE_KEY_PREFIX=lolstonks\nCACHE_KEY_VERSION=v1\n</code></pre>"},{"location":"getting-started/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"getting-started/configuration/#development","title":"Development","text":"<pre><code># .env.development\nLOG_LEVEL=DEBUG\nREDIS_HOST=localhost\nCACHE_TTL_SUMMONER=300      # 5 minutes for development\nRATE_LIMIT_RPS=100          # Higher limits for testing\n</code></pre>"},{"location":"getting-started/configuration/#production","title":"Production","text":"<pre><code># .env.production\nLOG_LEVEL=WARNING\nREDIS_HOST=redis-cluster.example.com\nREDIS_PASSWORD=strong-redis-password\nCACHE_TTL_SUMMONER=3600     # Longer cache for production\nRATE_LIMIT_RPS=20           # Conservative limits\n</code></pre>"},{"location":"getting-started/configuration/#testing","title":"Testing","text":"<pre><code># .env.testing\nLOG_LEVEL=ERROR\nREDIS_HOST=localhost\nCACHE_TTL_SUMMONER=1        # Very short cache for tests\nRATE_LIMIT_RPS=1000         # Very high limits for tests\n</code></pre>"},{"location":"getting-started/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>The gateway validates configuration on startup. Here are common validation checks:</p>"},{"location":"getting-started/configuration/#api-key-validation","title":"API Key Validation","text":"<pre><code># The gateway will check if your API key is valid\n# Invalid or expired keys will cause startup to fail\n</code></pre>"},{"location":"getting-started/configuration/#redis-connection-test","title":"Redis Connection Test","text":"<pre><code># The gateway tests Redis connectivity during startup\n# Connection failures will be logged but won't prevent startup\n</code></pre>"},{"location":"getting-started/configuration/#region-validation","title":"Region Validation","text":"<pre><code># Supported regions are validated\n# Invalid regions will fall back to the default region\n</code></pre>"},{"location":"getting-started/configuration/#performance-tuning","title":"Performance Tuning","text":""},{"location":"getting-started/configuration/#rate-limiting-optimization","title":"Rate Limiting Optimization","text":"<pre><code># For high-traffic applications\nRATE_LIMIT_RPS=50\nRATE_LIMIT_BURST=500\nRATE_LIMIT_PERIOD=60\n\n# For low-traffic applications\nRATE_LIMIT_RPS=5\nRATE_LIMIT_BURST=20\nRATE_LIMIT_PERIOD=300\n</code></pre>"},{"location":"getting-started/configuration/#cache-optimization","title":"Cache Optimization","text":"<pre><code># Aggressive caching for better performance\nCACHE_TTL_SUMMONER=7200     # 2 hours\nCACHE_TTL_MATCH=172800      # 2 days\nCACHE_TTL_LEAGUE=3600       # 1 hour\n\n# Minimal caching for fresh data\nCACHE_TTL_SUMMONER=300      # 5 minutes\nCACHE_TTL_MATCH=1800        # 30 minutes\nCACHE_TTL_LEAGUE=600        # 10 minutes\n</code></pre>"},{"location":"getting-started/configuration/#redis-performance","title":"Redis Performance","text":"<pre><code># Connection pool optimization\nREDIS_POOL_SIZE=20          # Increase for high concurrency\nREDIS_POOL_TIMEOUT=10       # Lower timeout for faster failover\n\n# Memory optimization\nREDIS_MAXMEMORY=1gb\nREDIS_MAXMEMORY_POLICY=allkeys-lru\n</code></pre>"},{"location":"getting-started/configuration/#security-configuration","title":"Security Configuration","text":""},{"location":"getting-started/configuration/#api-key-protection","title":"API Key Protection","text":"<pre><code># Never commit API keys to version control\n# Use environment variables or secret management systems\nRIOT_API_KEY=${RIOT_API_KEY_SECRET}\n</code></pre>"},{"location":"getting-started/configuration/#network-security","title":"Network Security","text":"<pre><code># Bind to specific interface in production\nHOST=127.0.0.1              # Local access only\n# or\nHOST=10.0.0.1               # Specific network interface\n</code></pre>"},{"location":"getting-started/configuration/#logging-security","title":"Logging Security","text":"<pre><code># Sanitize logs to avoid logging sensitive data\nLOG_SANITIZE_SECRETS=true\nLOG_LEVEL=WARNING           # Reduce log verbosity in production\n</code></pre>"},{"location":"getting-started/configuration/#monitoring-configuration","title":"Monitoring Configuration","text":""},{"location":"getting-started/configuration/#health-checks","title":"Health Checks","text":"<pre><code># Enable detailed health checks\nHEALTH_CHECK_DETAILED=true\nHEALTH_CHECK_REDIS=true\nHEALTH_CHECK_RIOT_API=true\n</code></pre>"},{"location":"getting-started/configuration/#metrics","title":"Metrics","text":"<pre><code># Enable metrics collection\nMETRICS_ENABLED=true\nMETRICS_PORT=9090\nMETRICS_PATH=/metrics\n</code></pre>"},{"location":"getting-started/configuration/#troubleshooting-configuration","title":"Troubleshooting Configuration","text":""},{"location":"getting-started/configuration/#common-issues","title":"Common Issues","text":"<ol> <li> <p>API Key Not Working <pre><code># Check that your API key is valid and not expired\n# Verify it doesn't have IP restrictions\nRIOT_API_KEY=RGAPI-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n</code></pre></p> </li> <li> <p>Redis Connection Failed <pre><code># Check Redis is running and accessible\nREDIS_HOST=localhost\nREDIS_PORT=6379\n# Verify network connectivity and firewall rules\n</code></pre></p> </li> <li> <p>Rate Limiting Too Aggressive <pre><code># Adjust rate limits based on your usage\nRATE_LIMIT_RPS=10\nRATE_LIMIT_BURST=50\n</code></pre></p> </li> <li> <p>Cache Not Working <pre><code># Check Redis connection and cache TTL settings\nREDIS_HOST=localhost\nCACHE_TTL_SUMMONER=3600\n</code></pre></p> </li> </ol>"},{"location":"getting-started/configuration/#configuration-debugging","title":"Configuration Debugging","text":"<p>Enable debug logging to troubleshoot configuration issues:</p> <pre><code>LOG_LEVEL=DEBUG\n</code></pre> <p>This will show: - Environment variable loading - Redis connection attempts - Rate limiting configuration - Cache configuration details</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Configure your development environment</li> <li>Set up monitoring and logging</li> <li>Review the API Reference for endpoint details</li> </ul>"},{"location":"getting-started/configuration/#getting-help","title":"Getting Help","text":"<p>If you need help with configuration:</p> <ol> <li>Check the GitHub Issues</li> <li>Review the troubleshooting guide</li> <li>Create a new issue with your configuration details (without sensitive data)</li> </ol>"},{"location":"getting-started/deployment/","title":"Production Deployment","text":"<p>This guide covers deploying the LOLStonks API Gateway to production environments with proper security, monitoring, and scalability considerations.</p>"},{"location":"getting-started/deployment/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/deployment/#system-requirements","title":"System Requirements","text":"<ul> <li>CPU: 2+ cores (4+ recommended for high traffic)</li> <li>RAM: 4GB+ (8GB+ recommended for production)</li> <li>Storage: 20GB+ SSD for logs and caching</li> <li>Network: Stable internet connection with low latency to Riot API servers</li> <li>Operating System: Linux (Ubuntu 20.04+, CentOS 8+, or similar)</li> </ul>"},{"location":"getting-started/deployment/#external-dependencies","title":"External Dependencies","text":"<ul> <li>Redis Server: 6.0+ for caching and session management</li> <li>Reverse Proxy: Nginx 1.18+ or similar for SSL termination</li> <li>Process Manager: systemd, supervisor, or similar</li> <li>SSL Certificate: Valid SSL certificate for HTTPS</li> </ul>"},{"location":"getting-started/deployment/#installation","title":"Installation","text":""},{"location":"getting-started/deployment/#1-system-preparation","title":"1. System Preparation","text":"<pre><code># Update system packages\nsudo apt update &amp;&amp; sudo apt upgrade -y\n\n# Install required system packages\nsudo apt install -y python3.12 python3.12-venv python3-pip nginx redis-server\n\n# Create application user\nsudo useradd -m -s /bin/bash lolstonks\nsudo usermod -aG sudo lolstonks\n</code></pre>"},{"location":"getting-started/deployment/#2-application-setup","title":"2. Application Setup","text":"<pre><code># Switch to application user\nsudo su - lolstonks\n\n# Install UV\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nsource ~/.bashrc\n\n# Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Install dependencies\nuv pip install -e \".[docs]\"\n\n# Create environment file\ncp .env.example .env\nnano .env  # Edit with your configuration\n</code></pre>"},{"location":"getting-started/deployment/#3-environment-configuration","title":"3. Environment Configuration","text":"<p>Create a secure <code>.env</code> file:</p> <pre><code># Production Configuration\nRIOT_API_KEY=RGAPI-your-production-api-key\nRIOT_DEFAULT_REGION=euw1\n\n# Server Configuration\nHOST=127.0.0.1\nPORT=8080\nLOG_LEVEL=INFO\nENVIRONMENT=production\n\n# Redis Configuration\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=your-redis-password\n\n# Rate Limiting (adjust based on your API key limits)\nRIOT_RATE_LIMIT_PER_SECOND=20\nRIOT_RATE_LIMIT_PER_2MIN=100\n\n# Security\nCORS_ORIGINS=https://yourdomain.com\nALLOWED_HOSTS=yourdomain.com\n\n# Monitoring\nENABLE_METRICS=true\nMETRICS_PORT=9090\n</code></pre>"},{"location":"getting-started/deployment/#process-management","title":"Process Management","text":""},{"location":"getting-started/deployment/#systemd-service-recommended","title":"Systemd Service (Recommended)","text":"<p>Create a systemd service file:</p> <pre><code>sudo nano /etc/systemd/system/lolstonks-api.service\n</code></pre> <pre><code>[Unit]\nDescription=LOLStonks API Gateway\nAfter=network.target redis.service\n\n[Service]\nType=exec\nUser=lolstonks\nGroup=lolstonks\nWorkingDirectory=/home/lolstonks/lolstonks-api-gateway\nEnvironment=PATH=/home/lolstonks/.local/bin:/usr/local/bin:/usr/bin:/bin\nEnvironmentFile=/home/lolstonks/lolstonks-api-gateway/.env\nExecStart=/home/lolstonks/.local/bin/uv run uvicorn app.main:app --host 0.0.0.0 --port 8080\nRestart=always\nRestartSec=10\nStandardOutput=journal\nStandardError=journal\n\n# Security settings\nNoNewPrivileges=true\nPrivateTmp=true\nProtectSystem=strict\nProtectHome=true\nReadWritePaths=/home/lolstonks/lolstonks-api-gateway/logs\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Enable and start the service:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable lolstonks-api.service\nsudo systemctl start lolstonks-api.service\n</code></pre>"},{"location":"getting-started/deployment/#supervisor-alternative","title":"Supervisor Alternative","text":"<p>If using supervisor, create <code>/etc/supervisor/conf.d/lolstonks-api.conf</code>:</p> <pre><code>[program:lolstonks-api]\ncommand=/home/lolstonks/.local/bin/uv run uvicorn app.main:app --host 0.0.0.0 --port 8080\ndirectory=/home/lolstonks/lolstonks-api-gateway\nuser=lolstonks\nautostart=true\nautorestart=true\nredirect_stderr=true\nstdout_logfile=/var/log/lolstonks/api.log\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nenvironment=PATH=\"/home/lolstonks/.local/bin:/usr/local/bin\"\n</code></pre>"},{"location":"getting-started/deployment/#reverse-proxy-configuration","title":"Reverse Proxy Configuration","text":""},{"location":"getting-started/deployment/#nginx-configuration","title":"Nginx Configuration","text":"<p>Create <code>/etc/nginx/sites-available/lolstonks-api</code>:</p> <pre><code>server {\n    listen 80;\n    server_name yourdomain.com www.yourdomain.com;\n    return 301 https://$server_name$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name yourdomain.com www.yourdomain.com;\n\n    # SSL Configuration\n    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n\n    # Security Headers\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\";\n\n    # Rate Limiting\n    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n    limit_req zone=api burst=20 nodelay;\n\n    location / {\n        proxy_pass http://127.0.0.1:8080;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Timeouts\n        proxy_connect_timeout 30s;\n        proxy_send_timeout 30s;\n        proxy_read_timeout 30s;\n\n        # Buffer settings\n        proxy_buffering on;\n        proxy_buffer_size 4k;\n        proxy_buffers 8 4k;\n    }\n\n    # Health endpoint (no rate limiting)\n    location /health {\n        proxy_pass http://127.0.0.1:8080/health;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n\n    # API documentation\n    location /docs {\n        proxy_pass http://127.0.0.1:8080/docs;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre> <p>Enable the site:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/lolstonks-api /etc/nginx/sites-enabled/\nsudo nginx -t\nsudo systemctl reload nginx\n</code></pre>"},{"location":"getting-started/deployment/#redis-configuration","title":"Redis Configuration","text":""},{"location":"getting-started/deployment/#production-redis-setup","title":"Production Redis Setup","text":"<p>Edit <code>/etc/redis/redis.conf</code>:</p> <pre><code># Security\nbind 127.0.0.1\nrequirepass your-redis-password\nport 6379\n\n# Memory management\nmaxmemory 2gb\nmaxmemory-policy allkeys-lru\n\n# Persistence\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# Logging\nlogfile /var/log/redis/redis-server.log\nloglevel notice\n\n# Performance\ntcp-keepalive 300\ntimeout 0\n</code></pre> <p>Restart Redis:</p> <pre><code>sudo systemctl restart redis-server\nsudo systemctl enable redis-server\n</code></pre>"},{"location":"getting-started/deployment/#ssl-certificate-setup","title":"SSL Certificate Setup","text":""},{"location":"getting-started/deployment/#lets-encrypt-recommended","title":"Let's Encrypt (Recommended)","text":"<pre><code># Install certbot\nsudo apt install certbot python3-certbot-nginx\n\n# Obtain certificate\nsudo certbot --nginx -d yourdomain.com -d www.yourdomain.com\n\n# Set up auto-renewal\nsudo crontab -e\n# Add this line:\n0 12 * * * /usr/bin/certbot renew --quiet\n</code></pre>"},{"location":"getting-started/deployment/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"getting-started/deployment/#log-management","title":"Log Management","text":"<p>Create log directories:</p> <pre><code>sudo mkdir -p /var/log/lolstonks\nsudo chown lolstonks:lolstonks /var/log/lolstonks\n</code></pre> <p>Configure log rotation:</p> <pre><code>sudo nano /etc/logrotate.d/lolstonks-api\n</code></pre> <pre><code>/var/log/lolstonks/*.log {\n    daily\n    missingok\n    rotate 30\n    compress\n    delaycompress\n    notifempty\n    create 644 lolstonks lolstonks\n    postrotate\n        systemctl reload lolstonks-api.service\n    endscript\n}\n</code></pre>"},{"location":"getting-started/deployment/#health-monitoring","title":"Health Monitoring","text":"<p>Set up monitoring for the health endpoint:</p> <pre><code># Simple monitoring script\ncat &gt; /home/lolstonks/health_check.sh &lt;&lt; 'EOF'\n#!/bin/bash\nHEALTH_URL=\"http://127.0.0.1:8080/health\"\nRESPONSE=$(curl -s -o /dev/null -w \"%{http_code}\" $HEALTH_URL)\n\nif [ $RESPONSE -ne 200 ]; then\n    echo \"Health check failed with status $RESPONSE\"\n    # Send alert (configure your preferred alerting method)\n    systemctl restart lolstonks-api.service\nfi\nEOF\n\nchmod +x /home/lolstonks/health_check.sh\n\n# Add to crontab for monitoring every minute\necho \"* * * * * /home/lolstonks/health_check.sh\" | crontab -u lolstonks -\n</code></pre>"},{"location":"getting-started/deployment/#performance-optimization","title":"Performance Optimization","text":""},{"location":"getting-started/deployment/#system-tuning","title":"System Tuning","text":"<pre><code># Increase file descriptor limits\necho \"lolstonks soft nofile 65536\" | sudo tee -a /etc/security/limits.conf\necho \"lolstonks hard nofile 65536\" | sudo tee -a /etc/security/limits.conf\n\n# Optimize network settings\necho \"net.core.somaxconn = 65535\" | sudo tee -a /etc/sysctl.conf\necho \"net.ipv4.tcp_max_syn_backlog = 65535\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -p\n</code></pre>"},{"location":"getting-started/deployment/#application-performance","title":"Application Performance","text":"<p>Update <code>.env</code> for production:</p> <pre><code># Performance settings\nUVICORN_WORKERS=4  # Number of worker processes\nUVICORN_WORKER_CONNECTIONS=1000\nUVICORN_BACKLOG=2048\n\n# Caching settings\nCACHE_TTL_SUMMONER=3600    # 1 hour\nCACHE_TTL_MATCH=86400      # 24 hours\nCACHE_TTL_LEAGUE=1800      # 30 minutes\n</code></pre>"},{"location":"getting-started/deployment/#security-hardening","title":"Security Hardening","text":""},{"location":"getting-started/deployment/#firewall-configuration","title":"Firewall Configuration","text":"<pre><code># Configure UFW firewall\nsudo ufw enable\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\n\n# Allow SSH (change port if needed)\nsudo ufw allow ssh\n\n# Allow HTTP/HTTPS\nsudo ufw allow 80\nsudo ufw allow 443\n\n# Allow Redis only locally\nsudo ufw allow from 127.0.0.1 to any port 6379\n</code></pre>"},{"location":"getting-started/deployment/#application-security","title":"Application Security","text":"<ol> <li>API Key Rotation: Implement regular API key rotation</li> <li>Input Validation: Ensure all inputs are validated (handled by Pydantic)</li> <li>Rate Limiting: Configure appropriate rate limits</li> <li>Access Controls: Implement IP whitelisting if needed</li> <li>Regular Updates: Keep system and dependencies updated</li> </ol>"},{"location":"getting-started/deployment/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"getting-started/deployment/#configuration-backup","title":"Configuration Backup","text":"<pre><code># Create backup script\ncat &gt; /home/lolstonks/backup.sh &lt;&lt; 'EOF'\n#!/bin/bash\nBACKUP_DIR=\"/home/lolstonks/backups\"\nDATE=$(date +%Y%m%d_%H%M%S)\n\nmkdir -p $BACKUP_DIR\n\n# Backup configuration\ntar -czf $BACKUP_DIR/config_$DATE.tar.gz \\\n    /home/lolstonks/lolstonks-api-gateway/.env \\\n    /etc/nginx/sites-available/lolstonks-api \\\n    /etc/systemd/system/lolstonks-api.service\n\n# Keep last 7 days\nfind $BACKUP_DIR -name \"config_*.tar.gz\" -mtime +7 -delete\nEOF\n\nchmod +x /home/lolstonks/backup.sh\n\n# Add to crontab for daily backup at 2 AM\necho \"0 2 * * * /home/lolstonks/backup.sh\" | crontab -u lolstonks -\n</code></pre>"},{"location":"getting-started/deployment/#disaster-recovery","title":"Disaster Recovery","text":"<ol> <li>Documentation: Keep deployment documentation updated</li> <li>Monitoring: Set up alerts for service failures</li> <li>Backups: Regular configuration and code backups</li> <li>Testing: Regular disaster recovery testing</li> </ol>"},{"location":"getting-started/deployment/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"getting-started/deployment/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>For high-traffic deployments:</p> <ol> <li>Load Balancer: Use HAProxy or cloud load balancer</li> <li>Multiple Instances: Run multiple API gateway instances</li> <li>Redis Cluster: Use Redis cluster for distributed caching</li> <li>Database Sharding: Consider database sharding if needed</li> </ol>"},{"location":"getting-started/deployment/#performance-monitoring","title":"Performance Monitoring","text":"<p>Monitor key metrics: - Request rate and response times - Error rates and types - Cache hit rates - Memory and CPU usage - Redis performance</p>"},{"location":"getting-started/deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/deployment/#common-issues","title":"Common Issues","text":"<ol> <li>Service Won't Start: Check logs with <code>journalctl -u lolstonks-api.service</code></li> <li>High Memory Usage: Check Redis memory usage and adjust limits</li> <li>Slow Responses: Check rate limiting and cache performance</li> <li>API Errors: Verify Riot API key and rate limits</li> </ol>"},{"location":"getting-started/deployment/#debug-commands","title":"Debug Commands","text":"<pre><code># Check service status\nsudo systemctl status lolstonks-api.service\n\n# View logs\nsudo journalctl -u lolstonks-api.service -f\n\n# Check Redis\nredis-cli -a your-password ping\n\n# Test API locally\ncurl http://127.0.0.1:8080/health\n\n# Check Nginx configuration\nsudo nginx -t\n\n# Monitor system resources\nhtop\niostat -x 1\n</code></pre> <p>This deployment guide provides a comprehensive foundation for running the LOLStonks API Gateway in production with proper security, monitoring, and scalability considerations.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers different installation methods for the LOLStonks API Gateway.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+ - The gateway requires Python 3.12 or higher</li> <li>Redis Server - Required for caching and match tracking</li> <li>Riot Developer API Key - Get one at developer.riotgames.com</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-using-uv-recommended","title":"Method 1: Using UV (Recommended)","text":"<p>UV is a fast Python package installer and resolver.</p> <pre><code># Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Install the project with documentation dependencies\nuv pip install -e \".[docs]\"\n\n# Activate the virtual environment\nsource .venv/bin/activate  # On Linux/macOS\n# or\n.venv\\Scripts\\activate     # On Windows\n</code></pre>"},{"location":"getting-started/installation/#method-2-using-pip","title":"Method 2: Using Pip","text":"<pre><code># Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Create virtual environment\npython -m venv .venv\n\n# Activate virtual environment\nsource .venv/bin/activate  # On Linux/macOS\n# or\n.venv\\Scripts\\activate     # On Windows\n\n# Upgrade pip\npip install --upgrade pip\n\n# Install the project in development mode\npip install -e \".[docs]\"\n</code></pre>"},{"location":"getting-started/installation/#method-3-docker-quick-start","title":"Method 3: Docker (Quick Start)","text":"<pre><code># Clone the repository\ngit clone https://github.com/OneStepAt4time/lolstonks-api-gateway.git\ncd lolstonks-api-gateway\n\n# Copy environment file\ncp .env.example .env\n\n# Edit .env with your Riot API key\n# nano .env\n\n# Start with Docker Compose\ndocker-compose up -d\n\n# Check logs\ndocker-compose logs -f\n</code></pre>"},{"location":"getting-started/installation/#redis-setup","title":"Redis Setup","text":""},{"location":"getting-started/installation/#option-1-docker-recommended-for-development","title":"Option 1: Docker (Recommended for Development)","text":"<pre><code># Start Redis with Docker\ndocker run -d --name redis -p 6379:6379 redis:7-alpine\n\n# Or use Docker Compose (included in project)\ndocker-compose up -d redis\n</code></pre>"},{"location":"getting-started/installation/#option-2-local-installation","title":"Option 2: Local Installation","text":"<pre><code># On Ubuntu/Debian\nsudo apt-get install redis-server\n\n# On macOS with Homebrew\nbrew install redis\n\n# On Windows\n# Download and install Redis from https://redis.io/download\n</code></pre>"},{"location":"getting-started/installation/#option-3-redis-cloud","title":"Option 3: Redis Cloud","text":"<p>For production deployments, consider using managed Redis services: - Redis Cloud - AWS ElastiCache - Azure Cache for Redis</p>"},{"location":"getting-started/installation/#riot-api-key-setup","title":"Riot API Key Setup","text":"<ol> <li>Visit Riot Developer Portal</li> <li>Sign in with your Riot Games account</li> <li>Create a new API key</li> <li>Copy your API key (starts with <code>RGAPI-</code>)</li> </ol>"},{"location":"getting-started/installation/#environment-configuration","title":"Environment Configuration","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code># Required\nRIOT_API_KEY=RGAPI-your-api-key-here\n\n# Optional (defaults shown)\nRIOT_DEFAULT_REGION=euw1\nREDIS_HOST=redis\nREDIS_PORT=6379\nREDIS_DB=0\nREDIS_PASSWORD=\nHOST=0.0.0.0\nPORT=8080\nLOG_LEVEL=INFO\n\n# Rate limiting (requests per second)\nRATE_LIMIT_RPS=20\nRATE_LIMIT_BURST=100\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":""},{"location":"getting-started/installation/#check-python-environment","title":"Check Python Environment","text":"<pre><code>python --version  # Should show Python 3.12+\npip list | grep fastapi  # Should show FastAPI installed\n</code></pre>"},{"location":"getting-started/installation/#check-redis-connection","title":"Check Redis Connection","text":"<pre><code># Test Redis connection\nredis-cli ping\n# Should return: PONG\n</code></pre>"},{"location":"getting-started/installation/#test-application","title":"Test Application","text":"<pre><code># Start the application\npython -m app.main\n\n# In another terminal, test health endpoint\ncurl http://localhost:8080/health\n# Should return: {\"status\":\"ok\"}\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Python Version Error <pre><code># Error: Python 3.12+ required\npython --version  # Check your Python version\n# Install Python 3.12+ from python.org or pyenv\n</code></pre></p> </li> <li> <p>Redis Connection Failed <pre><code># Check if Redis is running\nredis-cli ping\n\n# Check connection settings in .env\n# Ensure REDIS_HOST and REDIS_PORT are correct\n</code></pre></p> </li> <li> <p>Import Errors <pre><code># Reinstall dependencies (using UV - recommended)\nuv pip install -e \".[docs]\"\n# or using pip:\npip install -e \".[docs]\"\n\n# Check virtual environment activation\nwhich python  # Should point to your venv\n</code></pre></p> </li> <li> <p>Permission Errors <pre><code># On Linux/macOS, check file permissions\nchmod +x scripts/*.py\n\n# On Windows, run as administrator if needed\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues during installation:</p> <ol> <li>Check the GitHub Issues</li> <li>Review the Troubleshooting Guide</li> <li>Create a new issue with:</li> <li>Your operating system</li> <li>Python version</li> <li>Error messages</li> <li>Steps to reproduce</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Read the Quick Start guide</li> <li>Configure your environment variables</li> <li>Explore the API Reference</li> <li>Set up development tools</li> </ol>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with the LOLStonks API Gateway in minutes.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>\u2705 Installation completed (see Installation Guide)</li> <li>\u2705 Redis server running</li> <li>\u2705 Riot API key configured in <code>.env</code></li> </ul>"},{"location":"getting-started/quick-start/#start-the-gateway","title":"Start the Gateway","text":""},{"location":"getting-started/quick-start/#option-1-development-mode","title":"Option 1: Development Mode","text":"<pre><code># Activate virtual environment\nsource .venv/bin/activate  # Linux/macOS\n# or\n.venv\\Scripts\\activate     # Windows\n\n# Start the server\npython -m app.main\n</code></pre>"},{"location":"getting-started/quick-start/#option-2-production-mode","title":"Option 2: Production Mode","text":"<pre><code># Using uvicorn directly\nuvicorn app.main:app --host 0.0.0.0 --port 8080\n\n# Using gunicorn (production)\ngunicorn app.main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8080\n</code></pre>"},{"location":"getting-started/quick-start/#option-3-docker","title":"Option 3: Docker","text":"<pre><code># Using docker-compose\ndocker-compose up -d\n\n# Check logs\ndocker-compose logs -f api-gateway\n</code></pre>"},{"location":"getting-started/quick-start/#verify-installation","title":"Verify Installation","text":""},{"location":"getting-started/quick-start/#health-check","title":"Health Check","text":"<pre><code>curl http://localhost:8080/health\n# Expected response: {\"status\":\"ok\"}\n</code></pre>"},{"location":"getting-started/quick-start/#interactive-documentation","title":"Interactive Documentation","text":"<p>Open your browser and navigate to: - Swagger UI: http://localhost:8080/docs - ReDoc: http://localhost:8080/redoc</p>"},{"location":"getting-started/quick-start/#basic-usage-examples","title":"Basic Usage Examples","text":""},{"location":"getting-started/quick-start/#1-get-summoner-information","title":"1. Get Summoner Information","text":"<pre><code># Get summoner by name\ncurl \"http://localhost:8080/summoner/by-name/Faker?region=kr\"\n\n# Response example\n{\n  \"id\": \"KqOw12p4b3bLp5b6p7\",\n  \"accountId\": \"3b3Lp5b6p7KqOw12p4b\",\n  \"puuid\": \"p7KqOw12p4b3bLp5b6p7\",\n  \"name\": \"Faker\",\n  \"profileIconId\": 3188,\n  \"revisionDate\": 1678901234567,\n  \"summonerLevel\": 523\n}\n</code></pre>"},{"location":"getting-started/quick-start/#2-get-current-match","title":"2. Get Current Match","text":"<pre><code># Get active game for a summoner\ncurl \"http://localhost:8080/spectator/active-game/KqOw12p4b3bLp5b6p7?region=kr\"\n\n# Response contains game information\n{\n  \"gameId\": 1234567890,\n  \"gameMode\": \"CLASSIC\",\n  \"gameQueueConfigId\": 420,\n  \"participants\": [...],\n  \"gameLength\": 542,\n  \"gameStartTime\": 1678901234567\n}\n</code></pre>"},{"location":"getting-started/quick-start/#3-get-match-history","title":"3. Get Match History","text":"<pre><code># Get recent match IDs\ncurl \"http://localhost:8080/match/ids/by-puuid/p7KqOw12p4b3bLp5b6p7?region=kr&amp;count=5\"\n\n# Response: Array of match IDs\n[\"KR_1234567890\", \"KR_1234567891\", \"KR_1234567892\", \"KR_1234567893\", \"KR_1234567894\"]\n</code></pre>"},{"location":"getting-started/quick-start/#4-get-league-information","title":"4. Get League Information","text":"<pre><code># Get challenger league\ncurl \"http://localhost:8080/league/challenger/RANKED_SOLO_5x5?region=kr\"\n\n# Get master league\ncurl \"http://localhost:8080/league/master/RANKED_SOLO_5x5?region=kr\"\n</code></pre>"},{"location":"getting-started/quick-start/#5-get-champion-mastery","title":"5. Get Champion Mastery","text":"<pre><code># Get top masteries for summoner\ncurl \"http://localhost:8080/champion-mastery/top/KqOw12p4b3bLp5b6p7?region=kr&amp;count=5\"\n\n# Get mastery for specific champion\ncurl \"http://localhost:8080/champion-mastery/by-champion/KqOw12p4b3bLp5b6p7/157?region=kr\"\n</code></pre>"},{"location":"getting-started/quick-start/#python-client-examples","title":"Python Client Examples","text":""},{"location":"getting-started/quick-start/#using-httpx-recommended","title":"Using httpx (Recommended)","text":"<pre><code>import httpx\nimport asyncio\n\nasync def get_summoner_data():\n    \"\"\"Get basic summoner information\"\"\"\n    async with httpx.AsyncClient() as client:\n        # Get summoner by name\n        response = await client.get(\n            \"http://localhost:8080/summoner/by-name/Faker\",\n            params={\"region\": \"kr\"}\n        )\n        summoner = response.json()\n        print(f\"Summoner: {summoner['name']} (Level: {summoner['summonerLevel']})\")\n\n        # Get current match\n        response = await client.get(\n            f\"http://localhost:8080/spectator/active-game/{summoner['id']}\",\n            params={\"region\": \"kr\"}\n        )\n\n        if response.status_code == 200:\n            game = response.json()\n            print(f\"Currently in game: {game['gameMode']}\")\n        else:\n            print(\"Not currently in a game\")\n\n# Run the example\nasyncio.run(get_summoner_data())\n</code></pre>"},{"location":"getting-started/quick-start/#using-requests-synchronous","title":"Using requests (Synchronous)","text":"<pre><code>import requests\n\ndef get_league_data():\n    \"\"\"Get challenger league information\"\"\"\n    response = requests.get(\n        \"http://localhost:8080/league/challenger/RANKED_SOLO_5x5\",\n        params={\"region\": \"euw1\"}\n    )\n\n    if response.status_code == 200:\n        league = response.json()\n        print(f\"League: {league['name']}\")\n        print(f\"Tier: {league['tier']}\")\n        print(f\"Number of players: {len(league['entries'])}\")\n\n        # Show top 3 players\n        for i, entry in enumerate(league['entries'][:3], 1):\n            print(f\"{i}. {entry['summonerName']} - {entry['leaguePoints']} LP\")\n\nget_league_data()\n</code></pre>"},{"location":"getting-started/quick-start/#common-operations","title":"Common Operations","text":""},{"location":"getting-started/quick-start/#batch-operations","title":"Batch Operations","text":"<pre><code>import asyncio\nimport httpx\n\nasync def get_multiple_summoners(names, region=\"kr\"):\n    \"\"\"Get data for multiple summoners concurrently\"\"\"\n    async with httpx.AsyncClient() as client:\n        tasks = []\n        for name in names:\n            task = client.get(\n                \"http://localhost:8080/summoner/by-name/\" + name,\n                params={\"region\": region}\n            )\n            tasks.append(task)\n\n        responses = await asyncio.gather(*tasks)\n        return [r.json() for r in responses if r.status_code == 200]\n\n# Usage\nsummoners = asyncio.run(get_multiple_summoners([\"Faker\", \"ShowMaker\", \"Canyon\"]))\nfor summoner in summoners:\n    print(f\"{summoner['name']}: Level {summoner['summonerLevel']}\")\n</code></pre>"},{"location":"getting-started/quick-start/#error-handling","title":"Error Handling","text":"<pre><code>import httpx\n\nasync def safe_api_call(endpoint, params=None):\n    \"\"\"Safe API call with error handling\"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"http://localhost:8080{endpoint}\",\n                params=params\n            )\n            response.raise_for_status()\n            return response.json()\n\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            print(\"Resource not found\")\n        elif e.response.status_code == 429:\n            print(\"Rate limit exceeded - please wait\")\n        elif e.response.status_code == 503:\n            print(\"Service temporarily unavailable\")\n        else:\n            print(f\"HTTP error: {e.response.status_code}\")\n        return None\n\n    except httpx.RequestError as e:\n        print(f\"Request error: {e}\")\n        return None\n\n# Usage\ndata = await safe_api_call(\"/summoner/by-name/Faker\", {\"region\": \"kr\"})\nif data:\n    print(f\"Successfully retrieved: {data['name']}\")\n</code></pre>"},{"location":"getting-started/quick-start/#monitoring-the-gateway","title":"Monitoring the Gateway","text":""},{"location":"getting-started/quick-start/#health-checks","title":"Health Checks","text":"<pre><code># Basic health check\ncurl http://localhost:8080/health\n\n# Check specific endpoints\ncurl http://localhost:8080/docs  # Should load Swagger UI\ncurl http://localhost:8080/redoc  # Should load ReDoc\n</code></pre>"},{"location":"getting-started/quick-start/#log-monitoring","title":"Log Monitoring","text":"<pre><code># View application logs\npython -m app.main  # Logs will appear in console\n\n# Or use docker logs if running with Docker\ndocker-compose logs -f api-gateway\n</code></pre>"},{"location":"getting-started/quick-start/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use Appropriate Cache TTLs: Configure cache durations based on data volatility</li> <li>Batch Requests: Use concurrent requests for multiple API calls</li> <li>Region Selection: Use the correct region parameter for optimal performance</li> <li>Error Handling: Implement proper retry logic and error handling</li> <li>Rate Limit Awareness: Be mindful of Riot's rate limits</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Configuration Guide for advanced settings</li> <li>Explore the complete API Reference</li> <li>Set up development tools</li> <li>Review the Architecture Overview</li> </ul>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues:</p> <ol> <li>Connection Refused: Check if the gateway is running on the correct port</li> <li>401 Unauthorized: Verify your Riot API key in the <code>.env</code> file</li> <li>404 Not Found: Check the endpoint path and parameters</li> <li>429 Rate Limited: The gateway handles this automatically, but you may need to wait</li> <li>503 Service Unavailable: Riot API may be temporarily down</li> </ol> <p>For more help, see the Development Documentation.</p>"},{"location":"operations/monitoring/","title":"Monitoring and Observability","text":"<p>This guide covers monitoring, logging, and observability for the LOLStonks API Gateway in production environments.</p>"},{"location":"operations/monitoring/#overview","title":"Overview","text":"<p>Effective monitoring ensures: - Proactive Issue Detection: Identify problems before users notice - Performance Optimization: Track and optimize system performance - Capacity Planning: Understand resource usage and scaling needs - Security Monitoring: Detect unusual activity and potential threats</p>"},{"location":"operations/monitoring/#core-monitoring-components","title":"Core Monitoring Components","text":""},{"location":"operations/monitoring/#1-application-metrics","title":"1. Application Metrics","text":""},{"location":"operations/monitoring/#key-performance-indicators-kpis","title":"Key Performance Indicators (KPIs)","text":"Metric Description Target Alert Threshold Request Rate API requests per second Variable &gt; 1000 req/s Response Time Average API response time &lt; 200ms &gt; 500ms Error Rate Percentage of failed requests &lt; 1% &gt; 5% Cache Hit Rate Percentage of requests served from cache &gt; 80% &lt; 60% Memory Usage Application memory consumption &lt; 2GB &gt; 3GB CPU Usage Application CPU utilization &lt; 70% &gt; 85%"},{"location":"operations/monitoring/#custom-metrics-implementation","title":"Custom Metrics Implementation","text":"<pre><code># app/monitoring.py\nfrom prometheus_client import Counter, Histogram, Gauge, generate_latest\nimport time\nimport logging\n\n# Define metrics\nREQUEST_COUNT = Counter(\n    'lolstonks_requests_total',\n    'Total number of API requests',\n    ['method', 'endpoint', 'status']\n)\n\nREQUEST_DURATION = Histogram(\n    'lolstonks_request_duration_seconds',\n    'Request duration in seconds',\n    ['method', 'endpoint']\n)\n\nCACHE_HIT_RATE = Gauge(\n    'lolstonks_cache_hit_rate',\n    'Cache hit rate percentage'\n)\n\nACTIVE_CONNECTIONS = Gauge(\n    'lolstonks_active_connections',\n    'Number of active connections'\n)\n\nclass MetricsMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] == \"http\":\n            start_time = time.time()\n\n            # Process request\n            await self.app(scope, receive, send)\n\n            # Record metrics\n            duration = time.time() - start_time\n            REQUEST_DURATION.labels(\n                method=scope[\"method\"],\n                endpoint=scope[\"path\"]\n            ).observe(duration)\n\n            REQUEST_COUNT.labels(\n                method=scope[\"method\"],\n                endpoint=scope[\"path\"],\n                status=\"200\"  # Would be set from actual response\n            ).inc()\n        else:\n            await self.app(scope, receive, send)\n</code></pre>"},{"location":"operations/monitoring/#2-health-checks","title":"2. Health Checks","text":""},{"location":"operations/monitoring/#comprehensive-health-endpoint","title":"Comprehensive Health Endpoint","text":"<pre><code># app/health.py\nfrom fastapi import APIRouter, Depends\nfrom app.cache.redis_cache import RedisCache\nfrom app.riot.client import RiotClient\nimport asyncio\nimport time\n\nrouter = APIRouter()\n\n@router.get(\"/health\")\nasync def health_check():\n    \"\"\"Comprehensive health check endpoint.\"\"\"\n    start_time = time.time()\n\n    health_status = {\n        \"status\": \"healthy\",\n        \"timestamp\": time.time(),\n        \"version\": \"1.0.0\",\n        \"checks\": {},\n        \"duration_ms\": 0\n    }\n\n    # Check Redis\n    try:\n        redis_health = await check_redis_health()\n        health_status[\"checks\"][\"redis\"] = redis_health\n    except Exception as e:\n        health_status[\"checks\"][\"redis\"] = {\n            \"status\": \"unhealthy\",\n            \"error\": str(e)\n        }\n        health_status[\"status\"] = \"degraded\"\n\n    # Check Riot API connectivity\n    try:\n        riot_health = await check_riot_api_health()\n        health_status[\"checks\"][\"riot_api\"] = riot_health\n    except Exception as e:\n        health_status[\"checks\"][\"riot_api\"] = {\n            \"status\": \"unhealthy\",\n            \"error\": str(e)\n        }\n        health_status[\"status\"] = \"degraded\"\n\n    # Check system resources\n    try:\n        system_health = check_system_health()\n        health_status[\"checks\"][\"system\"] = system_health\n    except Exception as e:\n        health_status[\"checks\"][\"system\"] = {\n            \"status\": \"unhealthy\",\n            \"error\": str(e)\n        }\n        health_status[\"status\"] = \"unhealthy\"\n\n    health_status[\"duration_ms\"] = int((time.time() - start_time) * 1000)\n\n    return health_status\n\nasync def check_redis_health():\n    \"\"\"Check Redis connectivity and performance.\"\"\"\n    cache = RedisCache()\n\n    # Test basic connectivity\n    start_time = time.time()\n    await cache.set(\"health_check\", \"ok\", ttl=10)\n    result = await cache.get(\"health_check\")\n    duration = time.time() - start_time\n\n    if result != \"ok\":\n        raise Exception(\"Redis read/write test failed\")\n\n    # Get Redis info\n    import redis\n    redis_client = redis.Redis(\n        host=cache.redis_host,\n        port=cache.redis_port,\n        password=cache.redis_password,\n        decode_responses=True\n    )\n\n    info = redis_client.info()\n\n    return {\n        \"status\": \"healthy\",\n        \"response_time_ms\": int(duration * 1000),\n        \"memory_usage\": info.get(\"used_memory_human\"),\n        \"connected_clients\": info.get(\"connected_clients\"),\n        \"uptime_seconds\": info.get(\"uptime_in_seconds\")\n    }\n\nasync def check_riot_api_health():\n    \"\"\"Check Riot API connectivity.\"\"\"\n    client = RiotClient()\n\n    start_time = time.time()\n    response = await client.get(\n        \"/lol/status/v4/platform-data\",\n        region=\"na1\"\n    )\n    duration = time.time() - start_time\n\n    if response.status_code != 200:\n        raise Exception(f\"Riot API returned status {response.status_code}\")\n\n    return {\n        \"status\": \"healthy\",\n        \"response_time_ms\": int(duration * 1000),\n        \"status_code\": response.status_code\n    }\n\ndef check_system_health():\n    \"\"\"Check system resources.\"\"\"\n    import psutil\n\n    # CPU usage\n    cpu_percent = psutil.cpu_percent(interval=1)\n\n    # Memory usage\n    memory = psutil.virtual_memory()\n    disk = psutil.disk_usage('/')\n\n    # Network connections\n    connections = len(psutil.net_connections())\n\n    system_health = {\n        \"status\": \"healthy\",\n        \"cpu_percent\": cpu_percent,\n        \"memory_percent\": memory.percent,\n        \"memory_available_gb\": round(memory.available / (1024**3), 2),\n        \"disk_percent\": disk.percent,\n        \"disk_free_gb\": round(disk.free / (1024**3), 2),\n        \"network_connections\": connections\n    }\n\n    # Determine overall status\n    if cpu_percent &gt; 90 or memory.percent &gt; 90 or disk.percent &gt; 90:\n        system_health[\"status\"] = \"critical\"\n    elif cpu_percent &gt; 80 or memory.percent &gt; 80 or disk.percent &gt; 80:\n        system_health[\"status\"] = \"warning\"\n\n    return system_health\n</code></pre>"},{"location":"operations/monitoring/#3-logging-strategy","title":"3. Logging Strategy","text":""},{"location":"operations/monitoring/#structured-logging-configuration","title":"Structured Logging Configuration","text":"<pre><code># app/logging_config.py\nimport logging\nimport json\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\n\nclass JSONFormatter(logging.Formatter):\n    def format(self, record):\n        log_entry = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"message\": record.getMessage(),\n            \"module\": record.module,\n            \"function\": record.funcName,\n            \"line\": record.lineno\n        }\n\n        # Add exception info if present\n        if record.exc_info:\n            log_entry[\"exception\"] = self.formatException(record.exc_info)\n\n        # Add extra fields\n        for key, value in record.__dict__.items():\n            if key not in ['name', 'msg', 'args', 'levelname', 'levelno',\n                          'pathname', 'filename', 'module', 'exc_info',\n                          'exc_text', 'stack_info', 'lineno', 'funcName',\n                          'created', 'msecs', 'relativeCreated', 'thread',\n                          'threadName', 'processName', 'process', 'message']:\n                log_entry[key] = value\n\n        return json.dumps(log_entry)\n\ndef setup_logging():\n    \"\"\"Configure structured logging for the application.\"\"\"\n\n    # Create logs directory\n    log_dir = Path(\"/var/log/lolstonks\")\n    log_dir.mkdir(exist_ok=True)\n\n    # Configure root logger\n    logging.basicConfig(\n        level=logging.INFO,\n        handlers=[\n            logging.StreamHandler(sys.stdout),\n            logging.FileHandler(log_dir / \"api.log\")\n        ]\n    )\n\n    # Set JSON formatter for all handlers\n    for handler in logging.root.handlers:\n        handler.setFormatter(JSONFormatter())\n\n    # Configure specific loggers\n    loggers = [\n        \"uvicorn.access\",\n        \"uvicorn.error\",\n        \"app.riot.client\",\n        \"app.cache.redis_cache\"\n    ]\n\n    for logger_name in loggers:\n        logger = logging.getLogger(logger_name)\n        logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"operations/monitoring/#request-logging-middleware","title":"Request Logging Middleware","text":"<pre><code># app/middleware.py\nimport time\nimport uuid\nfrom fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nclass RequestLoggingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        # Generate unique request ID\n        request_id = str(uuid.uuid4())\n\n        # Log request start\n        start_time = time.time()\n\n        logger = logging.getLogger(\"request\")\n        logger.info(\n            \"Request started\",\n            extra={\n                \"request_id\": request_id,\n                \"method\": request.method,\n                \"url\": str(request.url),\n                \"client_ip\": request.client.host,\n                \"user_agent\": request.headers.get(\"user-agent\")\n            }\n        )\n\n        try:\n            # Process request\n            response = await call_next(request)\n\n            # Calculate duration\n            duration = time.time() - start_time\n\n            # Log request completion\n            logger.info(\n                \"Request completed\",\n                extra={\n                    \"request_id\": request_id,\n                    \"method\": request.method,\n                    \"url\": str(request.url),\n                    \"status_code\": response.status_code,\n                    \"duration_ms\": int(duration * 1000),\n                    \"response_size\": response.headers.get(\"content-length\", 0)\n                }\n            )\n\n            # Add request ID to response headers\n            response.headers[\"X-Request-ID\"] = request_id\n\n            return response\n\n        except Exception as e:\n            # Log request error\n            duration = time.time() - start_time\n            logger.error(\n                \"Request failed\",\n                extra={\n                    \"request_id\": request_id,\n                    \"method\": request.method,\n                    \"url\": str(request.url),\n                    \"duration_ms\": int(duration * 1000),\n                    \"error\": str(e),\n                    \"error_type\": type(e).__name__\n                }\n            )\n            raise\n</code></pre>"},{"location":"operations/monitoring/#monitoring-setup","title":"Monitoring Setup","text":""},{"location":"operations/monitoring/#prometheus-configuration","title":"Prometheus Configuration","text":""},{"location":"operations/monitoring/#prometheusyml","title":"prometheus.yml","text":"<pre><code>global:\n  scrape_interval: 15s\n  evaluation_interval: 15s\n\nrule_files:\n  - \"alert_rules.yml\"\n\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n          - alertmanager:9093\n\nscrape_configs:\n  - job_name: 'lolstonks-api'\n    static_configs:\n      - targets: ['localhost:9090']\n    metrics_path: '/metrics'\n    scrape_interval: 5s\n    scrape_timeout: 5s\n\n  - job_name: 'redis'\n    static_configs:\n      - targets: ['localhost:9121']\n\n  - job_name: 'node'\n    static_configs:\n      - targets: ['localhost:9100']\n</code></pre>"},{"location":"operations/monitoring/#alert-rules","title":"Alert Rules","text":"<pre><code># alert_rules.yml\ngroups:\n  - name: lolstonks_alerts\n    rules:\n      - alert: HighErrorRate\n        expr: rate(lolstonks_requests_total{status!~\"2..\"}[5m]) / rate(lolstonks_requests_total[5m]) &gt; 0.05\n        for: 2m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High error rate detected\"\n          description: \"Error rate is {{ $value | humanizePercentage }} for the last 5 minutes\"\n\n      - alert: HighResponseTime\n        expr: histogram_quantile(0.95, rate(lolstonks_request_duration_seconds_bucket[5m])) &gt; 0.5\n        for: 2m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High response time detected\"\n          description: \"95th percentile response time is {{ $value }}s\"\n\n      - alert: LowCacheHitRate\n        expr: lolstonks_cache_hit_rate &lt; 0.6\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Low cache hit rate\"\n          description: \"Cache hit rate is {{ $value | humanizePercentage }}\"\n\n      - alert: HighMemoryUsage\n        expr: process_resident_memory_bytes / 1024 / 1024 &gt; 3000\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High memory usage\"\n          description: \"Memory usage is {{ $value }}MB\"\n\n      - alert: ServiceDown\n        expr: up{job=\"lolstonks-api\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Service is down\"\n          description: \"LOLStonks API Gateway has been down for more than 1 minute\"\n</code></pre>"},{"location":"operations/monitoring/#grafana-dashboard","title":"Grafana Dashboard","text":""},{"location":"operations/monitoring/#dashboard-configuration","title":"Dashboard Configuration","text":"<pre><code>{\n  \"dashboard\": {\n    \"id\": null,\n    \"title\": \"LOLStonks API Gateway\",\n    \"tags\": [\"lolstonks\", \"api\"],\n    \"timezone\": \"browser\",\n    \"panels\": [\n      {\n        \"title\": \"Request Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(lolstonks_requests_total[5m])\",\n            \"legendFormat\": \"{{method}} {{endpoint}}\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Requests/sec\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Response Time\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"histogram_quantile(0.95, rate(lolstonks_request_duration_seconds_bucket[5m]))\",\n            \"legendFormat\": \"95th percentile\"\n          },\n          {\n            \"expr\": \"histogram_quantile(0.50, rate(lolstonks_request_duration_seconds_bucket[5m]))\",\n            \"legendFormat\": \"50th percentile\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Seconds\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Error Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(lolstonks_requests_total{status!~\\\"2..\\\"}[5m]) / rate(lolstonks_requests_total[5m])\",\n            \"legendFormat\": \"Error Rate\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Percentage\",\n            \"max\": 1,\n            \"min\": 0\n          }\n        ]\n      },\n      {\n        \"title\": \"Cache Hit Rate\",\n        \"type\": \"singlestat\",\n        \"targets\": [\n          {\n            \"expr\": \"lolstonks_cache_hit_rate\",\n            \"legendFormat\": \"Cache Hit Rate\"\n          }\n        ],\n        \"valueMaps\": [\n          {\n            \"value\": \"null\",\n            \"text\": \"N/A\"\n          }\n        ],\n        \"thresholds\": \"0.6,0.8\"\n      },\n      {\n        \"title\": \"Memory Usage\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"process_resident_memory_bytes / 1024 / 1024\",\n            \"legendFormat\": \"Memory (MB)\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"MB\"\n          }\n        ]\n      },\n      {\n        \"title\": \"CPU Usage\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(process_cpu_seconds_total[5m]) * 100\",\n            \"legendFormat\": \"CPU %\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Percentage\",\n            \"max\": 100,\n            \"min\": 0\n          }\n        ]\n      }\n    ],\n    \"time\": {\n      \"from\": \"now-1h\",\n      \"to\": \"now\"\n    },\n    \"refresh\": \"5s\"\n  }\n}\n</code></pre>"},{"location":"operations/monitoring/#log-management","title":"Log Management","text":""},{"location":"operations/monitoring/#log-aggregation-with-elk-stack","title":"Log Aggregation with ELK Stack","text":""},{"location":"operations/monitoring/#logstash-configuration","title":"Logstash Configuration","text":"<pre><code># logstash.conf\ninput {\n  file {\n    path =&gt; \"/var/log/lolstonks/api.log\"\n    start_position =&gt; \"beginning\"\n    codec =&gt; json\n  }\n}\n\nfilter {\n  # Parse timestamp\n  date {\n    match =&gt; [ \"timestamp\", \"ISO8601\" ]\n  }\n\n  # Add fields\n  mutate {\n    add_field =&gt; { \"service\" =&gt; \"lolstonks-api\" }\n    add_field =&gt; { \"environment\" =&gt; \"production\" }\n  }\n\n  # Parse request logs\n  if [request_id] {\n    mutate {\n      add_field =&gt; { \"log_type\" =&gt; \"request\" }\n    }\n  }\n\n  # Parse error logs\n  if [level] == \"ERROR\" or [level] == \"CRITICAL\" {\n    mutate {\n      add_field =&gt; { \"log_type\" =&gt; \"error\" }\n    }\n  }\n}\n\noutput {\n  elasticsearch {\n    hosts =&gt; [\"elasticsearch:9200\"]\n    index =&gt; \"lolstonks-logs-%{+YYYY.MM.dd}\"\n  }\n\n  # Also output to stdout for debugging\n  stdout {\n    codec =&gt; rubydebug\n  }\n}\n</code></pre>"},{"location":"operations/monitoring/#kibana-dashboard-configuration","title":"Kibana Dashboard Configuration","text":"<pre><code>// Kibana saved objects for LOLStonks monitoring\n{\n  \"dashboard\": {\n    \"title\": \"LOLStonks Logs\",\n    \"panels\": [\n      {\n        \"title\": \"Request Rate Over Time\",\n        \"type\": \"histogram\",\n        \"query\": \"log_type:request\",\n        \"timeField\": \"@timestamp\"\n      },\n      {\n        \"title\": \"Error Distribution\",\n        \"type\": \"pie\",\n        \"query\": \"level:ERROR OR level:CRITICAL\",\n        \"field\": \"error_type\"\n      },\n      {\n        \"title\": \"Response Time Distribution\",\n        \"type\": \"histogram\",\n        \"query\": \"duration_ms:*\",\n        \"field\": \"duration_ms\"\n      },\n      {\n        \"title\": \"Recent Errors\",\n        \"type\": \"table\",\n        \"query\": \"level:ERROR OR level:CRITICAL\",\n        \"sort\": [\"@timestamp\", \"desc\"],\n        \"columns\": [\"@timestamp\", \"message\", \"request_id\", \"endpoint\"]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"operations/monitoring/#advanced-monitoring","title":"Advanced Monitoring","text":""},{"location":"operations/monitoring/#distributed-tracing-with-opentelemetry","title":"Distributed Tracing with OpenTelemetry","text":"<pre><code># app/tracing.py\nfrom opentelemetry import trace\nfrom opentelemetry.exporter.jaeger.thrift import JaegerExporter\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\nfrom opentelemetry.instrumentation.fastapi import FastAPIInstrumentor\nfrom opentelemetry.instrumentation.httpx import HTTPXClientInstrumentor\nfrom opentelemetry.instrumentation.redis import RedisInstrumentor\n\ndef setup_tracing():\n    \"\"\"Configure OpenTelemetry tracing.\"\"\"\n\n    # Set up tracer\n    trace.set_tracer_provider(TracerProvider())\n    tracer = trace.get_tracer(__name__)\n\n    # Configure Jaeger exporter\n    jaeger_exporter = JaegerExporter(\n        agent_host_name=\"localhost\",\n        agent_port=6831,\n    )\n\n    # Add span processor\n    span_processor = BatchSpanProcessor(jaeger_exporter)\n    trace.get_tracer_provider().add_span_processor(span_processor)\n\n    # Instrument FastAPI\n    FastAPIInstrumentor.instrument()\n\n    # Instrument HTTP clients\n    HTTPXClientInstrumentor.instrument()\n\n    # Instrument Redis\n    RedisInstrumentor.instrument()\n</code></pre>"},{"location":"operations/monitoring/#custom-metrics","title":"Custom Metrics","text":"<pre><code># app/custom_metrics.py\nfrom prometheus_client import Counter, Histogram, Gauge\nimport time\nimport functools\n\n# Business metrics\nSUMMONER_LOOKUPS = Counter(\n    'lolstonks_summoner_lookups_total',\n    'Total number of summoner lookups',\n    ['region', 'source_type']\n)\n\nMATCH_LOOKUPS = Counter(\n    'lolstonks_match_lookups_total',\n    'Total number of match lookups',\n    ['region', 'queue_type']\n)\n\nAPI_KEY_USAGE = Counter(\n    'lolstonks_api_key_requests_total',\n    'Total requests to Riot API',\n    ['endpoint', 'status_code']\n)\n\nRATE_LIMIT_HITS = Counter(\n    'lolstonks_rate_limit_hits_total',\n    'Number of rate limit hits',\n    ['endpoint', 'region']\n)\n\ndef timed(histogram):\n    \"\"\"Decorator to measure function execution time.\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        async def wrapper(*args, **kwargs):\n            start_time = time.time()\n            try:\n                result = await func(*args, **kwargs)\n                histogram.observe(time.time() - start_time)\n                return result\n            except Exception as e:\n                histogram.observe(time.time() - start_time)\n                raise\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"operations/monitoring/#alerting","title":"Alerting","text":""},{"location":"operations/monitoring/#alert-configuration","title":"Alert Configuration","text":"<pre><code># alerts.yml\ngroups:\n  - name: lolstonks_critical\n    rules:\n      - alert: ServiceDown\n        expr: up{job=\"lolstonks-api\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"LOLStonks API Gateway is down\"\n          description: \"Service has been down for more than 1 minute\"\n\n      - alert: HighErrorRate\n        expr: rate(lolstonks_requests_total{status!~\"2..\"}[5m]) / rate(lolstonks_requests_total[5m]) &gt; 0.1\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High error rate detected\"\n          description: \"Error rate is {{ $value | humanizePercentage }}\"\n\n  - name: lolstonks_warnings\n    rules:\n      - alert: HighResponseTime\n        expr: histogram_quantile(0.95, rate(lolstonks_request_duration_seconds_bucket[5m])) &gt; 1.0\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High response time detected\"\n          description: \"95th percentile response time is {{ $value }}s\"\n\n      - alert: LowCacheHitRate\n        expr: lolstonks_cache_hit_rate &lt; 0.7\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Low cache hit rate\"\n          description: \"Cache hit rate is {{ $value | humanizePercentage }}\"\n</code></pre>"},{"location":"operations/monitoring/#notification-channels","title":"Notification Channels","text":"<pre><code># alertmanager.yml\nglobal:\n  smtp_smarthost: 'localhost:587'\n  smtp_from: 'alerts@yourdomain.com'\n\nroute:\n  group_by: ['alertname']\n  group_wait: 10s\n  group_interval: 10s\n  repeat_interval: 1h\n  receiver: 'web.hook'\n\nreceivers:\n  - name: 'web.hook'\n    email_configs:\n      - to: 'team@yourdomain.com'\n        subject: '[LOLStonks Alert] {{ .GroupLabels.alertname }}'\n        body: |\n          {{ range .Alerts }}\n          Alert: {{ .Annotations.summary }}\n          Description: {{ .Annotations.description }}\n          {{ end }}\n\n    slack_configs:\n      - api_url: 'YOUR_SLACK_WEBHOOK_URL'\n        channel: '#alerts'\n        title: 'LOLStonks Alert'\n        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'\n</code></pre> <p>This comprehensive monitoring setup provides full observability into the LOLStonks API Gateway, enabling proactive issue detection and performance optimization.</p>"},{"location":"operations/security/","title":"Security Best Practices","text":"<p>This guide covers security considerations and best practices for deploying and operating the LOLStonks API Gateway in production environments.</p>"},{"location":"operations/security/#overview","title":"Overview","text":"<p>Security is implemented through multiple layers of protection:</p> <ol> <li>Input Validation: Comprehensive request validation using Pydantic models</li> <li>Rate Limiting: Protection against abuse and DoS attacks</li> <li>Authentication &amp; Authorization: Secure API key management</li> <li>Network Security: Firewall rules and secure communications</li> <li>Monitoring &amp; Auditing: Comprehensive logging and threat detection</li> </ol>"},{"location":"operations/security/#api-key-security","title":"API Key Security","text":""},{"location":"operations/security/#secure-key-management","title":"Secure Key Management","text":""},{"location":"operations/security/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code># Never hardcode API keys in source code\nRIOT_API_KEY=RGAPI-your-secure-api-key\n\n# Use separate keys for different environments\nRIOT_API_KEY_DEV=RGAPI-dev-key\nRIOT_API_KEY_STAGING=RGAPI-staging-key\nRIOT_API_KEY_PROD=RGAPI-production-key\n</code></pre>"},{"location":"operations/security/#key-rotation-strategy","title":"Key Rotation Strategy","text":"<pre><code># app/security.py\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass APIKeyManager:\n    \"\"\"Manages Riot API key rotation and validation.\"\"\"\n\n    def __init__(self):\n        self.current_key = os.getenv(\"RIOT_API_KEY\")\n        self.backup_key = os.getenv(\"RIOT_API_KEY_BACKUP\")\n        self.last_rotation = datetime.now()\n        self.rotation_interval = timedelta(days=20)  # Riot API keys last 30 days\n\n    def get_active_key(self) -&gt; str:\n        \"\"\"Get the currently active API key.\"\"\"\n        # Check if key needs rotation\n        if datetime.now() - self.last_rotation &gt; self.rotation_interval:\n            logger.warning(\"API key rotation recommended\")\n\n        return self.current_key\n\n    def validate_key_format(self, key: str) -&gt; bool:\n        \"\"\"Validate API key format.\"\"\"\n        import re\n        pattern = r'^RGAPI-[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'\n        return bool(re.match(pattern, key))\n</code></pre>"},{"location":"operations/security/#key-storage-best-practices","title":"Key Storage Best Practices","text":"<ol> <li>Use Environment Variables: Never store keys in code or configuration files</li> <li>Separate Environments: Use different keys for dev, staging, and production</li> <li>Regular Rotation: Rotate keys every 20-25 days (Riot API keys expire in 30 days)</li> <li>Backup Keys: Maintain backup keys for failover scenarios</li> <li>Access Control: Limit access to API keys to only necessary personnel</li> </ol>"},{"location":"operations/security/#input-validation-sanitization","title":"Input Validation &amp; Sanitization","text":""},{"location":"operations/security/#pydantic-model-validation","title":"Pydantic Model Validation","text":"<p>All API inputs are validated using Pydantic models:</p> <pre><code># app/models/security.py\nfrom pydantic import BaseModel, Field, validator\nimport re\nfrom typing import Optional\n\nclass SecureSummonerNameParams(BaseModel):\n    \"\"\"Securely validated summoner name parameters.\"\"\"\n\n    summonerName: str = Field(\n        min_length=1,\n        max_length=16,\n        description=\"Summoner name (1-16 characters)\"\n    )\n\n    @validator('summonerName')\n    def validate_summoner_name(cls, v):\n        \"\"\"Validate summoner name format.\"\"\"\n        # Remove potentially dangerous characters\n        cleaned = re.sub(r'[^\\w\\s]', '', v.strip())\n\n        # Check for allowed characters (letters, numbers, spaces)\n        if not re.match(r'^[a-zA-Z0-9\\s]+$', cleaned):\n            raise ValueError('Invalid summoner name format')\n\n        return cleaned\n\nclass SecureRegionQuery(BaseModel):\n    \"\"\"Securely validated region parameters.\"\"\"\n\n    region: str = Field(\n        default=\"euw1\",\n        description=\"Riot API region code\"\n    )\n\n    @validator('region')\n    def validate_region(cls, v):\n        \"\"\"Validate region code against allowed list.\"\"\"\n        allowed_regions = {\n            'euw1', 'eun1', 'tr1', 'ru',  # Europe\n            'na1', 'br1', 'la1', 'la2',   # Americas\n            'kr', 'jp1',                  # Asia\n            'oc1', 'ph2', 'sg2', 'th2', 'tw2', 'vn2'  # SEA/Oceania\n        }\n\n        if v.lower() not in allowed_regions:\n            raise ValueError(f'Invalid region: {v}')\n\n        return v.lower()\n</code></pre>"},{"location":"operations/security/#sql-injection-prevention","title":"SQL Injection Prevention","text":"<p>Although this API doesn't use SQL databases directly, similar principles apply:</p> <pre><code># app/security/validation.py\nimport re\nfrom typing import Any, Dict, List\n\nclass SecurityValidator:\n    \"\"\"Security-focused input validation.\"\"\"\n\n    @staticmethod\n    def sanitize_string(input_str: str, max_length: int = 100) -&gt; str:\n        \"\"\"Sanitize string inputs.\"\"\"\n        if not isinstance(input_str, str):\n            raise TypeError(\"Input must be a string\")\n\n        # Remove potentially dangerous characters\n        sanitized = re.sub(r'[&lt;&gt;\"\\';\\\\&amp;]', '', input_str)\n\n        # Truncate to max length\n        sanitized = sanitized[:max_length]\n\n        return sanitized.strip()\n\n    @staticmethod\n    def validate_puuid(puuid: str) -&gt; bool:\n        \"\"\"Validate PUUID format.\"\"\"\n        pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'\n        return bool(re.match(pattern, puuid.lower()))\n\n    @staticmethod\n    def validate_match_id(match_id: str) -&gt; bool:\n        \"\"\"Validate match ID format.\"\"\"\n        pattern = r'^[A-Z0-9_]+$'\n        return bool(re.match(pattern, match_id))\n</code></pre>"},{"location":"operations/security/#rate-limiting-ddos-protection","title":"Rate Limiting &amp; DDoS Protection","text":""},{"location":"operations/security/#multi-level-rate-limiting","title":"Multi-Level Rate Limiting","text":"<pre><code># app/security/rate_limiting.py\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.util import get_remote_address\nfrom slowapi.errors import RateLimitExceeded\nfrom fastapi import Request, HTTPException\nimport redis\nimport json\n\n# Initialize rate limiter with Redis backend\nredis_client = redis.Redis(\n    host='localhost',\n    port=6379,\n    password='your-redis-password',\n    decode_responses=True\n)\n\nlimiter = Limiter(\n    key_func=get_remote_address,\n    storage_uri=\"redis://localhost:6379\",\n    default_limits=[\"1000/hour\"]  # Global limit\n)\n\n# Custom rate limit exceeded handler\nasync def rate_limit_exceeded_handler(request: Request, exc: RateLimitExceeded):\n    \"\"\"Custom handler for rate limit exceeded.\"\"\"\n    client_ip = get_remote_address(request)\n    logger.warning(f\"Rate limit exceeded for IP: {client_ip}\")\n\n    raise HTTPException(\n        status_code=429,\n        detail={\n            \"error\": \"Rate limit exceeded\",\n            \"message\": \"Too many requests. Please try again later.\",\n            \"retry_after\": exc.detail  # Seconds to wait\n        }\n    )\n\n# Apply rate limiting to sensitive endpoints\n@app.get(\"/summoner/by-name/{summonerName}\")\n@limiter.limit(\"100/minute\")  # Stricter limit for summoner lookups\nasync def get_summoner_by_name(\n    request: Request,\n    summonerName: str,\n    region: str = \"euw1\"\n):\n    \"\"\"Get summoner by name with rate limiting.\"\"\"\n    pass\n</code></pre>"},{"location":"operations/security/#ip-based-blocking","title":"IP-Based Blocking","text":"<pre><code># app/security/ip_blocking.py\nfrom typing import Set, Dict\nfrom datetime import datetime, timedelta\nimport json\n\nclass IPBlocker:\n    \"\"\"Manages IP blocking for malicious actors.\"\"\"\n\n    def __init__(self, redis_client):\n        self.redis = redis_client\n        self.block_duration = timedelta(hours=1)\n        self.permanent_block_threshold = 100  # Violations for permanent block\n\n    async def block_ip(self, ip: str, reason: str, permanent: bool = False):\n        \"\"\"Block an IP address.\"\"\"\n        block_data = {\n            \"ip\": ip,\n            \"reason\": reason,\n            \"timestamp\": datetime.now().isoformat(),\n            \"permanent\": permanent\n        }\n\n        if permanent:\n            await self.redis.set(f\"blocked_ip:{ip}\", json.dumps(block_data))\n        else:\n            await self.redis.setex(\n                f\"blocked_ip:{ip}\",\n                int(self.block_duration.total_seconds()),\n                json.dumps(block_data)\n            )\n\n    async def is_ip_blocked(self, ip: str) -&gt; bool:\n        \"\"\"Check if IP is blocked.\"\"\"\n        return await self.redis.exists(f\"blocked_ip:{ip}\")\n\n    async def record_violation(self, ip: str, violation_type: str):\n        \"\"\"Record a security violation.\"\"\"\n        violation_key = f\"violations:{ip}\"\n\n        # Increment violation count\n        count = await self.redis.incr(violation_key)\n        await self.redis.expire(violation_key, 86400)  # 24 hours\n\n        # Check if should be permanently blocked\n        if count &gt;= self.permanent_block_threshold:\n            await self.block_ip(ip, f\"Too many violations: {count}\", permanent=True)\n\n        return count\n\n# Middleware for IP blocking\n@app.middleware(\"http\")\nasync def ip_blocking_middleware(request: Request, call_next):\n    \"\"\"Check for blocked IPs before processing requests.\"\"\"\n    client_ip = get_remote_address(request)\n\n    if await ip_blocker.is_ip_blocked(client_ip):\n        raise HTTPException(\n            status_code=403,\n            detail=\"Access denied\"\n        )\n\n    response = await call_next(request)\n    return response\n</code></pre>"},{"location":"operations/security/#network-security","title":"Network Security","text":""},{"location":"operations/security/#ssltls-configuration","title":"SSL/TLS Configuration","text":""},{"location":"operations/security/#nginx-ssl-configuration","title":"Nginx SSL Configuration","text":"<pre><code># /etc/nginx/sites-available/lolstonks-api\nserver {\n    listen 443 ssl http2;\n    server_name api.yourdomain.com;\n\n    # SSL Configuration\n    ssl_certificate /etc/letsencrypt/live/api.yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/api.yourdomain.com/privkey.pem;\n\n    # Strong SSL Configuration\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384;\n    ssl_prefer_server_ciphers off;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n\n    # Security Headers\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n    add_header X-Frame-Options DENY always;\n    add_header X-Content-Type-Options nosniff always;\n    add_header X-XSS-Protection \"1; mode=block\" always;\n    add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;\n    add_header Content-Security-Policy \"default-src 'self'\"; always;\n\n    location / {\n        proxy_pass http://127.0.0.1:8080;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # SSL offloading\n        proxy_set_header X-Forwarded-Proto https;\n        proxy_set_header X-Forwarded-SSL on;\n    }\n}\n</code></pre>"},{"location":"operations/security/#application-ssl-settings","title":"Application SSL Settings","text":"<pre><code># app/security/ssl.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\n\ndef configure_security_middleware(app: FastAPI):\n    \"\"\"Configure security middleware for the FastAPI app.\"\"\"\n\n    # Force HTTPS in production\n    if os.getenv(\"ENVIRONMENT\") == \"production\":\n        app.add_middleware(HTTPSRedirectMiddleware)\n\n    # Only allow trusted hosts\n    allowed_hosts = os.getenv(\"ALLOWED_HOSTS\", \"localhost,127.0.0.1\").split(\",\")\n    app.add_middleware(\n        TrustedHostMiddleware,\n        allowed_hosts=allowed_hosts\n    )\n\n    return app\n</code></pre>"},{"location":"operations/security/#firewall-configuration","title":"Firewall Configuration","text":"<pre><code>#!/bin/bash\n# firewall_setup.sh\n\n# Reset firewall rules\nsudo ufw --force reset\n\n# Default policies\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\n\n# Allow SSH (restrict to your IP if possible)\nsudo ufw allow 22/tcp\n\n# Allow HTTP/HTTPS\nsudo ufw allow 80/tcp\nsudo ufw allow 443/tcp\n\n# Allow Redis only from localhost\nsudo ufw allow from 127.0.0.1 to any port 6379\n\n# Rate limiting for HTTP\nsudo ufw limit 80/tcp\nsudo ufw limit 443/tcp\n\n# Enable firewall\nsudo ufw --force enable\n\n# Show status\nsudo ufw status verbose\n</code></pre>"},{"location":"operations/security/#authentication-authorization","title":"Authentication &amp; Authorization","text":""},{"location":"operations/security/#api-key-authentication","title":"API Key Authentication","text":"<pre><code># app/security/auth.py\nfrom fastapi import HTTPException, Security, Depends\nfrom fastapi.security import APIKeyHeader\nimport os\nimport hashlib\nimport hmac\n\nclass APIKeyAuth:\n    \"\"\"API key authentication for admin endpoints.\"\"\"\n\n    def __init__(self):\n        self.api_key = os.getenv(\"ADMIN_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"ADMIN_API_KEY environment variable required\")\n\n    def verify_key(self, provided_key: str) -&gt; bool:\n        \"\"\"Verify provided API key using constant-time comparison.\"\"\"\n        return hmac.compare_digest(\n            hashlib.sha256(provided_key.encode()).hexdigest(),\n            hashlib.sha256(self.api_key.encode()).hexdigest()\n        )\n\n# Initialize API key authentication\napi_key_header = APIKeyHeader(name=\"X-API-Key\", auto_error=False)\nauth = APIKeyAuth()\n\nasync def verify_api_key(api_key: str = Security(api_key_header)):\n    \"\"\"Dependency for API key verification.\"\"\"\n    if not api_key or not auth.verify_key(api_key):\n        raise HTTPException(\n            status_code=403,\n            detail=\"Invalid or missing API key\"\n        )\n    return api_key\n\n# Usage in endpoints\n@app.get(\"/admin/stats\")\nasync def get_admin_stats(api_key: str = Depends(verify_api_key)):\n    \"\"\"Admin-only endpoint with API key authentication.\"\"\"\n    pass\n</code></pre>"},{"location":"operations/security/#cors-configuration","title":"CORS Configuration","text":"<pre><code># app/security/cors.py\nfrom fastapi.middleware.cors import CORSMiddleware\nimport os\n\ndef configure_cors(app: FastAPI):\n    \"\"\"Configure CORS based on environment.\"\"\"\n\n    # Production CORS settings\n    if os.getenv(\"ENVIRONMENT\") == \"production\":\n        allowed_origins = os.getenv(\"CORS_ORIGINS\", \"https://yourdomain.com\").split(\",\")\n        app.add_middleware(\n            CORSMiddleware,\n            allow_origins=allowed_origins,\n            allow_credentials=True,\n            allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n            allow_headers=[\"*\"],\n            expose_headers=[\"X-Request-ID\"]\n        )\n    else:\n        # Development CORS settings\n        app.add_middleware(\n            CORSMiddleware,\n            allow_origins=[\"*\"],\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"]\n        )\n</code></pre>"},{"location":"operations/security/#logging-monitoring","title":"Logging &amp; Monitoring","text":""},{"location":"operations/security/#security-logging","title":"Security Logging","text":"<pre><code># app/security/logging.py\nimport logging\nimport json\nfrom datetime import datetime\nfrom typing import Dict, Any\n\nclass SecurityLogger:\n    \"\"\"Specialized logger for security events.\"\"\"\n\n    def __init__(self):\n        self.logger = logging.getLogger(\"security\")\n\n        # Configure security logger\n        handler = logging.FileHandler(\"/var/log/lolstonks/security.log\")\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n\n    def log_security_event(self, event_type: str, details: Dict[str, Any]):\n        \"\"\"Log a security event.\"\"\"\n        event = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"event_type\": event_type,\n            \"details\": details\n        }\n\n        self.logger.info(json.dumps(event))\n\n    def log_blocked_request(self, ip: str, endpoint: str, reason: str):\n        \"\"\"Log a blocked request.\"\"\"\n        self.log_security_event(\"blocked_request\", {\n            \"ip\": ip,\n            \"endpoint\": endpoint,\n            \"reason\": reason\n        })\n\n    def log_rate_limit_violation(self, ip: str, endpoint: str):\n        \"\"\"Log rate limit violation.\"\"\"\n        self.log_security_event(\"rate_limit_violation\", {\n            \"ip\": ip,\n            \"endpoint\": endpoint\n        })\n\n    def log_authentication_failure(self, ip: str, key_provided: bool):\n        \"\"\"Log authentication failure.\"\"\"\n        self.log_security_event(\"auth_failure\", {\n            \"ip\": ip,\n            \"key_provided\": key_provided\n        })\n\n# Initialize security logger\nsecurity_logger = SecurityLogger()\n</code></pre>"},{"location":"operations/security/#security-monitoring","title":"Security Monitoring","text":"<pre><code># app/security/monitoring.py\nfrom prometheus_client import Counter, Histogram\nimport time\nimport hashlib\n\n# Security metrics\nSECURITY_EVENTS = Counter(\n    'lolstonks_security_events_total',\n    'Total security events',\n    ['event_type', 'severity']\n)\n\nAUTHENTICATION_ATTEMPTS = Counter(\n    'lolstonks_authentication_attempts_total',\n    'Total authentication attempts',\n    ['result']\n)\n\nRATE_LIMIT_VIOLATIONS = Counter(\n    'lolstonks_rate_limit_violations_total',\n    'Total rate limit violations',\n    ['ip', 'endpoint']\n)\n\nclass SecurityMonitor:\n    \"\"\"Security monitoring and alerting.\"\"\"\n\n    @staticmethod\n    def track_security_event(event_type: str, severity: str = \"medium\"):\n        \"\"\"Track security events for metrics.\"\"\"\n        SECURITY_EVENTS.labels(event_type=event_type, severity=severity).inc()\n\n    @staticmethod\n    def track_authentication_attempt(success: bool, ip: str):\n        \"\"\"Track authentication attempts.\"\"\"\n        result = \"success\" if success else \"failure\"\n        AUTHENTICATION_ATTEMPTS.labels(result=result).inc()\n\n        # Log suspicious patterns\n        if not success:\n            SecurityMonitor.check_suspicious_ip(ip)\n\n    @staticmethod\n    def check_suspicious_ip(ip: str):\n        \"\"\"Check for suspicious IP patterns.\"\"\"\n        # Hash IP for privacy\n        ip_hash = hashlib.sha256(ip.encode()).hexdigest()[:16]\n\n        # In production, you might check against:\n        # - Known malicious IP databases\n        # - Geographic anomalies\n        # - Unusual request patterns\n        pass\n</code></pre>"},{"location":"operations/security/#security-auditing","title":"Security Auditing","text":""},{"location":"operations/security/#regular-security-checks","title":"Regular Security Checks","text":"<pre><code>#!/bin/bash\n# security_audit.sh\n\necho \"=== LOLStonks Security Audit ===\"\necho \"Date: $(date)\"\necho\n\n# Check for exposed API keys\necho \"1. Checking for exposed API keys...\"\nif grep -r \"RGAPI-\" /home/lolstonks/lolstonks-api-gateway/ --exclude-dir=.git; then\n    echo \"\u26a0\ufe0f  WARNING: Potential exposed API keys found!\"\nelse\n    echo \"\u2705 No exposed API keys found\"\nfi\n\n# Check file permissions\necho -e \"\\n2. Checking file permissions...\"\nfind /home/lolstonks/lolstonks-api-gateway/ -type f -name \"*.env\" -exec ls -la {} \\;\n\n# Check SSL certificate expiry\necho -e \"\\n3. Checking SSL certificate...\"\nif command -v certbot &gt;/dev/null 2&gt;&amp;1; then\n    certbot certificates\nelse\n    echo \"Certbot not installed\"\nfi\n\n# Check firewall status\necho -e \"\\n4. Checking firewall status...\"\nsudo ufw status\n\n# Check running services\necho -e \"\\n5. Checking running services...\"\nsystemctl list-units --type=service --state=running | grep -E \"(nginx|redis|lolstonks)\"\n\n# Check log for suspicious activity\necho -e \"\\n6. Recent security events...\"\nif [ -f /var/log/lolstonks/security.log ]; then\n    tail -20 /var/log/lolstonks/security.log\nelse\n    echo \"Security log not found\"\nfi\n\necho -e \"\\n=== Audit Complete ===\"\n</code></pre>"},{"location":"operations/security/#security-checklist","title":"Security Checklist","text":"<ul> <li>[ ] API Key Management</li> <li>[ ] API keys stored in environment variables only</li> <li>[ ] Regular key rotation (every 20-25 days)</li> <li>[ ] Separate keys for different environments</li> <li> <p>[ ] Backup keys available for failover</p> </li> <li> <p>[ ] Input Validation</p> </li> <li>[ ] All inputs validated using Pydantic models</li> <li>[ ] String inputs sanitized and length-limited</li> <li>[ ] Pattern validation for IDs and special formats</li> <li> <p>[ ] SQL injection prevention measures in place</p> </li> <li> <p>[ ] Rate Limiting</p> </li> <li>[ ] Global rate limits configured</li> <li>[ ] Endpoint-specific rate limits for sensitive operations</li> <li>[ ] IP-based blocking for abusive behavior</li> <li> <p>[ ] DDoS protection at multiple levels</p> </li> <li> <p>[ ] Network Security</p> </li> <li>[ ] HTTPS enforced in production</li> <li>[ ] Strong SSL/TLS configuration</li> <li>[ ] Security headers implemented</li> <li>[ ] Firewall rules configured</li> <li> <p>[ ] CORS properly configured</p> </li> <li> <p>[ ] Authentication</p> </li> <li>[ ] Admin endpoints protected with API keys</li> <li>[ ] Constant-time comparison for secrets</li> <li>[ ] Secure session management</li> <li> <p>[ ] Proper logout mechanisms</p> </li> <li> <p>[ ] Logging &amp; Monitoring</p> </li> <li>[ ] Security events logged separately</li> <li>[ ] Failed authentication attempts tracked</li> <li>[ ] Suspicious activity alerts configured</li> <li> <p>[ ] Log files properly secured and rotated</p> </li> <li> <p>[ ] Regular Maintenance</p> </li> <li>[ ] Security audits performed regularly</li> <li>[ ] Dependencies kept up to date</li> <li>[ ] SSL certificates monitored for expiry</li> <li>[ ] Backup and recovery procedures tested</li> </ul> <p>This comprehensive security framework ensures the LOLStonks API Gateway remains secure against common threats while maintaining high performance and reliability.</p>"},{"location":"operations/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This comprehensive troubleshooting guide helps diagnose and resolve common issues with the LOLStonks API Gateway.</p>"},{"location":"operations/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Service Issues</li> <li>Performance Problems</li> <li>Cache and Redis Issues</li> <li>API and Rate Limiting Issues</li> <li>Network and Connectivity Issues</li> <li>Configuration Issues</li> <li>Monitoring and Debugging</li> </ul>"},{"location":"operations/troubleshooting/#service-issues","title":"Service Issues","text":""},{"location":"operations/troubleshooting/#service-wont-start","title":"Service Won't Start","text":""},{"location":"operations/troubleshooting/#symptoms","title":"Symptoms","text":"<ul> <li>Service fails to start or crashes immediately</li> <li><code>systemctl status lolstonks-api.service</code> shows failed state</li> <li>No response from health endpoint</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis-steps","title":"Diagnosis Steps","text":"<ol> <li> <p>Check Service Status <pre><code>sudo systemctl status lolstonks-api.service\n</code></pre></p> </li> <li> <p>View Service Logs <pre><code># View recent logs\nsudo journalctl -u lolstonks-api.service -n 50\n\n# Follow logs in real-time\nsudo journalctl -u lolstonks-api.service -f\n</code></pre></p> </li> <li> <p>Check Configuration <pre><code># Verify environment file exists and is readable\nsudo -u lolstonks cat /home/lolstonks/lolstonks-api-gateway/.env\n\n# Test configuration manually\nsudo -u lolstonks cd /home/lolstonks/lolstonks-api-gateway\nsudo -u lolstonks uv run python -c \"from app.config import settings; print(settings.dict())\"\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#common-causes-and-solutions","title":"Common Causes and Solutions","text":"<p>Missing Dependencies <pre><code># Reinstall dependencies\nsudo -u lolstonks cd /home/lolstonks/lolstonks-api-gateway\nsudo -u lolstonks uv pip install -e \".[docs]\"\n</code></pre></p> <p>Permission Issues <pre><code># Fix ownership\nsudo chown -R lolstonks:lolstonks /home/lolstonks/lolstonks-api-gateway\n\n# Fix permissions\nsudo chmod +x /home/lolstonks/lolstonks-api-gateway/scripts/*.py\n</code></pre></p> <p>Port Already in Use <pre><code># Check what's using the port\nsudo netstat -tulpn | grep :8080\n\n# Kill the process using the port\nsudo kill -9 &lt;PID&gt;\n</code></pre></p> <p>Invalid Configuration <pre><code># Validate environment variables\nsudo -u lolstonks bash -c 'source .env &amp;&amp; echo \"Configuration valid\"'\n</code></pre></p>"},{"location":"operations/troubleshooting/#service-crashes-or-restarts","title":"Service Crashes or Restarts","text":""},{"location":"operations/troubleshooting/#symptoms_1","title":"Symptoms","text":"<ul> <li>Service runs for a while then crashes</li> <li>Frequent automatic restarts</li> <li>Out of memory errors</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis","title":"Diagnosis","text":"<ol> <li> <p>Check Memory Usage <pre><code># Monitor memory usage\nhtop\n\n# Check OOM killer logs\nsudo dmesg | grep -i \"killed process\"\n</code></pre></p> </li> <li> <p>Check for Memory Leaks <pre><code># Monitor over time\nwhile true; do\n    echo \"$(date): $(ps -o pid,ppid,cmd,%mem,%cpu -p $(pgrep -f uvicorn))\"\n    sleep 30\ndone\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions","title":"Solutions","text":"<p>Increase Memory Limits <pre><code># Edit service file to increase memory limits\nsudo nano /etc/systemd/system/lolstonks-api.service\n# Add:\n# MemoryLimit=2G\n# MemorySwap=2G\n</code></pre></p> <p>Optimize Configuration <pre><code># In .env file\nUVICORN_WORKERS=2  # Reduce worker count\nCACHE_SIZE_LIMIT=1000000  # Reduce cache size\n</code></pre></p>"},{"location":"operations/troubleshooting/#performance-problems","title":"Performance Problems","text":""},{"location":"operations/troubleshooting/#slow-response-times","title":"Slow Response Times","text":""},{"location":"operations/troubleshooting/#symptoms_2","title":"Symptoms","text":"<ul> <li>API responses taking &gt;5 seconds</li> <li>Timeouts from client applications</li> <li>High latency on specific endpoints</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_1","title":"Diagnosis","text":"<ol> <li> <p>Benchmark Response Times <pre><code># Test response time\ncurl -w \"@curl-format.txt\" -o /dev/null -s http://localhost:8080/health\n\n# Create curl-format.txt:\n#      time_namelookup:  %{time_namelookup}\\n\n#         time_connect:  %{time_connect}\\n\n#      time_appconnect:  %{time_appconnect}\\n\n#     time_pretransfer:  %{time_pretransfer}\\n\n#        time_redirect:  %{time_redirect}\\n\n#   time_starttransfer:  %{time_starttransfer}\\n\n#                      ----------\\n\n#           time_total:  %{time_total}\\n\n</code></pre></p> </li> <li> <p>Profile the Application <pre><code># Install profiling tools\nuv pip install py-spy\n\n# Profile CPU usage\nsudo py-spy top --pid $(pgrep -f uvicorn)\n\n# Generate flame graph\nsudo py-spy record --pid $(pgrep -f uvicorn) -o profile.svg --duration 60\n</code></pre></p> </li> <li> <p>Check Resource Utilization <pre><code># CPU and memory\ntop\nhtop\n\n# Disk I/O\niostat -x 1\n\n# Network I/O\niftop\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#common-causes-and-solutions_1","title":"Common Causes and Solutions","text":"<p>High CPU Usage - Cause: Too many concurrent requests, inefficient code - Solution:   - Reduce worker count: <code>UVICORN_WORKERS=2</code>   - Implement caching: Increase cache TTL   - Optimize database queries</p> <p>High Memory Usage - Cause: Memory leaks, large cache sizes - Solution:   - Reduce cache size: <code>CACHE_SIZE_LIMIT=500000</code>   - Restart service periodically   - Profile memory usage</p> <p>Network Latency - Cause: Slow network to Riot API, DNS resolution issues - Solution:   - Use faster DNS servers: 8.8.8.8, 1.1.1.1   - Consider CDN or regional deployment   - Implement connection pooling</p>"},{"location":"operations/troubleshooting/#high-error-rates","title":"High Error Rates","text":""},{"location":"operations/troubleshooting/#symptoms_3","title":"Symptoms","text":"<ul> <li>5xx errors increasing</li> <li>429 rate limit errors</li> <li>Timeouts from Riot API</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_2","title":"Diagnosis","text":"<ol> <li> <p>Check Error Logs <pre><code># Filter for errors\nsudo journalctl -u lolstonks-api.service | grep -i error\n\n# Check specific error types\nsudo journalctl -u lolstonks-api.service | grep \"429\\|500\\|502\\|503\"\n</code></pre></p> </li> <li> <p>Monitor Riot API Status <pre><code># Test Riot API directly\ncurl -H \"X-Riot-Token: YOUR_API_KEY\" \\\n     https://euw1.api.riotgames.com/lol/status/v4/platform-data\n\n# Check status page\ncurl https://status.riotgames.com/\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions_1","title":"Solutions","text":"<p>Rate Limiting (429 Errors) <pre><code># Reduce rate limits in .env\nRIOT_RATE_LIMIT_PER_SECOND=15  # Reduce from 20\nRIOT_RATE_LIMIT_PER_2MIN=80    # Reduce from 100\n</code></pre></p> <p>Riot API Outages - Solution: Monitor Riot API status, implement circuit breakers - Monitoring: Set up alerts for API status changes</p> <p>Timeout Errors <pre><code># Increase timeouts in .env\nRIOT_REQUEST_TIMEOUT=30\nRIOT_MAX_RETRIES=5\n</code></pre></p>"},{"location":"operations/troubleshooting/#cache-and-redis-issues","title":"Cache and Redis Issues","text":""},{"location":"operations/troubleshooting/#cache-misses-or-invalidation","title":"Cache Misses or Invalidation","text":""},{"location":"operations/troubleshooting/#symptoms_4","title":"Symptoms","text":"<ul> <li>High rate of API calls to Riot servers</li> <li>Inconsistent data responses</li> <li>Poor performance</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_3","title":"Diagnosis","text":"<ol> <li> <p>Check Redis Status <pre><code># Test Redis connection\nredis-cli -a YOUR_PASSWORD ping\n\n# Check memory usage\nredis-cli -a YOUR_PASSWORD info memory\n\n# Check hit rate\nredis-cli -a YOUR_PASSWORD info stats | grep keyspace\n</code></pre></p> </li> <li> <p>Monitor Cache Performance <pre><code># Check cache keys\nredis-cli -a YOUR_PASSWORD keys \"lolstonks:*\" | wc -l\n\n# Monitor cache operations\nredis-cli -a YOUR_PASSWORD monitor\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions_2","title":"Solutions","text":"<p>Redis Connection Issues <pre><code># Check Redis service\nsudo systemctl status redis-server\n\n# Restart Redis if needed\nsudo systemctl restart redis-server\n\n# Check Redis configuration\nsudo redis-cli -a YOUR_PASSWORD config get \"*\"\n</code></pre></p> <p>Cache Eviction <pre><code># Increase Redis memory limit\n# In redis.conf:\nmaxmemory 4gb\nmaxmemory-policy allkeys-lru\n</code></pre></p> <p>Invalid Cache Keys <pre><code># Clear corrupted cache\nredis-cli -a YOUR_PASSWORD flushdb\n\n# Restart application to rebuild cache\nsudo systemctl restart lolstonks-api.service\n</code></pre></p>"},{"location":"operations/troubleshooting/#redis-memory-issues","title":"Redis Memory Issues","text":""},{"location":"operations/troubleshooting/#symptoms_5","title":"Symptoms","text":"<ul> <li>Redis using excessive memory</li> <li>Out of memory errors</li> <li>Slow Redis operations</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_4","title":"Diagnosis","text":"<pre><code># Check Redis memory usage\nredis-cli -a YOUR_PASSWORD info memory | grep used_memory_human\n\n# Check largest keys\nredis-cli -a YOUR_PASSWORD --bigkeys\n\n# Monitor memory usage over time\nwatch -n 1 'redis-cli -a YOUR_PASSWORD info memory | grep used_memory_human'\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_3","title":"Solutions","text":"<p>Memory Optimization <pre><code># In redis.conf\nmaxmemory 2gb\nmaxmemory-policy allkeys-lru\n</code></pre></p> <p>Key Expiration <pre><code># Set TTL on existing keys\nredis-cli -a YOUR_PASSWORD --eval - &lt;&lt;EOF\nfor _, key in ipairs(redis.call('keys', 'lolstonks:*')) do\n  redis.call('expire', key, 3600)\nend\nEOF\n</code></pre></p>"},{"location":"operations/troubleshooting/#api-and-rate-limiting-issues","title":"API and Rate Limiting Issues","text":""},{"location":"operations/troubleshooting/#rate-limiting-problems","title":"Rate Limiting Problems","text":""},{"location":"operations/troubleshooting/#symptoms_6","title":"Symptoms","text":"<ul> <li>429 errors from Riot API</li> <li>Requests being throttled</li> <li>Poor user experience</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_5","title":"Diagnosis","text":"<ol> <li> <p>Check Current Rate Limits <pre><code># Monitor rate limiting in logs\nsudo journalctl -u lolstonks-api.service | grep -i \"rate.*limit\"\n\n# Check API usage dashboard on Riot Developer Portal\n</code></pre></p> </li> <li> <p>Test Rate Limiting <pre><code># Quick test script\nfor i in {1..25}; do\n  curl -s -o /dev/null -w \"%{http_code}\\n\" http://localhost:8080/health\n  sleep 0.1\ndone\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions_4","title":"Solutions","text":"<p>Adjust Rate Limits <pre><code># Conservative rate limits\nRIOT_RATE_LIMIT_PER_SECOND=10\nRIOT_RATE_LIMIT_PER_2MIN=80\n</code></pre></p> <p>Implement Request Batching <pre><code># Batch multiple requests into single API calls\n# This reduces overall API usage\n</code></pre></p> <p>Add Request Queuing <pre><code># Implement request queue for high-traffic periods\n</code></pre></p>"},{"location":"operations/troubleshooting/#invalid-api-responses","title":"Invalid API Responses","text":""},{"location":"operations/troubleshooting/#symptoms_7","title":"Symptoms","text":"<ul> <li>Corrupted or incomplete data</li> <li>Invalid JSON responses</li> <li>Missing fields in API responses</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_6","title":"Diagnosis","text":"<ol> <li> <p>Validate API Response <pre><code># Test specific endpoint\ncurl -s http://localhost:8080/summoner/by-name/test?region=euw1 | jq .\n\n# Check response headers\ncurl -I http://localhost:8080/summoner/by-name/test?region=euw1\n</code></pre></p> </li> <li> <p>Check Data Validation <pre><code># Test with invalid data\ncurl -s http://localhost:8080/summoner/by-name/invalid@name?region=euw1\n</code></pre></p> </li> </ol>"},{"location":"operations/troubleshooting/#solutions_5","title":"Solutions","text":"<p>Update Pydantic Models - Cause: Riot API changed response format - Solution: Update models in <code>app/models/</code> to match new format</p> <p>Implement Data Sanitization <pre><code># Add data cleaning in API routers\ndef clean_summoner_data(data):\n    # Remove or fix invalid fields\n    return cleaned_data\n</code></pre></p>"},{"location":"operations/troubleshooting/#network-and-connectivity-issues","title":"Network and Connectivity Issues","text":""},{"location":"operations/troubleshooting/#dns-resolution-problems","title":"DNS Resolution Problems","text":""},{"location":"operations/troubleshooting/#symptoms_8","title":"Symptoms","text":"<ul> <li>Slow startup times</li> <li>Intermittent connection failures</li> <li>DNS timeout errors</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_7","title":"Diagnosis","text":"<pre><code># Test DNS resolution\nnslookup euw1.api.riotgames.com\ndig euw1.api.riotgames.com\n\n# Test with different DNS servers\nnslookup euw1.api.riotgames.com 8.8.8.8\nnslookup euw1.api.riotgames.com 1.1.1.1\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_6","title":"Solutions","text":"<p>Use Reliable DNS Servers <pre><code># Edit /etc/resolv.conf\nnameserver 8.8.8.8\nnameserver 1.1.1.1\nnameserver 208.67.222.222\n</code></pre></p> <p>Implement DNS Caching <pre><code># Install dnsmasq for local DNS caching\nsudo apt install dnsmasq\nsudo systemctl enable dnsmasq\nsudo systemctl start dnsmasq\n</code></pre></p>"},{"location":"operations/troubleshooting/#ssltls-issues","title":"SSL/TLS Issues","text":""},{"location":"operations/troubleshooting/#symptoms_9","title":"Symptoms","text":"<ul> <li>Certificate errors</li> <li>SSL handshake failures</li> <li>HTTPS connection issues</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_8","title":"Diagnosis","text":"<pre><code># Test SSL connection\nopenssl s_client -connect euw1.api.riotgames.com:443\n\n# Check certificate validity\ncurl -v https://euw1.api.riotgames.com/lol/status/v4/platform-data\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_7","title":"Solutions","text":"<p>Update CA Certificates <pre><code>sudo apt update &amp;&amp; sudo apt install ca-certificates\n</code></pre></p> <p>Configure SSL Properly <pre><code># Ensure system time is correct\nsudo timedatectl set-ntp true\n\n# Update SSL libraries\nsudo apt install openssl libssl-dev\n</code></pre></p>"},{"location":"operations/troubleshooting/#configuration-issues","title":"Configuration Issues","text":""},{"location":"operations/troubleshooting/#environment-variable-problems","title":"Environment Variable Problems","text":""},{"location":"operations/troubleshooting/#symptoms_10","title":"Symptoms","text":"<ul> <li>Service won't start</li> <li>Invalid configuration values</li> <li>Runtime errors</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_9","title":"Diagnosis","text":"<pre><code># Check environment file syntax\ncat .env | bash -n\n\n# Test configuration loading\nsudo -u lolstonks bash -c 'source .env &amp;&amp; env | grep RIOT'\n\n# Validate required variables\ngrep -E \"^(RIOT_API_KEY|REDIS_HOST)\" .env\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_8","title":"Solutions","text":"<p>Fix Environment File <pre><code># Backup and recreate\ncp .env .env.backup\nnano .env\n\n# Ensure proper format:\n# KEY=value\n# No quotes around values unless needed\n</code></pre></p> <p>Missing Required Variables <pre><code># Add missing variables to .env\necho \"RIOT_API_KEY=RGAPI-your-key-here\" &gt;&gt; .env\necho \"REDIS_HOST=localhost\" &gt;&gt; .env\n</code></pre></p>"},{"location":"operations/troubleshooting/#permissions-issues","title":"Permissions Issues","text":""},{"location":"operations/troubleshooting/#symptoms_11","title":"Symptoms","text":"<ul> <li>Permission denied errors</li> <li>File access issues</li> <li>Service startup failures</li> </ul>"},{"location":"operations/troubleshooting/#diagnosis_10","title":"Diagnosis","text":"<pre><code># Check file permissions\nls -la /home/lolstonks/lolstonks-api-gateway/\n\n# Check user permissions\nsudo -u lolstonks whoami\nsudo -u lolstonks ls -la\n\n# Check systemd service user\ngrep \"User\\|Group\" /etc/systemd/system/lolstonks-api.service\n</code></pre>"},{"location":"operations/troubleshooting/#solutions_9","title":"Solutions","text":"<p>Fix Ownership <pre><code># Set correct ownership\nsudo chown -R lolstonks:lolstonks /home/lolstonks/lolstonks-api-gateway\n</code></pre></p> <p>Fix Permissions <pre><code># Set appropriate permissions\nsudo chmod 755 /home/lolstonks/lolstonks-api-gateway\nsudo chmod 644 /home/lolstonks/lolstonks-api-gateway/.env\nsudo chmod +x /home/lolstonks/lolstonks-api-gateway/scripts/*.py\n</code></pre></p>"},{"location":"operations/troubleshooting/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"operations/troubleshooting/#health-check-script","title":"Health Check Script","text":"<p>Create a comprehensive health monitoring script:</p> <pre><code>#!/bin/bash\n# health_check.sh\n\nAPI_URL=\"http://127.0.0.1:8080/health\"\nREDIS_CLI=\"redis-cli -a YOUR_PASSWORD\"\nLOG_FILE=\"/var/log/lolstonks/health_check.log\"\n\n# Function to log with timestamp\nlog() {\n    echo \"$(date '+%Y-%m-%d %H:%M:%S') - $1\" | tee -a \"$LOG_FILE\"\n}\n\n# Check API health\ncheck_api() {\n    local response=$(curl -s -o /dev/null -w \"%{http_code}\" \"$API_URL\")\n    if [ \"$response\" != \"200\" ]; then\n        log \"API health check failed with status: $response\"\n        return 1\n    fi\n    return 0\n}\n\n# Check Redis health\ncheck_redis() {\n    local pong=$($REDIS_CLI ping 2&gt;/dev/null)\n    if [ \"$pong\" != \"PONG\" ]; then\n        log \"Redis health check failed\"\n        return 1\n    fi\n    return 0\n}\n\n# Check system resources\ncheck_resources() {\n    local cpu_usage=$(top -bn1 | grep \"Cpu(s)\" | awk '{print $2}' | cut -d'%' -f1)\n    local mem_usage=$(free | grep Mem | awk '{printf \"%.1f\", $3/$2 * 100.0}')\n\n    if (( $(echo \"$cpu_usage &gt; 80\" | bc -l) )); then\n        log \"High CPU usage: ${cpu_usage}%\"\n    fi\n\n    if (( $(echo \"$mem_usage &gt; 80\" | bc -l) )); then\n        log \"High memory usage: ${mem_usage}%\"\n    fi\n}\n\n# Main health check\nmain() {\n    log \"Starting health check\"\n\n    if ! check_api; then\n        log \"Restarting API service\"\n        sudo systemctl restart lolstonks-api.service\n    fi\n\n    if ! check_redis; then\n        log \"Restarting Redis service\"\n        sudo systemctl restart redis-server\n    fi\n\n    check_resources\n\n    log \"Health check completed\"\n}\n\nmain\n</code></pre>"},{"location":"operations/troubleshooting/#log-analysis-script","title":"Log Analysis Script","text":"<p>Create a log analysis script for troubleshooting:</p> <pre><code>#!/bin/bash\n# analyze_logs.sh\n\nLOG_FILE=\"/var/log/lolstonks/api.log\"\nERROR_PATTERN=\"(ERROR|CRITICAL|Exception|Traceback)\"\nWARNING_PATTERN=\"(WARNING|WARN)\"\n\necho \"=== Error Analysis ===\"\ngrep -E \"$ERROR_PATTERN\" \"$LOG_FILE\" | tail -20\n\necho -e \"\\n=== Warning Analysis ===\"\ngrep -E \"$WARNING_PATTERN\" \"$LOG_FILE\" | tail -20\n\necho -e \"\\n=== Response Time Analysis ===\"\ngrep \"response_time\" \"$LOG_FILE\" | tail -20 | awk '{print $NF}' | sort -n\n\necho -e \"\\n=== Top Error Endpoints ===\"\ngrep \"ERROR\" \"$LOG_FILE\" | awk '{print $6}' | sort | uniq -c | sort -nr | head -10\n</code></pre>"},{"location":"operations/troubleshooting/#performance-monitoring","title":"Performance Monitoring","text":"<p>Set up basic performance monitoring:</p> <pre><code>#!/bin/bash\n# monitor.sh\n\nAPI_PID=$(pgrep -f uvicorn)\n\nif [ -z \"$API_PID\" ]; then\n    echo \"API service not running\"\n    exit 1\nfi\n\necho \"=== CPU and Memory Usage ===\"\nps -p \"$API_PID\" -o pid,ppid,cmd,%mem,%cpu\n\necho -e \"\\n=== File Descriptors ===\"\nlsof -p \"$API_PID\" | wc -l\n\necho -e \"\\n=== Network Connections ===\"\nnetstat -p | grep \"$API_PID\" | wc -l\n\necho -e \"\\n=== Redis Memory Usage ===\"\nredis-cli -a YOUR_PASSWORD info memory | grep used_memory_human\n</code></pre> <p>This comprehensive troubleshooting guide should help diagnose and resolve most common issues with the LOLStonks API Gateway. For issues not covered here, check the service logs and consider reaching out to the development team.</p>"}]}